<!DOCTYPE HTML>
<html lang="zh-CN,en,default">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="王柏元的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://baiyuan.wang">
    <!--SEO-->

<meta name="keywords" content="" />


<meta name="description" content="在工业控制中，工控机（一般都基于Windows平台）经常需要与智能仪表通过串口进行通信。串口通信方便易行，应用广泛。 一般情况下，工控机和各智能仪表通过RS485总线进行通信。RS485的通信方..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    C/C++串口通信原理及读写与操作 |
    
    王柏元的博客 | 博学广问，自律静思
</title>

<link rel="alternate" href="/atom.xml" title="王柏元的博客" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">


    


<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">


<meta name="generator" content="Hexo 6.3.0"></head>

<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
<header class="main-header"  style="background-image:url(
    /img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Baiyuan Wang'>
            <img src="/img/avatar.jpg?rev=@@hash" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                博学广问，自律静思
            </h2>
            
        </div>
    </div>
</header>

<nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://baiyuan.wang">
                        王柏元的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa fa-home"></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/技术/"><i class="fa fa-shield"></i>
                                技术</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/岁月/"><i class="fa fa-heartbeat"></i>
                                岁月</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/极客视点/"><i class="fa fa-slideshare"></i>
                                观点</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa fa-history"></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
<section class="content-wrap">
    <div class="container">
        <div class="row">
            <main class="col-md-8 main-content m-post">
                <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="C/C++串口通信原理及读写与操作">
            
            C/C++串口通信原理及读写与操作
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2015/08/06</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p>在工业控制中，工控机（一般都基于Windows平台）经常需要与智能仪表通过串口进行通信。串口通信方便易行，应用广泛。 一般情况下，工控机和各智能仪表通过RS485总线进行通信。RS485的通信方式是半双工的，只能由作为主节点的工控PC机依次轮询网络上的各智能控制单元子节点。每次通信都是由PC机通过串口向智能控制单元发布命令，智能控制单元在接收到正确的命令后作出应答。 <a href="http://baiyuan.wang/wp-content/uploads/2015/08/20100216043335-563490202.jpg"><img src="http://baiyuan.wang/wp-content/uploads/2015/08/20100216043335-563490202.jpg" alt="20100216043335-563490202"></a> 在Win32下，可以使用两种编程方式实现串口通信，<strong>其一是使用ActiveX控件</strong>，这种方法程序简单，但欠灵活。<strong>其二是调用Windows的API函数</strong>，这种方法可以清楚地掌握串口通信的机制，并且自由灵活。本文我们只介绍API串口通信部分。 串口的操作可以有两种操作方式：同步操作方式和重叠操作方式（又称为异步操作方式）。 同步操作时，API函数会阻塞直到操作完成以后才能返回（在多线程方式中，虽然不会阻塞主线程，但是仍然会阻塞监听线程）；而重叠操作方式，API函数会立即返回，操作在后台进行，避免线程的阻塞。 无论那种操作方式，一般都通过四个步骤来完成：</p>
<ul>
<li>（1） 打开串口</li>
<li>（2） 配置串口</li>
<li>（3） 读写串口</li>
<li>（4） 关闭串口</li>
</ul>
<h2 id="1、打开串口"><a href="#1、打开串口" class="headerlink" title="1、打开串口"></a>1、打开串口</h2><p>Win32系统把文件的概念进行了扩展。无论是文件、通信设备、命名管道、邮件槽、磁盘、还是控制台，都是用API函数CreateFile来打开或创建的。该函数的原型为：</p>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><p>HANDLE CreateFile( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);</p>
<ul>
<li>**<em>lpFileName：</em>**将要打开的串口逻辑名，如”COM1”；</li>
<li>**<em>dwDesiredAccess：</em>**指定串口访问的类型，可以是读取、写入或二者并列；</li>
<li>_<strong>dwShareMode：</strong>_指定共享属性，由于串口不能共享，该参数必须置为0；</li>
<li>**<em>lpSecurityAttributes：</em>**引用安全性属性结构，缺省值为NULL；</li>
<li>_<strong>dwCreationDistribution：</strong>_创建标志，对串口操作该参数必须置为OPEN_EXISTING；</li>
<li>_<strong>dwFlagsAndAttributes：</strong>_属性描述，用于指定该串口是否进行异步操作，该值为FILE_FLAG_OVERLAPPED，表示使用异步的I&#x2F;O；该值为0，表示同步I&#x2F;O操作；</li>
<li>_<strong>hTemplateFile：</strong>_对串口而言该参数必须置为NULL。</li>
</ul>
<h3 id="同步I-O方式打开串口的示例代码：C-代码"><a href="#同步I-O方式打开串口的示例代码：C-代码" class="headerlink" title="同步I&#x2F;O方式打开串口的示例代码：C++代码"></a>同步I&#x2F;O方式打开串口的示例代码：C++代码</h3><p>HANDLE hCom; &#x2F;&#x2F;全局变量，串口句柄<br>hCom&#x3D;CreateFile(“COM1”,&#x2F;&#x2F;COM1口<br>GENERIC_READ|GENERIC_WRITE, &#x2F;&#x2F;允许读和写<br>0, &#x2F;&#x2F;独占方式<br>NULL,<br>OPEN_EXISTING, &#x2F;&#x2F;打开而不是创建<br>0, &#x2F;&#x2F;同步方式<br>NULL);<br>if(hCom&#x3D;&#x3D;(HANDLE)-1)<br>{<br>AfxMessageBox(“打开COM失败!”);<br>return FALSE;<br>}<br>return TRUE;</p>
<p> </p>
<h3 id="重叠I-O打开串口的示例代码："><a href="#重叠I-O打开串口的示例代码：" class="headerlink" title="重叠I&#x2F;O打开串口的示例代码："></a>重叠I&#x2F;O打开串口的示例代码：</h3><p>C++代码</p>
<p>HANDLE hCom; &#x2F;&#x2F;全局变量，串口句柄<br>hCom &#x3D;CreateFile(“COM1”, &#x2F;&#x2F;COM1口<br>GENERIC_READ|GENERIC_WRITE, &#x2F;&#x2F;允许读和写<br>0, &#x2F;&#x2F;独占方式<br>NULL,<br>OPEN_EXISTING, &#x2F;&#x2F;打开而不是创建<br>FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED, &#x2F;&#x2F;重叠方式<br>NULL);<br>if(hCom &#x3D;&#x3D;INVALID_HANDLE_VALUE)<br>{<br>AfxMessageBox(“打开COM失败!”);<br>return FALSE;<br>}<br>return TRUE;</p>
<p> </p>
<h2 id="2、配置串口"><a href="#2、配置串口" class="headerlink" title="2、配置串口"></a>2、配置串口</h2><p>在打开通讯设备句柄后，常常需要对串口进行一些初始化配置工作。这需要通过一个DCB结构来进行。DCB结构包含了诸如波特率、数据位数、奇偶校验和停止位数等信息。在查询或配置串口的属性时，都要用DCB结构来作为缓冲区。 一般用CreateFile打开串口后，可以调用GetCommState函数来获取串口的初始配置。要修改串口的配置，应该先修改DCB结构，然后再调用SetCommState函数设置串口。 DCB结构包含了串口的各项参数设置，下面仅介绍几个该结构常用的变量： typedef struct _DCB{ ……… DWORD BaudRate;&#x2F;&#x2F;波特率，指定通信设备的传输速率。这个成员可以是实际波特率值或者下面的常量值之一：  CBR_110，CBR_300，CBR_600，CBR_1200，CBR_2400，CBR_4800，CBR_9600，CBR_19200， CBR_38400， CBR_56000， CBR_57600， CBR_115200， CBR_128000， CBR_256000， CBR_14400 DWORD fParity; &#x2F;&#x2F; 指定奇偶校验使能。若此成员为1，允许奇偶校验检查 … BYTE ByteSize; &#x2F;&#x2F; 通信字节位数，4—8 BYTE Parity; &#x2F;&#x2F;指定奇偶校验方法。此成员可以有下列值： EVENPARITY 偶校验 NOPARITY 无校验 MARKPARITY 标记校验 ODDPARITY 奇校验 BYTE StopBits; &#x2F;&#x2F;指定停止位的位数。此成员可以有下列值： ONESTOPBIT 1位停止位 TWOSTOPBITS 2位停止位 ON 5STOPBITS   1.5位停止位 GetCommState函数可以获得COM口的设备控制块，从而获得相关参数：</p>
<p>BOOL GetCommState(<br>HANDLE hFile, &#x2F;&#x2F;标识通讯端口的句柄<br>LPDCB lpDCB &#x2F;&#x2F;指向一个设备控制块（DCB结构）的指针 );<br>SetCommState函数设置COM口的设备控制块：<br>BOOL SetCommState( HANDLE hFile, LPDCB lpDCB );</p>
<p>  除了在BCD中的设置外，程序一般还需要设置I&#x2F;O缓冲区的大小和超时。Windows用I&#x2F;O缓冲区来暂存串口输入和输出的数据。如果通信的速率较高，则应该设置较大的缓冲区。调用SetupComm函数可以设置串行口的输入和输出缓冲区的大小。 BOOL SetupComm( HANDLE hFile, &#x2F;&#x2F; 通信设备的句柄 DWORD dwInQueue, &#x2F;&#x2F; 输入缓冲区的大小（字节数） DWORD dwOutQueue &#x2F;&#x2F; 输出缓冲区的大小（字节数） ); 在用ReadFile和WriteFile读写串行口时，需要考虑超时问题。超时的作用是在指定的时间内没有读入或发送指定数量的字符，ReadFile或WriteFile的操作仍然会结束。 要查询当前的超时设置应调用GetCommTimeouts函数，该函数会填充一个COMMTIMEOUTS结构。调用SetCommTimeouts可以用某一个COMMTIMEOUTS结构的内容来设置超时。 读写串口的超时有两种：间隔超时和总超时。间隔超时是指在接收时两个字符之间的最大时延。总超时是指读写操作总共花费的最大时间。写操作只支持总超时，而读操作两种超时均支持。用COMMTIMEOUTS结构可以规定读写操作的超时。 COMMTIMEOUTS结构的定义为：</p>
<p>typedef struct _COMMTIMEOUTS {<br>DWORD ReadIntervalTimeout; &#x2F;&#x2F;读间隔超时<br>DWORD ReadTotalTimeoutMultiplier; &#x2F;&#x2F;读时间系数<br>DWORD ReadTotalTimeoutConstant; &#x2F;&#x2F;读时间常量<br>DWORD WriteTotalTimeoutMultiplier; &#x2F;&#x2F; 写时间系数<br>DWORD WriteTotalTimeoutConstant; &#x2F;&#x2F;写时间常量<br>} COMMTIMEOUTS,*LPCOMMTIMEOUTS;</p>
<p>  COMMTIMEOUTS结构的成员都以毫秒为单位。 总超时的计算公式是：总超时＝时间系数×要求读&#x2F;写的字符数＋时间常量 例如，要读入10个字符，那么读操作的总超时的计算公式为： 读总超时＝ReadTotalTimeoutMultiplier×10＋ReadTotalTimeoutConstant 可以看出：间隔超时和总超时的设置是不相关的，这可以方便通信程序灵活地设置各种超时。 如果所有写超时参数均为0，那么就不使用写超时。如果ReadIntervalTimeout为0，那么就不使用读间隔超时。如果ReadTotalTimeoutMultiplier 和 ReadTotalTimeoutConstant 都为0，则不使用读总超时。如果读间隔超时被设置成MAXDWORD并且读时间系数和读时间常量都为0，那么在读一次输入缓冲区的内容后读操作就立即返回，而不管是否读入了要求的字符。 在用重叠方式读写串口时，虽然ReadFile和WriteFile在完成操作以前就可能返回，但超时仍然是起作用的。在这种情况下，超时规定的是操作的完成时间，而不是ReadFile和WriteFile的返回时间。</p>
<h3 id="配置串口的示例代码："><a href="#配置串口的示例代码：" class="headerlink" title="配置串口的示例代码："></a>配置串口的示例代码：</h3><p>SetupComm(hCom,1024,1024); &#x2F;&#x2F;输入缓冲区和输出缓冲区的大小都是1024<br>COMMTIMEOUTS TimeOuts; &#x2F;&#x2F;设定读超时<br>TimeOuts.ReadIntervalTimeout&#x3D;1000;<br>TimeOuts.ReadTotalTimeoutMultiplier&#x3D;500;<br>TimeOuts.ReadTotalTimeoutConstant&#x3D;5000; &#x2F;&#x2F;设定写超时<br>TimeOuts.WriteTotalTimeoutMultiplier&#x3D;500;<br>TimeOuts.WriteTotalTimeoutConstant&#x3D;2000;<br>SetCommTimeouts(hCom,&amp;TimeOuts); &#x2F;&#x2F;设置超时<br>DCB dcb;<br>GetCommState(hCom,&amp;dcb);<br>dcb.BaudRate&#x3D;9600; &#x2F;&#x2F;波特率为9600<br>dcb.ByteSize&#x3D;8; &#x2F;&#x2F;每个字节有8位<br>dcb.Parity&#x3D;NOPARITY; &#x2F;&#x2F;无奇偶校验位<br>dcb.StopBits&#x3D;TWOSTOPBITS; &#x2F;&#x2F;两个停止位<br>SetCommState(hCom,&amp;dcb);<br>PurgeComm(hCom,PURGE_TXCLEAR|PURGE_RXCLEAR);</p>
<p>  在读写串口之前，还要用PurgeComm()函数清空缓冲区，该函数原型： <em><strong>BOOL PurgeComm( HANDLE hFile, &#x2F;&#x2F;串口句柄</strong></em> <em><strong>DWORD dwFlags &#x2F;&#x2F; 需要完成的操作 );</strong></em> 参数dwFlags指定要完成的操作，可以是下列值的组合： PURGE_TXABORT 中断所有写操作并立即返回，即使写操作还没有完成。 PURGE_RXABORT 中断所有读操作并立即返回，即使读操作还没有完成。 PURGE_TXCLEAR 清除输出缓冲区 PURGE_RXCLEAR 清除输入缓冲区</p>
<h2 id="3、读写串口"><a href="#3、读写串口" class="headerlink" title="3、读写串口"></a>3、读写串口</h2><p>我们使用ReadFile和WriteFile读写串口，下面是两个函数的声明：</p>
<p>BOOL ReadFile( HANDLE hFile, &#x2F;&#x2F;串口的句柄<br>&#x2F;&#x2F; 读入的数据存储的地址，<br>&#x2F;&#x2F; 即读入的数据将存储在以该指针的值为首地址的一片内存区<br>LPVOID lpBuffer,<br>&#x2F;&#x2F; 要读入的数据的字节数<br>DWORD nNumberOfBytesToRead,<br>&#x2F;&#x2F; 指向一个DWORD数值，该数值返回读操作实际读入的字节数<br>LPDWORD lpNumberOfBytesRead,<br>&#x2F;&#x2F; 重叠操作时，该参数指向一个OVERLAPPED结构，同步操作时，该参数为NULL。<br>LPOVERLAPPED lpOverlapped );<br>BOOL WriteFile( HANDLE hFile, &#x2F;&#x2F;串口的句柄<br>&#x2F;&#x2F; 写入的数据存储的地址，<br>&#x2F;&#x2F; 即以该指针的值为首地址的<br>LPCVOID lpBuffer,<br>&#x2F;&#x2F;要写入的数据的字节数<br>DWORD nNumberOfBytesToWrite,<br>&#x2F;&#x2F; 指向指向一个DWORD数值，该数值返回实际写入的字节数<br>LPDWORD lpNumberOfBytesWritten,<br>&#x2F;&#x2F; 重叠操作时，该参数指向一个OVERLAPPED结构，<br>&#x2F;&#x2F; 同步操作时，该参数为NULL。<br>LPOVERLAPPED lpOverlapped );</p>
<p>在用ReadFile和WriteFile读写串口时，既可以同步执行，也可以重叠执行。在同步执行时，函数直到操作完成后才返回。这意味着同步执行时线程会被阻塞，从而导致效率下降。在重叠执行时，即使操作还未完成，这两个函数也会立即返回，费时的I&#x2F;O操作在后台进行。 ReadFile和WriteFile函数是同步还是异步由CreateFile函数决定，如果在调用CreateFile创建句柄时指定了FILE_FLAG_OVERLAPPED标志，那么调用ReadFile和WriteFile对该句柄进行的操作就应该是重叠的；如果未指定重叠标志，则读写操作应该是同步的。ReadFile和WriteFile函数的同步或者异步应该和CreateFile函数相一致。 ReadFile函数只要在串口输入缓冲区中读入指定数量的字符，就算完成操作。而WriteFile函数不但要把指定数量的字符拷入到输出缓冲区，而且要等这些字符从串行口送出去后才算完成操作。 如果操作成功，这两个函数都返回TRUE。需要注意的是，当ReadFile和WriteFile返回FALSE时，不一定就是操作失败，线程应该调用GetLastError函数分析返回的结果。例如，在重叠操作时如果操作还未完成函数就返回，那么函数就返回FALSE，而且GetLastError函数返回ERROR_IO_PENDING。这说明重叠操作还未完成。 同步方式读写串口比较简单，下面先例举同步方式读写串口的代码：</p>
<p>&#x2F;&#x2F;同步读串口</p>
<p>char str[100];</p>
<p>DWORD wCount;&#x2F;&#x2F;读取的字节数</p>
<p>BOOL bReadStat;</p>
<p>bReadStat&#x3D;ReadFile(hCom,str,100,&amp;wCount,NULL);</p>
<p>if(!bReadStat) { AfxMessageBox(“读串口失败!”); return FALSE; } return TRUE; &#x2F;&#x2F;同步写串口</p>
<p>char lpOutBuffer[100];</p>
<p>DWORD dwBytesWrite&#x3D;100;</p>
<p>COMSTAT ComStat;</p>
<p>DWORD dwErrorFlags;</p>
<p>BOOL bWriteStat;</p>
<p>ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);</p>
<p>bWriteStat&#x3D;WriteFile(hCom,lpOutBuffer,dwBytesWrite,&amp; dwBytesWrite,NULL);</p>
<p>if(!bWriteStat) { AfxMessageBox(“写串口失败!”); }</p>
<p>PurgeComm(hCom, PURGE_TXABORT| PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);</p>
<p>  在重叠操作时,操作还未完成函数就返回。 重叠I&#x2F;O非常灵活，它也可以实现阻塞（例如我们可以设置一定要读取到一个数据才能进行到下一步操作）。有两种方法可以等待操作完成：一种方法是用象WaitForSingleObject这样的等待函数来等待OVERLAPPED结构的hEvent成员；另一种方法是调用GetOverlappedResult函数等待，后面将演示说明。 下面我们先简单说一下OVERLAPPED结构和GetOverlappedResult函数： OVERLAPPED结构 OVERLAPPED结构包含了重叠I&#x2F;O的一些信息，定义如下：</p>
<p>typedef struct _OVERLAPPED { &#x2F;&#x2F; o</p>
<p>DWORD Internal;</p>
<p>DWORD InternalHigh;</p>
<p>DWORD Offset;</p>
<p>DWORD OffsetHigh;</p>
<p>HANDLE hEvent;</p>
<p>} OVERLAPPED;</p>
<p>  在使用ReadFile和WriteFile重叠操作时，线程需要创建OVERLAPPED结构以供这两个函数使用。线程通过OVERLAPPED结构获得当前的操作状态，该结构最重要的成员是hEvent。hEvent是读写事件。当串口使用异步通讯时，函数返回时操作可能还没有完成，程序可以通过检查该事件得知是否读写完毕。 当调用ReadFile, WriteFile 函数的时候，该成员会自动被置为无信号状态；当重叠操作完成后，该成员变量会自动被置为有信号状态。 GetOverlappedResult函数 BOOL GetOverlappedResult( HANDLE hFile, &#x2F;&#x2F; 串口的句柄 &#x2F;&#x2F; 指向重叠操作开始时指定的OVERLAPPED结构 LPOVERLAPPED lpOverlapped, &#x2F;&#x2F; 指向一个32位变量，该变量的值返回实际读写操作传输的字节数。 LPDWORD lpNumberOfBytesTransferred, &#x2F;&#x2F; 该参数用于指定函数是否一直等到重叠操作结束。 &#x2F;&#x2F; 如果该参数为TRUE，函数直到操作结束才返回。 &#x2F;&#x2F; 如果该参数为FALSE，函数直接返回，这时如果操作没有完成， &#x2F;&#x2F; 通过调用GetLastError()函数会返回ERROR_IO_INCOMPLETE。 BOOL bWait ); 该函数返回重叠操作的结果，用来判断异步操作是否完成，它是通过判断OVERLAPPED结构中的hEvent是否被置位来实现的。</p>
<h3 id="异步读串口的示例代码："><a href="#异步读串口的示例代码：" class="headerlink" title="异步读串口的示例代码："></a>异步读串口的示例代码：</h3><p>char lpInBuffer[1024];</p>
<p>DWORD dwBytesRead&#x3D;1024;</p>
<p>COMSTAT ComStat;</p>
<p>DWORD dwErrorFlags;</p>
<p>OVERLAPPED m_osRead;</p>
<p>memset(&amp;m_osRead,0,sizeof(OVERLAPPED));</p>
<p>m_osRead.hEvent&#x3D;CreateEvent(NULL,TRUE,FALSE,NULL);</p>
<p>ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);</p>
<p>dwBytesRead&#x3D;min(dwBytesRead,(DWORD)ComStat.cbInQue);</p>
<p>if(!dwBytesRead) return FALSE;</p>
<p>BOOL bReadStatus;</p>
<p>bReadStatus&#x3D;ReadFile(hCom,lpInBuffer, dwBytesRead,&amp;dwBytesRead,&amp;m_osRead);</p>
<p>if(!bReadStatus)</p>
<p>&#x2F;&#x2F;如果ReadFile函数返回FALSE</p>
<p>{</p>
<p>if(GetLastError()&#x3D;&#x3D;ERROR_IO_PENDING)</p>
<p>&#x2F;&#x2F;GetLastError()函数返回ERROR_IO_PENDING,表明串口正在进行读操作</p>
<p>{</p>
<p>WaitForSingleObject(m_osRead.hEvent,2000);</p>
<p>&#x2F;&#x2F;使用WaitForSingleObject函数等待，直到读操作完成或延时已达到2秒钟</p>
<p>&#x2F;&#x2F;当串口读操作进行完毕后，m_osRead的hEvent事件会变为有信号</p>
<p>PurgeComm(hCom, PURGE_TXABORT| PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);</p>
<p>return dwBytesRead;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>PurgeComm(hCom, PURGE_TXABORT| PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);</p>
<p>return dwBytesRead;</p>
<p> </p>
<h3 id="对以上代码再作简要说明："><a href="#对以上代码再作简要说明：" class="headerlink" title="对以上代码再作简要说明："></a>对以上代码再作简要说明：</h3><p>在使用ReadFile 函数进行读操作前，应先使用ClearCommError函数清除错误。 ClearCommError函数的原型如下：</p>
<p>BOOL ClearCommError( HANDLE hFile,</p>
<p>&#x2F;&#x2F; 串口句柄LPDWORD lpErrors, &#x2F;&#x2F; 指向接收错误码的变量</p>
<p>LPCOMSTAT lpStat &#x2F;&#x2F; 指向通讯状态缓冲区 );</p>
<p>  该函数获得通信错误并报告串口的当前状态，同时，该函数清除串口的错误标志以便继续输入、输出操作。 参数lpStat指向一个COMSTAT结构，该结构返回串口状态信息。 COMSTAT结构 COMSTAT结构包含串口的信息， 结构定义如下： typedef struct _COMSTAT { &#x2F;&#x2F; cst DWORD fCtsHold : 1; &#x2F;&#x2F; Tx waiting for CTS signal DWORD fDsrHold : 1; &#x2F;&#x2F; Tx waiting for DSR signal DWORD fRlsdHold : 1; &#x2F;&#x2F; Tx waiting for RLSD signal DWORD fXoffHold : 1; &#x2F;&#x2F; Tx waiting, XOFF char rec’’d DWORD fXoffSent : 1; &#x2F;&#x2F; Tx waiting, XOFF char sent DWORD fEof : 1; &#x2F;&#x2F; EOF character sent DWORD fTxim : 1; &#x2F;&#x2F; character waiting for Tx DWORD fReserved : 25; &#x2F;&#x2F; reserved DWORD cbInQue; &#x2F;&#x2F; bytes in input buffer DWORD cbOutQue; &#x2F;&#x2F; bytes in output buffer } COMSTAT, *LPCOMSTAT; 本文只用到了cbInQue成员变量，该成员变量的值代表输入缓冲区的字节数。 最后用PurgeComm函数清空串口的输入输出缓冲区。 这段代码用WaitForSingleObject函数来等待OVERLAPPED结构的hEvent成员，下面我们再演示一段调用GetOverlappedResult函数等待的</p>
<h3 id="异步读串口示例代码："><a href="#异步读串口示例代码：" class="headerlink" title="异步读串口示例代码："></a>异步读串口示例代码：</h3><p>char lpInBuffer[1024];<br>DWORD dwBytesRead&#x3D;1024;<br>BOOL bReadStatus;<br>DWORD dwErrorFlags;<br>COMSTAT ComStat;<br>OVERLAPPED m_osRead;<br>ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);<br>if(!ComStat.cbInQue) return 0;<br>dwBytesRead&#x3D;min(dwBytesRead,(DWORD)ComStat.cbInQue);<br>bReadStatus&#x3D;ReadFile(hCom, lpInBuffer,dwBytesRead, &amp;dwBytesRead,&amp;m_osRead);<br>if(!bReadStatus) &#x2F;&#x2F;如果ReadFile函数返回FALSE<br>{ if(GetLastError()&#x3D;&#x3D;ERROR_IO_PENDING)<br>{ GetOverlappedResult(hCom, &amp;m_osRead,&amp;dwBytesRead,TRUE);<br>&#x2F;&#x2F; GetOverlappedResult函数的最后一个参数设为TRUE，<br>&#x2F;&#x2F;函数会一直等待，直到读操作完成或由于错误而返回。<br>return dwBytesRead; }<br>return 0; }<br>return dwBytesRead;</p>
<p> </p>
<h3 id="异步写串口的示例代码："><a href="#异步写串口的示例代码：" class="headerlink" title="异步写串口的示例代码："></a>异步写串口的示例代码：</h3><p>char buffer[1024];<br>DWORD dwBytesWritten&#x3D;1024;<br>DWORD dwErrorFlags;<br>COMSTAT ComStat;<br>OVERLAPPED m_osWrite;<br>BOOL bWriteStat;<br>bWriteStat&#x3D;WriteFile(hCom,buffer,dwBytesWritten, &amp;dwBytesWritten,&amp;m_OsWrite);<br>if(!bWriteStat)<br>{ if(GetLastError()&#x3D;&#x3D;ERROR_IO_PENDING)<br>{ WaitForSingleObject(m_osWrite.hEvent,1000);<br>return dwBytesWritten; }<br>return 0; }<br>return dwBytesWritten;</p>
<p> </p>
<h2 id="4、关闭串口"><a href="#4、关闭串口" class="headerlink" title="4、关闭串口"></a>4、关闭串口</h2><p>利用API函数关闭串口非常简单，只需使用CreateFile函数返回的句柄作为参数调用CloseHandle即可：</p>
<p>BOOL CloseHandle(<br>HANDLE hObject; &#x2F;&#x2F;handle to object to close<br>);</p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系获得授权 ©<a href="/" target="_blank">王柏元的博客</a>, <b>非商业转载请务必注明: </b></br>
原文出处：
                <a href="https://baiyuan.wang/c-serial-communication-write-reading.html" target="_blank">王柏元的博客 >> C/C++串口通信原理及读写与操作</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/baidu-face-recognition-open-for-first-time.html" class="pre-post btn btn-default" title='百度人脸识别服务首次对外开放'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            百度人脸识别服务首次对外开放</span>
    </a>
    
    
    <a href="/use-of-memory-do-virtual-memory-virtual-disk-disk.html" class="next-post btn btn-default" title='使用内存做虚拟磁盘与磁盘做虚拟内存'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            使用内存做虚拟磁盘与磁盘做虚拟内存</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
<script src="https://cdn.bootcdn.net/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script>
<link href="https://cdn.bootcdn.net/ajax/libs/gitalk/1.7.2/gitalk.min.css" rel="stylesheet">
<div id="gitalk-container">
    <div class="gt-container detail">
    
</div>

</div>
<script type="text/javascript">
var gitalk = new Gitalk({
    // Gitalk配置
    language: "zh-CN,en,default",
    clientID: "8fbc26599e94fd5e4f2d",
    clientSecret: "16d6dc93d6a850229a9fd96c74096bd5d491eb82",
    repo: "blog",
    owner: "wangbaiyuan",
    admin: ["geekeren"],
    id: "50099",
    distractionFreeMode: "true"
});
gitalk.render('gitalk-container');
</script>


    <div class="gt-container detail">
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/7a1e26ab2a0cf203f5de9d0cddfea25e.png"
                                 alt="@极客人">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                极客人
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                这个问题我没遇到过，建议你百度一下，我看见有很多人遇到这个问题
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/eab739b3bf4161ac88e7077cd075b8e8.png"
                                 alt="@Try It!">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                Try It!
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                Loaded 'APP01.EXE', no matching symbolic information found.
Loaded 'C:\Windows\SysWOW64\kernel32.dll', no matching symbolic information found.
Loaded 'C:\Windows\SysWOW64\KernelBase.dll', no matching symbolic information found.
Loaded 'C:\Windows\SysWOW64\apphelp.dll', no matching symbolic information found.

这些错误是什么意思啊？
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/7a1e26ab2a0cf203f5de9d0cddfea25e.png"
                                 alt="@极客人">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                极客人
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                这些是库里面的，不需要自己写的，你加上windows.h看看效果。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/eab739b3bf4161ac88e7077cd075b8e8.png"
                                 alt="@Try It!">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                Try It!
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                好的，谢谢，我还想问在用CreateFile，Handle等这些时，Windows.h够吗？还是我得重建头文件去定义这些函数。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/7a1e26ab2a0cf203f5de9d0cddfea25e.png"
                                 alt="@极客人">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                极客人
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                还有你有个变量hcom写成了hCom
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/7a1e26ab2a0cf203f5de9d0cddfea25e.png"
                                 alt="@极客人">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                极客人
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                这个太细节了，建议你看看代码中引用的类型，百度一下需要引用哪些头文件。肯定是要include一些东西的。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/eab739b3bf4161ac88e7077cd075b8e8.png"
                                 alt="@Try It!">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                Try It!
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                我是不是缺少头文件还是？课对应的头文件我不会写，请教一下。
还有你看我的读写功能是对的吗？我的头文件只有
#include
#include
#include
这三个。是不是应该加点什么？
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/eab739b3bf4161ac88e7077cd075b8e8.png"
                                 alt="@Try It!">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                Try It!
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-19
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                我是在vc++下编译的，错误c:\users\chongzhou\desktop\uart_terminal.cpp(62) : error C2065: 'hCom' : undeclared identifier
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/7a1e26ab2a0cf203f5de9d0cddfea25e.png"
                                 alt="@极客人">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                极客人
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-18
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                请问有提示报什么错误吗？然后你的编译环境是什么（操作系统和C/C++编译器是什么），这个代码应该在Windows下才能跑得通，比如里面用到的handle是Windows下的句柄。如果在Linux操作系统下应该是编译不过的。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <div class="gt-comments">
            <div style="position: relative;">
                <div class="gt-comment gt-comment-admin" style="transform-origin: center top;">
                    
                        <div class="gt-avatar gt-comment-avatar">
                            <img src="https://wangbaiyuan.cn/wp-content/avatars/2dd2b68e3bd19959576c5a44651aeee4.png"
                                 alt="@zc106">
                        </div>
                    

                    <div class="gt-comment-content">
                        <div class="gt-comment-header">
                            <div class="gt-comment-block-2"></div>
                            <a class="gt-comment-username">
                                zc106
                            </a>
                            
                                <span class="gt-comment-text">commented at</span>
                            
                            <span class="gt-comment-date">
                                2018-08-18
                            </span>
                        </div>
                        <div class="gt-comment-body markdown-body">
                            <p>
                                我按照上述方法编写的读写文件，为啥不能编译，我是不是缺少什么？
你能帮我看看需要改什么或者帮我调试一下吗？十分感谢





#include 
#include 
#include 
 
using namespace std;
 
int main()
{
    HANDLE hcom;
    hcom = CreateFile("COM5",GENERIC_READ | GENERIC_WRITE,0,NULL,OPEN_EXISTING 
                        ,FILE_ATTRIBUTE_NORMAL,NULL);
    if (hcom == INVALID_HANDLE_VALUE)
    {
       
		fprintf(stderr, "打开串口失败！\n");
        exit(0);
    }
    SetupComm(hcom,1024,1024);
    DCB dcb;
    GetCommState(hcom,&amp;dcb);
    dcb.BaudRate = 115200;
    dcb.ByteSize = 8;
    dcb.Parity = ODDPARITY;
    dcb.StopBits = ONESTOPBIT;
    SetCommState(hcom,&amp;dcb);
    
    ifstream fileinput;
    fileinput.open("e:\\input.txt");
    double data[100];
    for(int i=0;i&gt;data[i];
    fileinput.close();
    
   /* ifstream fin("data.txt");
    vector vec;
    while (fin)
   {
      int idata;
      fin &gt;&gt; idata;
      vec.pushback(idata);
    }*/

    DWORD dwWrittenLen = 0;
	int k=0;
    for (;;) {
    if(!WriteFile(hcom,data,8,&amp;dwWrittenLen,NULL))
    {
       	fprintf(stderr, "发送数据失败！\n");
    }
   
		k++;
          
		 printf("往串口发送数据成功！第%d次\n" ,k);
	     Sleep(10*1000);  //10s发送一次
	}
   int str[100]; 

   DWORD wCount;//读取的字节数

   BOOL bReadStat; 

   bReadStat=ReadFile(hCom,str,100,&amp;wCount,NULL);
   if(!bReadStat){ AfxMessageBox("读串口失败!"); return FALSE; } return TRUE;

    fstream fs;
    fs.open("e:\\output.txt");
    for(int i=0;i&lt;100;i++)
    fs&lt;&lt;str[i]&lt;&lt;&#039;,&#039;;
    fs.close();
 
    return 0;
}
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
</div>

</div>


            </main>
            
                <aside class="col-md-4 sidebar">
    
<div class="widget">
    <h3 class="title">
        关注我
    </h3>
    <div class="content follow_me">
        
        <a href="//github.com/geekeren" rel="external nofollow" title="github" target="_blank" class="github">
            <i class="github fa fa-github"></i>
        </a>
        
        <a href="mailto:me@mail.wangbaiyuan.cn" rel="external nofollow" title="email" target="_blank" class="email">
            <i class="envelope-o fa fa-envelope-o"></i>
        </a>
        
        <a href="//weibo.com/3734351975" rel="external nofollow" title="weibo" target="_blank" class="weibo">
            <i class="weibo fa fa-weibo"></i>
        </a>
        
        <a href="/atom.xml" rel="external nofollow" title="rss" target="_blank" class="rss">
            <i class="feed fa fa-feed"></i>
        </a>
        
    </div>
</div>


    
    <div class="widget">
        <h3 class="title">
            订阅微信公众号
        </h3>
        <div class="content subscribe_wechat">
            <div>
                <img
                        width="200"
                        src="/img/wechat.jpg" alt="扫一扫关注<br/>
《我是极客人》微信公众号
"
                />
            </div>
            <div>
                扫一扫关注<br/>
《我是极客人》微信公众号

            </div>
        </div>
    </div>


</aside>


<aside id="article-toc" role="navigation" class="col-md-4 sidebar scroll-fix">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%89%93%E5%BC%80%E4%B8%B2%E5%8F%A3"><span class="toc-text">1、打开串口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%BB%A3%E7%A0%81"><span class="toc-text">C++代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5I-O%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9AC-%E4%BB%A3%E7%A0%81"><span class="toc-text">同步I&#x2F;O方式打开串口的示例代码：C++代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0I-O%E6%89%93%E5%BC%80%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">重叠I&#x2F;O打开串口的示例代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3"><span class="toc-text">2、配置串口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">配置串口的示例代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%AF%BB%E5%86%99%E4%B8%B2%E5%8F%A3"><span class="toc-text">3、读写串口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%BB%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">异步读串口的示例代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BB%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%E5%86%8D%E4%BD%9C%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">对以上代码再作简要说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%BB%E4%B8%B2%E5%8F%A3%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">异步读串口示例代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%86%99%E4%B8%B2%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">异步写串口的示例代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3"><span class="toc-text">4、关闭串口</span></a></li></ol>
        
    </div>
</aside>



            
        </div>
    </div>
</section>
<footer class="main-footer">
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <span>&copy;
                    2014 - 2024
                    <a href="https://baiyuan.wang" target="_blank">王柏元的博客</a>
                    <a href="//beian.miit.gov.cn/" target="_blank" rel="nofollow">
                        鄂ICP备2022019264号-1</a>
                    
                </span>|
                <span>
                   
    <script
            type="text/javascript"
            src="https://s4.cnzz.com/z_stat.php?id=1254162355&web_id=1254162355"
    >
    </script>





                </span>|
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span>|
                <span>
                    Theme by <a href="https://github.com/geekeren/hexo-theme-snippet-pro" class="copyright-links"
                                target="_blank" rel="nofollow">Snippet Pro</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>


    

    <a id="back-to-top" class="icon-btn hide">
        <i class="fa fa-chevron-up"></i>
    </a>
</footer>

</body>
</html>
