{"meta":{"title":"王柏元的博客","subtitle":"博学广问，自律静思","description":"","author":"Baiyuan Wang","url":"https://baiyuan.wang","root":"/"},"pages":[{"title":"Not Found","date":"2015-03-23T14:56:26.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"404.html","permalink":"https://baiyuan.wang/404.html","excerpt":"","text":"Not found!"},{"title":"","date":"2024-03-28T02:24:50.740Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://baiyuan.wang/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"文章","date":"2015-03-23T14:56:26.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"articles/index.html","permalink":"https://baiyuan.wang/articles/index.html","excerpt":"","text":""},{"title":"留言","date":"2014-12-03T08:41:58.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"leave-message/index.html","permalink":"https://baiyuan.wang/leave-message/index.html","excerpt":"","text":"这里是我的博客的留言区，欢迎大家前来交流。"}],"posts":[{"title":"将Github打造成个人全平台作品的持续发布平台","slug":"build-github-into-a-continuous-publishing-platform-for-personal-full-platform-works","date":"2019-12-25T10:47:51.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"build-github-into-a-continuous-publishing-platform-for-personal-full-platform-works.html","link":"","permalink":"https://baiyuan.wang/build-github-into-a-continuous-publishing-platform-for-personal-full-platform-works.html","excerpt":"","text":"文章推荐群体：前端Dev、桌面端Dev、DevOps与Github羊毛党 2016年6月，Github发布了GitHub Pages功能，它允许将静态网页文件存放在github仓库上，并将其发布成web网站。借助Hexo博客框架及其周边丰富、优美的博客主题，可以让程序员使用markdown语法搭建出精美、简洁的博客网站。随后，Github page还支持自定义域名、https… 无需服务器、免费https证书，无需操心运维，一时间，不少博客主纷纷放弃wordpress，转战Github Page。 私以为这可谓广大博客主们“薅github羊毛”的迈出的第一步。 为什么说“薅github羊毛”，是因为我发现越来越多的项目在极致地开发出github的潜能，比如将github gist作为前端应用的存储后端、homebrew还将github作为包发布和审核平台 Github Page已成历史，而今天我这里介绍的除了Github Page，还将介绍如何在Github上持续发布个人全平台应用作品。 其中，“持续发布”意味着我将介绍： 如何实现作品的多平台自动打包 如何实现自动发布到github release与github page 如何自动生成Release Note 而“全平台”包括： Web端 桌面端（Linux&#x2F;Windows&#x2F;Mac） Docker镜像 这意味你开发的个人作品将支持同时发布在以上各操作系统或运行平台上，想起来是不是有点些小激动呢？ Web端：发布到Github Page鉴于“怎么在Github上部署自己的网站？怎么绑定自定义域名”可以在Google上搜到成千上万条结果，本博客便不赘述相关细节。在这里主要介绍如何将Github Page的发布过程自动化。 在这之前，我们应该有这样一个基本的共识，Github Page只支持纯前端项目。所以我们这里不妨以React.js项目为例： React.js 采用如下脚本完成打包（包括JS&#x2F;CSS构建、JS混淆minify、HTML模板渲染、manifest清单文件更新等） 1&quot;build&quot;: &quot;react-scripts build&quot;, 运行yarn build命令后，在build文件夹下将会生成上述构建产物，而使用nginx或者apache这样的HTTP服务器将该目录发布，就可以搭建一个静态网站。 通常情况下，我们常常将github repo的master分支根目录和docs目录作为github的发布目录。实际上github还支持将“gh-pages”分支作为github page发布分支。 这里推荐一个npm库gh-pages，它可以将指定目录文件发布到gh-pages分支的npm库，项目主页：https://github.com/tschaub/gh-pages 使用yarn install gh-pages 后在package.json添加发布脚本 1&quot;release:web&quot;: &quot;gh-pages -d build&quot;, 运行 yarn release:web即可自动发布。 桌面端：基于Electron多平台Web APPElectron是由Github开发，同时包含Chromium和Node.js运行时环境的跨平台桌面应用平台。它可以打包生成运行在Windows、Mac、Linux等多种操作系统的安装包。常用的Virtual Studio Code、Slack APP就是基于Electron开发。 实现自动构建多平台版本建议采用electron-builder npm库打包electron应用 yarn add -D electron-builder 打包脚本electron-builder.yml 12345678910111213141516171819202122appId: cn.wangbaiyuan.magpiefiles:- build/**/*- node_modules/**/*productName: Magpie幸运抽奖artifactName: &#x27;$&#123;name&#125;-$&#123;version&#125;-for-$&#123;os&#125;-$&#123;arch&#125;.$&#123;ext&#125;&#x27;icon: build/icon.pngnsis: runAfterFinish: false deleteAppDataOnUninstall: true allowToChangeInstallationDirectory: true oneClick: false installerLanguages: zh_CN language: &#x27;2052&#x27; perMachine: true createDesktopShortcut: truewin: target: nsismac: target: dmglinux: target: deb electron-builder可以帮助我们完成electron应用的安装包打包，文件名加版本号，以及混淆加密。 DockerDockerhub除了是一个公用的docker镜像仓库，同时帮助我们在无需CI&#x2F;CD的情况下免费、自动地构建docker镜像，具体可以参考https://baiyuan.wang/using-dockerhub-continually-build-container-mirroring.html 实现在Github Release时自动构建Docker镜像并推送到Dockerhub 根据Release版本号给镜像打版本标签、Latest标签 利用Release-it自动化发布过程release-it npm库可以实现发布的自动化，实现以下功能 自动升级package.json版本号 自动创建Github Release 上传产出物（Electron APP） 自动添加Release Note 123456789101112hooks: after:bump: yarn dist after:git:release: yarn release:webgit: tagName: v$&#123;version&#125;github: release: true assets: - dist/*-mac.zip - dist/*-win.exe - dist/*-linux.deb 开源项目更多请参考示例作品：https://github.com/geekeren/Magpie-LuckyDraw","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"NodeJs web项目集成调用链追踪","slug":"nodejs-web项目集成调用链追踪","date":"2019-12-23T05:11:14.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"nodejs-web项目集成调用链追踪.html","link":"","permalink":"https://baiyuan.wang/nodejs-web%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E8%B0%83%E7%94%A8%E9%93%BE%E8%BF%BD%E8%B8%AA.html","excerpt":"","text":"在微服务架构中，一次用户请求往往调用多个服务，微服务调用链追踪工具可以 在用户请求发生错误时，帮助我们定位root cause 在性能优化时提供可观测性指标，找到架构中最耗时的服务和API请求，帮助我们对症下药 现在的NodeJs web项目比较流行地采用express作为服务器，axios也是一款比较流行的HTTP客户端。微服务的特点之一，自己作为服务端的同时，也为作为客户端访问其它服务。所以集成调用链追踪的关键在于： 集成server，处理客户端请求。通常会有现成的框架实现了此功能：构造新的，或者从上游的HTTP 请求的header中获取一个包含tracing的结构体（如x-b3-spanid） 集成client，在发出请求和返回数据时记录请求，zipkin等工具需要知道每个请求的请求时间、返回码、路径等等。 将server的请求头tracing数据传递到客户端 传统微服务（非istio）工具方法 123456789101112131415161718192021222324const &#123; Tracer, ExplicitContext, ConsoleRecorder &#125; = require(&#x27;zipkin&#x27;);const &#123; expressMiddleware &#125;= require(&#x27;zipkin-instrumentation-express&#x27;);const recorder = new ConsoleRecorder();const &#123; get &#125; = require(&#x27;lodash&#x27;);const zipkinTracer = new Tracer(&#123; ctxImpl: new ExplicitContext(), recorder, localServiceName: &#x27;&lt;YOUR\\_SERVICE\\_NAME&gt;&#x27;&#125;);const zipkinMiddleware = expressMiddleware(&#123; tracer: zipkinTracer &#125;);const getTraceIdFromRequest = req =&gt; get(req, &#x27;\\_trace\\_id&#x27;);const isolateZipkinContextByRequest = (req, res, next) =&gt; &#123; zipkinTracer.scoped(() =&gt; &#123; zipkinTracer.setId(getTraceIdFromRequest(req)); next(); &#125;);&#125;;module.exports = &#123; zipkinTracer, zipkinMiddleware, isolateZipkinContextByRequest,&#125;; express 服务器路由集成zipkin 12router.use(zipkinMiddleware);router.use(isolateZipkinContextByRequest); 由于nodejs是主线程为单线程的服务器语言，高并发由异步消息队列完成。所以保证从服务器端传递tracing信息和客户端tracing信息在同一个“上下文”，不能简单地采用一个全局变量来保存tracing信息。此处的isolateZipkinContextByRequest至关重要， axios客户端集成zipkin12345678910111213141516171819const axios = require(&#x27;axios&#x27;);const wrapAxios = require(&#x27;zipkin-instrumentation-axiosjs&#x27;);const &#123; Tracer, ExplicitContext, ConsoleRecorder &#125; = require(&#x27;zipkin&#x27;);const ctxImpl = new ExplicitContext();const recorder = new ConsoleRecorder();const localServiceName = &#x27;service-a&#x27;; // name of this applicationconst tracer = new Tracer(&#123; ctxImpl, recorder, localServiceName &#125;);const remoteServiceName = &#x27;weather-api&#x27;;const zipkinAxios = wrapAxios(axios, &#123; tracer, remoteServiceName &#125;);zipkinAxios.get(&#x27;/user?ID=12345&#x27;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 详见：https://github.com/openzipkin/zipkin-js/tree/master/packages/zipkin-instrumentation-axiosjs istio相比传统的K8S架构，由于service mesh使用sidecar的方式代理了pod的所有网络请求，构造请求头、和记录请求路径、请求返回码等操作可以在sidebar等istio组件上实现。 所以在istio语境下我们只需要实现HTTP header中的tracing信息从服务端到客户端的传递。同样的原因，nodejs是单线程语言，不能通过一个thread级别隔离的全局变量来保存tracing信息，同时通过层层函数调用栈的方式来传递request的tracing信息则过于麻烦。express库本身没有提供类似于spring或者PHP中的session的会话对象，这里会引入一个“express-http-context”的npm库完成request之间的数据“隔离”。 获取请求中的tracing header123456789101112131415161718const &#123; pick &#125; = require(&#x27;lodash&#x27;);module.exports = &#123; getForwardHeaders(req) &#123; return pick(req.headers, [&#x27;x-request-id&#x27;, &#x27;x-b3-traceid&#x27;, &#x27;x-b3-spanid&#x27;, &#x27;x-b3-parentspanid&#x27;, &#x27;x-b3-sampled&#x27;, &#x27;x-b3-flags&#x27;, &#x27;x-ot-span-context&#x27;, &#x27;x-datadog-trace-id&#x27;, &#x27;x-datadog-parent-id&#x27;, &#x27;x-datadog-sampled&#x27; ] ) || &#123;&#125;; &#125;&#125;; express的集成代码： 123456789101112131415161718192021222324const &#123; getForwardHeaders &#125; = require(&#x27;./util/tracer&#x27;);const app = express();const httpContext = require(&#x27;express-http-context&#x27;);app.use(httpContext.middleware);app.use((req, res, next) =&gt; &#123; httpContext.set(&#x27;traceHeaders&#x27;, getForwardHeaders(req)); next();&#125;);client的集成代码：```jsconst axios = require(&#x27;axios&#x27;);const httpContext = require(&#x27;express-http-context&#x27;);// 关键代码config.headers = Object.assign(config.headers || &#123;&#125;, httpContext.get(&#x27;traceHeaders&#x27;));axios(config) .then(res =&gt; &#123; // &#125;) .catch(err =&gt; &#123; // &#125;) 参考资料 zipkin链路追踪原理：https://www.cnblogs.com/iiiiiher/p/10256676.html","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"定期清理虚拟机上的docker资源","slug":"periodically-clean-up-the-docker-resources-on-the-virtual-machine","date":"2019-12-19T02:15:46.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"periodically-clean-up-the-docker-resources-on-the-virtual-machine.html","link":"","permalink":"https://baiyuan.wang/periodically-clean-up-the-docker-resources-on-the-virtual-machine.html","excerpt":"","text":"在部署持续集成流水线项目的虚拟机上，随着构建次数的增加，机器上的docker镜像等资源会越来越多，最终将机器占满。本项目是帮助DevOps人员自动清理机器上的docker资源。 开源项目：https://github.com/geekeren/docker-cleaner 定期清理脚本1234567891011#!/bin/bashset -ewhile true; do echo &quot;Starting an new job to clean Docker...&quot; echo &quot;CLEAN\\_FILTER:$&#123;CLEAN\\_FILTER&#125;, CLEAN\\_INTERVAL: $&#123;CLEAN\\_INTERVAL&#125;&quot; docker system prune -a -f --filter $&#123;CLEAN_FILTER&#125; echo &quot;All docker images after cleaning are at below:&quot; docker images -a echo &quot;Clean Docker job finised, next job will start after $&#123;CLEAN_INTERVAL&#125; seconds&quot; sleep $CLEAN_INTERVALdone Dockerfile123456FROM dockerENV CLEAN_INTERVAL=3600ENV CLEAN_FILTER=&quot;until=48h&quot;WORKDIR /appCOPY . .CMD \\[&quot;sh&quot;, &quot;./clean_docker.sh&quot;\\] K8S部署为什么是K8S部署？理论上K8S部署的服务我们一般不会关心服务的docker镜像会不会把机器占满的问题，那么为什么我还要写K8S部署呢？ 这主要用于 CI Agent跑在K8S上的情况。以微软Azure DevOps K8S Agent为例，https://github.com/Azure/helm-vsts-agent，其agent会将宿主机的docker.sock挂载在K8S node上，如果agent存在构建docker镜像的行为，就会导致agent构建出来的docker 镜像已经“脱离”了K8S的控制 12345678910111213141516171819202122232425262728293031323334353637---apiVersion: extensions/v1beta1kind: DaemonSetmetadata: name: docker-cleaner namespace: devopsspec: selector: matchLabels: app: docker-cleaner updateStrategy: type: RollingUpdate rollingUpdate: maxUnavailable: 10% template: metadata: labels: app: docker-cleaner spec: volumes: - name: dockersocket hostPath: path: /var/run/docker.sock containers: - name: docker-cleaner image: bywang/docker-cleaner imagePullPolicy: Always env: - name: CLEAN_INTERVAL value: 14400 resources: requests: cpu: 10m memory: 40Mi volumeMounts: - name: dockersocket mountPath: /var/run/docker.sock","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【开源】Terraform实现在Team中分享Azure订阅","slug":"open-source-terraform-implementation-sharing-azure-subscription-in-team","date":"2019-10-25T06:59:22.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"open-source-terraform-implementation-sharing-azure-subscription-in-team.html","link":"","permalink":"https://baiyuan.wang/open-source-terraform-implementation-sharing-azure-subscription-in-team.html","excerpt":"","text":"假设你属于组织中的某个团队，现在你们只有一份Azure subscription，而你是Azure订阅的所有者。那怎么怎么把一个subscription分享给其它人，同时实现： 与您的团队共享Azure，每个人都可以在您的订阅中使用Azure资源。 每个人的环境是隔离的，比如你操作不了或者至少看不见别人创建的资源 每个人的私有资源组只能由其所有者管理。 可以与所有团队成员共享一个公共资源组。 当有人离开团队时，他的资源很容易被销毁避免收费。 文章 https://lennilobel.wordpress.com/2018/10/15/adding-a-user-to-your-azure-subscription-with-resource-group-access/ 介绍了在Azure后台UI上实现这一需求，主要是在Resource Group级别进行了IAM控制。 同时，极客人将其进行了代码化：https://github.com/tf-module/azure-user-resource-group ，它实现过程如下（详情请移步开源地址） 创建一个Azure AD用户组，其中包含您的团队成员，也就是你提供的邮件地址 分别为每个成员创建它以其姓名命名的私人资源组，利用role assignment，将自己配置为私人资源组的owner。 一个给整个团队共享的公共资源组，每个成员都是其贡献者，利用role assignment，将用户组配置为该资源组的contributor。","categories":[{"name":"作品","slug":"作品","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/"},{"name":"技术","slug":"作品/技术","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"基础设施","slug":"基础设施","permalink":"https://baiyuan.wang/tags/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"}]},{"title":"密钥管理：从薪火相传的密钥到“密码即服务”","slug":"key-management-from-the-key-handed-down-from-generation-to-generation-to-password-as-a-service","date":"2019-10-10T02:49:08.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"key-management-from-the-key-handed-down-from-generation-to-generation-to-password-as-a-service.html","link":"","permalink":"https://baiyuan.wang/key-management-from-the-key-handed-down-from-generation-to-generation-to-password-as-a-service.html","excerpt":"","text":"一个可运行的软件项目通常包括两个要素：代码和密钥。我们通常会使用无版本控制的FTP和有版本控制的SVN、git等成熟的工具进行代码管理；而在我参加的大大小小、许许多多的项目中，密钥管理似乎缺乏成熟或标准的实践。本文将历数一下笔者在各个使用过的密钥管理实践并分析他们的优缺点。最后给大家推荐一款密钥管理工具：vault。 在软件项目开发中，密钥常常应用于下面四个场景： 本地开发：通常包括开发环境的数据库密码、用于访问第三方API的token、一些私有程序包仓库的凭证等。 CICD流水线：比如Push Docker镜像的Docker仓库的访问凭证、用于部署的云服务凭证（AWS Secret等）、用于访问K8S集群的token等 运行线上服务：线上服务启动所需的数据库密码、API Token等等，同时可能需要管理用于多套环境的不同密钥。 线上运维：线上发生事故时，需要在本地登入堡垒机（跳板机）的SSH Key或集群的访问凭证。 本地开发：“薪火相传”的密钥文件当我们加入一个团队时，通常会有一个Readme文档告诉你项目代码库的下载链接。除此之外它会告诉你需要向团队“前辈”索要密钥文件，不然你的代码是不能在本地启动的。同时有人告诉你，这个密钥文件千万不要加入到git仓库中。 这种“薪火相传”的密钥管理方式，是最原始也是最常见的方式。它常常会伴随这样几个问题： 密钥更换或者引入新的密钥后，团队其它成员因为没有得到最新的密钥文件，导致服务在本地起不来。 比如你会听到这样的对话： A: “我拉了一下最近的代码，怎么就跑不起来了？” 坐在旁边的B突然想起了什么：“好吧，我想起来了！我改了一下数据库密码，忘记告诉你了，我把最新的密钥发给你。”或者“我新加了一个功能因为使用API-KEY要访问消息队列，我在自己本地的环境变量里面加上了这个KEY，忘记告诉你们了” 随后B把最新的密钥文件传给了A。几天后，同在项目的C也遇到了同样的问题…… 误提交到代码仓库问题： 相信已经不止一次地听人提醒：千万不要将密钥文件明文提交到git。但是密钥泄露在代码仓库的问题依旧时有发生。 本地开发：将密钥加密后存放在Git仓库密钥和代码一样，在团队项目中同样需要进行共享、同步。密钥放在git仓库中本来是可以解决团队协作问题的，只不是不能被明文存储。那么，如果是将密钥加密后再提交到git仓库呢？ git-crypt便是这样一款可将git仓库中的密钥文件进行透明加密和解密的工具。它可以将密钥文件在push时加密，在pull下来后解密。更多介绍和使用说明可以参考：https://github.com/AGWA/git-crypt 借助git版本控制工具，它可以实现： 使用git进行密码共享 密钥的版本控制 用户权限管理 问题： 密码可能在多个服务中使用，怎么同步？ 持续集成流水线中的密钥管理 在现在的Web项目的CI&#x2F;CD流程中，通常会将项目代码经过构建打包生成docker镜像（制品）；在部署阶段，不同环境会采用相同的docker镜像，但是会使用不同的环境变量（比如集群、域名、数据库地址密码等）传入到docker的运行时，从而完成在不同环境的部署。 环境（变量）在不同的CI&#x2F;CD中有不同形式，比如的Jenkins的Credential、GoCD的Environment、CircleCI的Context。 如果将所有的部署与运行时所需要的密钥数据都保存到pipeline上，会导致下面的问题 过多的密码字段，将密码作为环境变量一个个传递到服务十分复杂 pipeline存环境变量一般加密后难以解密，如果你设置完自己都忘记了，那这个环境就彻底忘了 解决的办法一般是在pipeline上保存尽量少的密钥字段，我们通过一次认证就可以具备获取所有密钥数据的权限。 密码即服务：Hashicorp Vault在云和基础设施自动化时代，我们应该知道一家名为Hashcorp的公司，其代表作有知名的terraform、consul、packer、vagrant。vault也是这家公司的产品之一，它通过API将密码以服务的方式暴露出去。它可以提供： 中心化的密码服务 更安全的加密存储 密码的服务化 丰富的第三方集成：实现认证的扩展、多平台密钥管理 服务化后的vault可以做到 与Github身份认证集成，比如你可以做到只允许在特定git organization下的用户才能获取密钥 签发临时的SSH证书：比如你只允许一个30分钟内有效的SSH KEY来登录堡垒机 生成临时的AWS KEY：比如你只能用一个30分钟内有效的AWS凭证 定期更换数据库密码，因为数据库长期不更换会加大泄露的风险 OTP：基于时间的临时密码 密码权限策略：只允许特定的微服务读取或者写入指定的密钥 密码的revoke（同事下项目了怎么办？） 最佳实践 不在本地持久化存储密钥，密钥的只存于当前terminal的环境变量里并随terminal session关闭而销毁 密钥是有时效性的，定期轮换 密钥获取者是有身份的，并且有权限控制 团队成员下项目时，revoke成员的token","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://baiyuan.wang/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"敏捷会议中的cycle time","slug":"the-cycle-time-meeting-in-agile-process","date":"2019-08-31T15:28:49.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"the-cycle-time-meeting-in-agile-process.html","link":"","permalink":"https://baiyuan.wang/the-cycle-time-meeting-in-agile-process.html","excerpt":"","text":"《人月神话》中提到了软件工程中的Brooks法则： 向进度落后的项目中增加人手，只会使进度更加落后 Brooks法则并不是像数据公式一样有严谨的推理，而且也没有介绍一个解决进度落后、除了增加人手以外还有什么通用方法。 实际上，敏捷会议中有一个叫做Cycle time。Cycle time的初衷应该就是解决这个问题，找出估算和实际时间出入很大的卡，对着这些卡，实际时间花的比估算的多，原因是什么，有什么可以采取的action；花的时间比估算的少，是为什么，有什么可以分享的东西。 还有一个作用就是让团队知道产生估算有出入的具体细节，做这张卡的人可以做一个澄清，一方面可以寻求团队帮助，另一方面当事人吐槽一下，可能他也很委屈，大家都抱怨这个做慢了，却不晓得是因为我趟了好多坑，这些坑是之前没遇到的；或者是之前估卡的scope变大了。 没有银弹，许多事情都需要case by case地进行分析，而Cycle time就是提供这种流程的实践，帮助团队发现估算有出入问题的原因。一切敏捷流程都是为了尽早暴露问题、增加沟通和加速反馈。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"业界","slug":"技术/业界","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E4%B8%9A%E7%95%8C/"}],"tags":[{"name":"敏捷","slug":"敏捷","permalink":"https://baiyuan.wang/tags/%E6%95%8F%E6%8D%B7/"}]},{"title":"【随笔】中台服务，谁为你的服务买单","slug":"who-pays-for-your-service","date":"2019-06-19T12:28:01.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"who-pays-for-your-service.html","link":"","permalink":"https://baiyuan.wang/who-pays-for-your-service.html","excerpt":"","text":"大概过程与技术原理脑洞一下：中台以后各个部门的数据以微服务API形式放在API store里面供其它部分消费，为了避免部门打架、中台成本谁来出、费用怎么收的问题。在想能不能基于istio开发为请求计费的插件（计费链），技术实现的大概思路就是就是像zipkin每个调用单元（span）加一个价格，一次API的价格等于调用链路中所有单元（span）价格的求和。 最后的大概可视化效果就是这张图的时间ms，换成人民币单位（估计不要一分钱） 比如调用一次A服务某API价格为a，一次B服务某API价格为b，调一次C服务需要调A和B，那么C调用费用就是a + b + c。其中C分别要给别的服务a和b的费用，c是给自己的。上面为了介绍思想，这里只是做一个简单的求和，其实也许我们可以做更复杂的方案。就像卖商品一样卖自己的API请求。 比如每个服务可以这样定价： 基于硬件资源：数据查询次数、CPU、内存 数据价值人为定价 以上的综合 以上可称为API as Product, Data as Product的按量收费方案。 解决了什么问题 第一个上面所说的平台服务谁来买单的问题，实际调用者买单，价格为调用单元的费用总和。 API请求的定价问题，更科学的定价方案，单纯按照API请求数，忽略了不同请求之间可能耗费硬件资源、业务逻辑复杂度的差异 衍生到数据部门，解决数据到底值多少钱的问题 收费限制了其它消费者恶意调用的问题，让他们在消费其它第三方数据服务时考虑消费成本，让他们更加节约。对于复杂度较高、数据价值较大的API提高价格，利用市场化手段将API或数据作为产品来管理API。服务提供者可以通过抬价方式限制访问，通过降价方式促销自己的数据。 为什么聊到istio istio实现了网络流量的透明代理，对其它服务没有倾入性，新建一个独立的中心服务，不用修改其它服务代码； 不用其它服务去配合一个一个在header里面加traceId，parentId，其一是麻烦，需要一个人员去协调那么多微服务团队增加组织协调成本；主要是你觉得别人会配合？我加上这玩意意味着你就要像我收费，我凭啥配合你加？也防止服务使用什么黑科技逃避收费。 中心化控制公平公道可仲裁，价格在一个地方，一目了然，API商店里面一个个API明码标价。 Q&amp;A API Gateway可以计费啊？为什么还需要这个 不是从基础架构方面计费，按业务价值；中台没有业务价值，怎么给它定义价值，而且做到每一个API请求他的价格不一样，不是简单地按调多少次来收费； 每一次API请求需要多少钱，是它自己本身花费的费用，加上它调用其它一些服务的成本 收费模式？ 比如服务A定价取一次user信息2分钱，服务B定价取一次商品信息3分钱），订单服务C调了一次user和商品，就要分别给A和B付2分钱和3分钱，然后D调C，可能它要花8分钱，然后它想知道为什么要花8分钱，于是点开调用链可以看到收费清单，上面明明白白地告诉它8毛钱花在哪里，分别给哪些服务付了多少钱。 一个公司内部的，有必要算的这么细吗？ 有必要。 第一点，我在公司内部运营部门呆过，因为免费，发现做的API各种被调，不被限制地被调。通过只是想通过收费手段来降低API的调用压力。也有些API服务可以机械性地限流，调用多少次限流，而这种模式是市场化调节。收费高你自然谨慎地调。 第二点，公司高层往往觉得公司的运营部门是一个纯成本消耗的部门，很难去衡量一个内部部门的价值。通过这种方式，可以让高层知道每个部门掌握的业务数据到底值多少钱。为其对内部部门的投资决策提供参考。 第三点，其实在一个公司里面，内部还是各种算账啊，不展开赘述。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"极客视点","slug":"技术/极客视点","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[]},{"title":"怎样让你的个人项目看起来更专业","slug":"how-to-make-your-personal-project-look-more-professional","date":"2019-06-15T05:41:31.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-make-your-personal-project-look-more-professional.html","link":"","permalink":"https://baiyuan.wang/how-to-make-your-personal-project-look-more-professional.html","excerpt":"","text":"Readme文档 包含使用方法、操作步骤和预览图、在线预览链接 在标题下面各种标签的徽章 使用敏捷看板 Github自带的敏捷开发看板工具 让项目有条不紊，优先级管理 给Story Card打上标签和milestone 一键自动化的Release Windows&#x2F;Linux&#x2F;Mac全平台支持 使用release-it工具一键自动化发布并生成Release Note 添加产出物Assets Docker镜像自动构建和自动打标签 OSchinak开源软件主页 项目地址：https://github.com/geekeren/Magpie-LuckyDraw","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"中美贸易战对软件行业有什么影响的几个观点","slug":"several-views-on-impact-of-sino-us-trade-war-on-software-industry","date":"2019-05-25T13:34:55.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"several-views-on-impact-of-sino-us-trade-war-on-software-industry.html","link":"","permalink":"https://baiyuan.wang/several-views-on-impact-of-sino-us-trade-war-on-software-industry.html","excerpt":"","text":"软件授权被禁，国内的市场就大了：用不了国外的，就会自己做，对于中国是机会也是挑战 程序员的岗位就多了，中国盗版用习惯了，要是都用正版，愿意为软件付钱，然后又买国产软件，需求就多了，市场就大了，就能让程序员多吃几年饭；现在拿来主义惯了，就不用这个程序员来做，不仅操作系统，像PS MATLAB 这种东西中国都缺啊。 现在音乐都规范版权了，如果软件方面也规范版权了，就要花钱买，有人买就要人去开发卖，外国的太贵了，中国就可以开发个便宜点的。反正中国市场那么大，便宜点也有钱赚；而要开发这些东西，就要程序员，就业就好了 现在的中国的软件行业都窝在互联网，一个个产品都做死了，来来回回就那么些东西，哪个火就搞哪个。不管做啥BAT都要搞啥，小厂搞出来，BAT跟着搞就把他灭了；中国软件行业这几年钱全放在互联网，哪像中国全是BAT在玩，而且玩的也是上层应用，搞个UI啥的，技术含量不足 美国真正厉害的是即使是软件这一块，各个领域都很牛逼，各种小公司都是世界顶尖的，旧金山随便抓一个公司都是世界顶级的；公司之前互相付license费用，做的好，一小块领域就可以让自己活下来了；在中国没有看到这种技术上的商业生态 小公司活的好，国家就业也就会好；毕竟BAT员工数量对于整个行业还是少部分，众多的小企业都能活下来带来都的是更多的就业数量；中国那么大市场，市场就是资源，做好一小块就可以活的够好，可惜资源都是大厂被把持住 中国科技是缺乏自驱力的，而从来都是自上向下的号召和政府的引导。在政府关注的领域，我相信这个领域一定能发展的好，比如航天、高铁。现在开始关注操作系统和芯片了，我相信也能发展得好，那么其他领域呢？很难看到百花齐放的氛围，这缺乏行业自己来推动技术发展的自驱力，我一直认为创新来自于自己的自驱力而是上面的压力和重视（就像好的学生是自己想学习，而不是应付老师检查作业或者应付考试）。像旧金山随便找一个公司都是世界顶尖的事情在中国还没有看到曙光。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[]},{"title":"新建NodeJS Web服务的几个最佳实践","slug":"best-practices-when-creating-node-js-web-service","date":"2019-05-16T04:28:32.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"best-practices-when-creating-node-js-web-service.html","link":"","permalink":"https://baiyuan.wang/best-practices-when-creating-node-js-web-service.html","excerpt":"","text":"在项目建立初期引入一些最佳实践可以避免后期大量复杂的重构工作，本文总结了在使用Node JS构建Web服务时的一些最佳实践，同时涉及的具体的操作步骤。 一、使用初始化脚手架所谓脚手架，就是在初始化代码库时，脚手架可以帮助自动生成一些代码和项目结构，注入一些框架。对于一个NodeJS项目，不需要我们从npm init初始化起，自己一步步安装一些依赖。 Express命令Express是目前最流行的NodeJS web框架。全局安装一个express-generator，用来初始化express项目。 全局安装命令：npm install express-generator -g 新建一个名为hello-express项目: express hello-express 使用脚手架初始化Express项目 使用Swagger脚手架当使用NodeJS 开发Web API时，强烈建议使用Swagger进行API构建与管理，以及提供API文档服务。全局安装swagger命令也可以实现初始化一个swagger项目。swagger命令可以让你在浏览器上实时直接编辑你的API定义和调试API。 初始化swagger项目 安装命令：npm install swagger -g 新建Swagger API项目：swagger project create hello-swagger，在这过程中会让你选择使用哪种Web服务器，当选择express时就可以自动引入express框架 项目结构： .├── README.md├── api│ ├── controllers│ │ ├── README.md│ │ └── hello_world.js│ ├── helpers│ │ └── README.md│ ├── mocks│ │ └── README.md│ └── swagger│ └── swagger.yaml├── app.js├── config│ ├── README.md│ └── default.yaml├── package-lock.json├── package.json└── test └── api ├── controllers │ ├── README.md │ └── hello_world.js └── helpers └── README.md 实时编辑和语法校验 启动在线编辑：swagger project edit, 此时会打开系统浏览器，在浏览器中可以直接编辑swagger文档，并进行实时语法检查，同时浏览器里面的编辑变更会回写到代码。 Swagger实时编辑和语法校验 在线调试API上图右侧部分，就是类似于 postman的API调试工具。 二、Swagger文档服务Swagger是一个最流行的的API构建与管理工具，在各种语言和框架都有相应的库可以支持，同时安装swagger-ui扩展进行API文档管理和在线调试。 其遵循OpenAPI标准，OpenAPI定义了诸如路由转发、参数定义与校验等一整套API规范。 OpenAPI规范文档：https://swagger.io/specification/ 在线API编辑器预览：https://editor.swagger.io 发布swagger文档上面的swagger命令适合在本地编辑、调试使用，当在产品（Production）环境发布文档服务时，适合引入 swagger UI 中间件 app.use(SwaggerUi(swaggerExpress.runner.swagger)); 访问http://localhost:10010/docs/#/即可查看API文档： Swagger UI 在线预览：https://petstore.swagger.io/ 完整代码如下： 12345678910111213141516SwaggerExpress.create(config, function (err, swaggerExpress) &#123; if (err) &#123; throw err; &#125; // install middleware app.use(SwaggerUi(swaggerExpress.runner.swagger)); swaggerExpress.register(app); const port = 10010; app.listen(port); if (swaggerExpress.runner.swagger.paths\\[&#x27;/hello&#x27;\\]) &#123; console.log(&#x27;try this:\\\\ncurl http://127.0.0.1:&#x27; + port + &#x27;/hello?name=Scott&#x27;); &#125;&#125;); 三、启用ES6 JS语法ECMAScript 是 JS 的语言标准，ES6是新的JS语法标准。在没有其它配置的情况下使用ES6语法会出现一下错误。我们需要引入babel做语法转换。 123456import SwaggerExpress from &#x27;swagger-express-mw&#x27;; ^^^^^^^^^^^^^^SyntaxError: Unexpected identifier at Module._compile (internal/modules/cjs/loader.js:760:23) at Object.Module._extensions..js (internal/modules/cjs/loader.js:827:10) 什么是babelBabel 是一个 JavaScript 编译器，工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。更多文档可参考：https://www.babeljs.cn/docs/ 如何配置？ 安装依赖： 1npm install -D @babel/core @babel/cli @babel/preset-env @babel/node 在根目录创建.babelrc文件，内容如下 123&#123; &quot;presets&quot;: \\[&quot;@babel/preset-env&quot;\\] &#125; 使用babel-node命令代替node1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run prod&quot;, &quot;server&quot;: &quot;node ./app.js&quot; // -&gt; &quot;babel-node ./app.js&quot;&#125; 如何处理已有的非ES6项目？ 安装一个npm module cjs-to-es6 可以做一些简单的ES6语法转化：npm install -g cjs-to-es6 参考资料 https://www.babeljs.cn/docs/ How to enable ES6 (and beyond) syntax with Node and Express：https://medium.freecodecamp.org/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab 四、文件变动监听并自动重启服务每次修改代码时我们需要重启Express来查看效果，nodemon可以在指定的文件发生修改后，帮助我们自动重启服务，提高开发效率。 安装nodemon：npm i -D nodemon 在根目录添加配置文件nodemon.json： { “exec”: “npm run dev”, “watch”: [“src&#x2F;“, “public&#x2F;“], “ext”: “js, html, css, json”} 参考文档可以更多配置：https://github.com/remy/nodemon#nodemon 五、使用ES Lint做代码风格扫描ES Lint是一款代码风格扫描工具，尤其是在团队开发时可以帮助我们规范我们的代码风格，并提供与IDE的集成做到代码纠错。 安装eslint npm i -D eslint 参考文档：https://eslint.org/docs/user-guide/getting-started 六、在代码提交时触发指定操作常常有这样的场景，持续集成要求我们在提交代码之前测试在本地是可以通过的。这个时候我们可以在注册“钩子”的方式，在代码提交之前在本地运行测试，如果测试不通过则不允许提交。那么使用husky可以这一需求： husky文档：https://github.com/typicode/husky#readme 例子1： 在git push 之前运行测试“husky”: { “hooks”: { “pre-push”: “npm run coverage &amp;&amp; npm run pact:test” } }, 例子2： 在git commit 之前运行代码风格检查和自动纠正“husky”: { “hooks”: { “pre-commit”: “npm lint” } }, 七、开启Gzip压缩提高服务响应速度开启gzip压缩可以显著提高HTTP的服务的访问速度，安装compression中间件可以非常方便地启用： import compression from ‘compression’;…app.use(compression());","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"DevOps","slug":"DevOps","permalink":"https://baiyuan.wang/tags/DevOps/"},{"name":"Node.JS","slug":"Node-JS","permalink":"https://baiyuan.wang/tags/Node-JS/"}]},{"title":"Spring框架下异步日志收集及验证是否生效","slug":"verify-effectiveness-of-asynchronous-log-collection-under-spring-framework","date":"2019-05-15T09:04:20.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"verify-effectiveness-of-asynchronous-log-collection-under-spring-framework.html","link":"","permalink":"https://baiyuan.wang/verify-effectiveness-of-asynchronous-log-collection-under-spring-framework.html","excerpt":"","text":"Logback+AsyncAppenderlogback的介绍. Logback是由log4j创始人设计的另一个开源日志组件。 为了避免日志记录会给服务带来性能问题，在项目中决定采用“异步记录日志”进行记录。这里就要使用到Logback的AsyncAppender组件。简而言之，就是AsyncAppender会在请求处理的主线程以外新建一个子线程 -“日志记录线程”进行日志输出。避免日志输出造成主线程阻塞。 在运行过程中，主线程不会直接输出日志，而是将日志以Event的方式发给日志线程，Event在日志线程中会形成一条队列。而AsyncAppender的配置项很多都是对队列的配置，比如： queueSize int BlockingQueue的最大容量，默认情况下，大小为256。 discardingThreshold int 默认情况下，当BlockingQueue还有20%容量，他将丢弃TRACE、DEBUG和INFO级别的event，只保留WARN和ERROR级别的event。为了保持所有的events，设置该值为0。 includeCallerData boolean 提取调用者数据的代价是相当昂贵的。为了提升性能，默认情况下，当event被加入到queue时，event关联的调用者数据不会被提取。默认情况下，只有”cheap”的数据，如线程名。 需要注意到点： AsyncAppender只是实现将日志事件缓存到队列，具体怎么输出日志需要在 中实现，完整代码如下： info {\"service\":\"${appName}\"} true 0 1000 Shutdown hook为了在JVM虚拟机退出之前，能将日志线程的队列中的日志处理完毕，需要注册一个shutdown hook 详见： https://logback.qos.ch/manual/appenders.html#AsyncAppender 怎样验证异步日志收集是否生效按照Logback的文档实现异步日志很简单，那么怎么验证异步日志有没有生效就是个问题。这里引入一个“VisualVM”工具，它可以列出一个Java进程所包含的线程。可以看到下面的AsyncAppender-Works-xxx就是日志收集线程。 扩展资料 Java日志框架：logback详解：https://www.cnblogs.com/xrq730/p/8628945.html Logback AsyncAppender 示例：https://examples.javacodegeeks.com/enterprise-java/logback/logback-ayncappender-example/","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://baiyuan.wang/tags/Spring/"}]},{"title":"Nginx在网站改版中实现金丝雀发布","slug":"nginxs-implementation-of-canary-release-in-website-revision","date":"2019-04-23T13:07:32.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"nginxs-implementation-of-canary-release-in-website-revision.html","link":"","permalink":"https://baiyuan.wang/nginxs-implementation-of-canary-release-in-website-revision.html","excerpt":"","text":"在网站改版中我们希望选取部分用户进行金丝雀发布来给自己的新网站做“试点”，在确认新网站使用没有问题后，会慢慢加大新网站“试点”的比重，从而用到“金丝雀发布”。 “金丝雀发布”这一典故来源于采煤行业，据说以前矿工挖煤的时候，矿工下矿井前会先把金丝雀放进去，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。 矿工们用金丝雀对矿井进行空气测试的道理没沿用到软件行业。当我们要发布应用的新版本时，我们通常只会将部分流量切到新版本，当测试新版本应用没有问题时，再慢慢加大切向新版本流量的比例，这种发布方式被称为“金丝雀发布”。 那么，我们可以怎样实现金丝雀发布呢？ 在不涉及istio的情况下，我们一般会采用Nginx反向代理服务器来实现这种流量切分，通过编写nginx.conf规则来实现。 方法一：没有“记忆”的随机流量切分12345678910111213http &#123;upstream service &#123; server &#123;new-website-url&#125; weight=10; server &#123;old-website-url&#125; weight=90;&#125;server &#123; listen 80; server_name baiyuan.wang; location / &#123; proxy_pass http://service; &#125;&#125; 这种方式常常用于配置nginx作为负载均衡时，可以控制流量导向不同应用服务器的比重，当然也可以通过用于新旧版本的流量切分。但这种方式的一个问题是用户在多次请求时，被导向的页面是随机的。比如反复刷新浏览器，有时被导向新版网站，有时被导向旧的，这显然不是我们希望发生的。 方法二：有“记忆”的流量切分所以我们希望服务能“记住”每个用户第一次访问的版本，后续的请求依旧导向到改版本。而HTTP请求是无状态的，即每个HTTP请求实际上是独立的，而不是和用户建立一个长久的会话。我们只有设置里一个“特定的标记”，服务器才能知道你是不是同一个用户，所以我们需要使用cookie来标记用户。使用cookie而不是localstorage的原因是cookie是每次都会被浏览器发往服务器端。 这里，我们使用cookie来记录用户第一次访问的版本。后续访问时读取该cookie字段来控制nginx的转发行为。 1234567891011121314151617181920212223242526http &#123; split\\_clients &quot;$&#123;http\\_user\\_agent&#125;$&#123;date\\_gmt&#125;&quot; $app_version &#123; 10% new; 90% old; &#125; map $cookie\\_split\\_version $upstream_group &#123; default $app_version; &quot;old&quot; &quot;old&quot;; &quot;new&quot; &quot;new&quot;; &#125; location = / &#123; add\\_header Set-Cookie &quot;split\\_version=$upstream_group;Path=/;Max-Age=21600;&quot;; if ($upstream_group = &quot;old&quot;) &#123; proxy\\_pass https://$old\\_url; break; &#125; if ($upstream_group = &quot;new&quot;) &#123; proxy\\_pass https://$new\\_url; break; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://baiyuan.wang/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"保护日志中的用户隐私数据","slug":"protecting-user-privacy-data-in-logs","date":"2019-04-14T13:42:03.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"protecting-user-privacy-data-in-logs.html","link":"","permalink":"https://baiyuan.wang/protecting-user-privacy-data-in-logs.html","excerpt":"","text":"2019年度“315”晚会人工智能拨打骚扰电话的情节，让大众了解到在信息时代，保护个人隐私的重要性。本篇文章分享了在日志记录中保护用户隐私数据的七个最佳实践。 与“中国人愿意用隐私交换便利性”的心态完全不同，欧美国家在个人隐私保护方面明显走得更早也更远一些。在2018年5月GDPR发布前后的一段时间里，保护个人隐私相关的需求被迅速提高了优先级，而像我这样一个开发国际化产品的普通程序员，日常工作也因此受到影响，我们放下手中的业务需求卡（Story），转而去做GDPR相关的安全需求。 一般在医疗保健或金融行业中，限制访问客户的敏感数据有着非常严格的规定，尤其欧洲GDPR颁布之后，公司泄露个人数据的后果也非常严重。在个人隐私保护方面，国内目前在法律和意识方面处于滞后的状态，但是许多人或多或少都感受到个人信息泄露给自己带来的麻烦，比如骚扰电话的增多就是最明显的例证。比较乐观的是网络安全法的发布，以及网民意识的觉醒，表明我们的个人信息保护正在路上。 对于一些面向欧美的项目，从公司最高层面，自上而下，我们采取了一系列相关动作，比如梳理我们基础设施架构图、数据流图、API数据字段分析等，其中包括保护日志中的个人信息。 安全问题的特殊性个人隐私安全和其它安全问题一样，是一个永远做不完的需求。你不能说你的网站是绝对安全的，只能说“我检查了所有目前已发现的安全漏洞列表（Checklist），并且采取了相应的防御措施，做到尽量安全”，或者说我们采取了一些很好的安全实践，比如采取了动态密码、在nginx上安装了防攻击防SQL注入插件等等。 现在的Web系统一般都配备了日志系统用于记录访问请求、分析线上事故等，比如开源的有ELK，SaaS的有DataDog、Sumo Logic 等。 在日志记录过程记录下一些用户隐私信息往往是不可避免的。诚然，开发者的个人隐私保护意识是很重要的，但有时并不一定是开发者的主动想偷窥用户信息。比如这里举一个很常见的情况，有些程序异常如果没有合理捕获，往往会输出调用堆栈，这些调用堆栈里面某些方法的参数可能就包含有个人隐私信息； 虽说没有一种一劳永逸的方式来避免个人信息出现在日志中，但我们可以通过下面的实践来尽量规避，并将这些内建在自己平时的开发工作中。下面的实践，一些涉及到了代码层面的技术实践、团队流程的优化，还有的是测试、运维上的一些措施。 首先：确定什么是隐私数据在我们深入讨论怎样避免个人隐私数据出现在日志之前，我们来界定什么是_隐私数据_： 个人可标识数据（PII）：如社会安全号码，数据组合（如名字+出生日期或姓氏+邮政编码）或用户生成的数据（如电子邮件或用户名，如blog@mail.baiyuan.wang），手机号。 健康信息 财务数据（如信用卡号） 密码 IP地址：IP地址也有可能是个人隐私数据，尤其是与个人可标识数据与其有某种绑定关系。（而2019年的3.15晚会介绍一种将MAC也变成了PII的方式） 个人隐私信息不一而足，其界定工作可能需要与熟悉GDPR的安全专家合作来完成，根据实际情况彻查应用内的数据，来确定什么是敏感的。 一、解耦隐私字段处理隐私数据时，应尽量减少系统使用这些数据的频率。比如在数据库表设计时，使用电子邮件地址Email，或者极端一点的例子，使用身份证号码（下称PID）来作为“用户”表的主键。这意味系统在访问用户数据时，都需要使用Email或者PID来建立关联关系，这样做可能会非常省事，而且系统也是完全可以工作的，但是这极大地提高了敏感字段的曝光率，出现的地方越多，意味着被日志记录下来的几率越大。 所以更好的方法是解耦出隐私数据，只在在必要时才使用它。一种常见的解决方案是将随机生成的字符串作为用户表的ID，同时建立一个“1对1”的数据库表来存储用户ID与用户数据库表主键的关系。例如： PID | 外键————————-42-12xxxx-345 |5a2_cXKrt32DcWOJpJlyhr7FhTcLPfvlEAb1eA2Hza 在用户表以外的所有数据库表，都应该使用这个随机ID进行查询，这种随机ID即使被暴露也不会泄露任何个人数据。 二、避免在URL中出现个人隐私信息比如你有一个RESTful API，通过Email来查找用户信息，则可能很容易拥有这样一个Endpoint，如：**&#x2F;user&#x2F;**。这种请求URL通常会被反向代理服务器和Web服务器记录下来，这样Email就会出现在日志当中。要将敏感数据不出现在网址之中，你可以 选项1. 不要将敏感字段用作唯一标识符，改用这些随机ID。 **选项2.**将敏感值作为POST的数据传递 与上面数据库解耦隐私字段一样，这些问题在API或数据库设计早期就需要考虑，否则可能后期需要花大量的工作来进行重构。而它的前提就是，应该要确定系统中哪些数据是敏感数据。 三、对象打印重写toString方法为了定位问题或者debug的方便，开发经常会在日志中添加一个调试信息。因为追求方便的缘故，可能写出这样的代码（将User直接打印，而不是user.username）: logger.info(“为用户$ {user}更新电子邮件); 一些程序语言，比如Java、Javascript，如果将一个对象直接进行打印，它其实是打印 toString方法返回的字符串，这样我们可以重写对象的toString方法来避免打印对象时出现的个人信息泄漏问题。 class UserAccount { id：string username：string passwordHash：string firstName：string lastName：string … public toString（）{ return “UserAccount (${this.id})”;} 如果开发人员实在“作死”的话，比如直接打印对象的字段就没有办法了，例如： logger.info(&quot;The user&#39;s details are: $&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot;); 四、结构化日志输出时屏蔽隐私字段为了日志方便查看，我们常常将日志以Json字符串的形式上传到日志服务器，这样我们查看日志可以清晰看到键值对结构。 我们可以在应用的日志输出中，遍历所有键值对信息，如果“键”存在firstName这样的字段，或者“值”中能匹配到Email，那么将对应的值替换成“”，例如： Blacklist &#x3D; [“firstName”, “lastName”]EmailRegex &#x3D; r”.+@.+”;class Logger { log(details: Map&lt;string,string&gt;) { const cleanedDetails &#x3D; details.map( (key, value) &#x3D;&gt; { if (Blacklist.contains(key) || EmailRegex.match(value)) { return (key, ““); } return (key, value); } console.log(JSON.stringify(cleanedDetails)); }} 五、将日志代码审查纳入Code ReviewCode Review是开发过程中可以保证代码质量的部分，比如在Code Review中常常会被别人指出程序漏洞、健壮性问题、改进建议等等。将日志代码的检查作为Code Review中各个成员关注的一部分。这个方面不是技术层面，而是团队Code Review流程上的改善。 如果使用的是Pull Request Template 来进行合并代码，则可能需要在模板中设置一个复选框，提示reviewer进行检查。 六、个人信息泄露测试纳入QA和自动化测试虽说目前大部分公司的实践，并没有把个人隐私泄露测试纳入测试或者QA人员的工作范围，但是这部分的工作不仅需要测试来做，而且甚至可以自动化。 比如一个用户注册的场景，测试人员可以模仿用户在Web前端表单填写姓名、Email后，检查服务器日志中是否含有这些信息。而这部分工作可以使用Selenium、Cypress等端到端测试工具，然后调用日志服务器的API来搜索这些信息是否存在，来实现自动化。 自动化的个人隐私泄露测试也可以将其纳入到CI&#x2F;CD持续集成流水线中。 七、在日志收集器上传前“打码”隐私信息在我们的项目中，一般存在两种日志收集方式 通过日志中心提供的日志收集进程（代理程序、Agent），将机器实例的标准输出或者日志文件内容，推送到日志服务器 通过AWS Lambda无服务器代码转发日志到日志中心 日志收集工具是日志到达日志中心的必经之地，在这个关口做好信息屏蔽，就可以对来自所有服务（多个微服务的情况下）的日志做集中式的处理。Datadog Agent直接提供了屏蔽隐私数据的配置，而AWS Lambda的代码则是我们可控的，可以自己实现代码层面的正则替换。 八、日志系统中配置个人隐私信息的监控告警即使有了上面的实践，我们依旧不能保证个人隐私绝对不会出现在日志中，一方面我们可以在平时Debug、查看应用日志时有意识地检查有没有含有隐私信息，另一方面我们还是可以通过一些技术手段将这一检测工作自动化，并通过告警系统通知到团队成员进行处理。 在监控系统配置Email告警 这已经在笔者所在的团队中得到实践。我们使用Datadog作为日志、监控系统，成功实现在日志中出现Email信息时，Datadog能自动发送邮件通知。但是需要指出的一点是，因为Email可以很好地通过正则表达式进行匹配，同时被很多日志系统所支持。但是对于姓名这些信息，可能只能交给人工智能了。 总结 PII Protection 从上面的阐述中可以看到，个人隐私信息的保护，已经不是请一个安全专家就能简单解决的问题，也不是单独的某个角色的工作，而是需要整个团队各个角色的通力合作。这就是DevSecOps理念。 参考资料：https:&#x2F;&#x2F;medium.com&#x2F;@joecrobak&#x2F;seven-best-practices-for-keeping-sensitive-data-out-of-logs-3d7bbd12904","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"DevOps","slug":"DevOps","permalink":"https://baiyuan.wang/tags/DevOps/"},{"name":"日志","slug":"日志","permalink":"https://baiyuan.wang/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"利用ModSecurity为你的wordpress博客保驾护航","slug":"use-modsecurity-escort-your-wordpress-blog","date":"2019-03-12T07:28:12.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"use-modsecurity-escort-your-wordpress-blog.html","link":"","permalink":"https://baiyuan.wang/use-modsecurity-escort-your-wordpress-blog.html","excerpt":"","text":"ModSecurity是一个入侵探测与阻止的引擎，它主要是用于Web应用程序所以也可以叫做Web应用程序防火墙；它可以作为Apache Web服务器的一个模块或单独的应用程序来运行。ModSecurity的目的是为增强Web应用程序的安全性，来保护Web应用程序避免遭受攻击. Availability of ModSecurity 2.9.1 ModSecurity功能特点HTTP流量记录web服务器已有的日志功能已经足够进行访问请求分析，但是就web的应用分析还有些不足，特别是大多情况下没办法记录下请求体。你的对手很清楚这 一点，所以很多时候的攻击是通过POST请求产生，并导致您的系统失明。ModSecurity充分的获取HTTP交互中的所以内容，并记录完整的请求和 响应。其日志功能可以允许您更细致的做出判断究竟什么是登录的时候，并确保相关的数据都被记录下来。一些请求和响应中的某些关键字段可能包含敏感数 据，ModSecurity可以被配置成在记录这些审计日志前隐藏它。 实时监控和攻击检测除了提供记录日志功能外，ModSecurity还能实时的监控HTTP的流量以检测攻击。在某些时候，ModSecurity做为一个WEB入侵检测工具，可以让你对发生在WEB系统上的一些可疑事件做出响应。 攻击防御和及时修补ModSecurity能够立即针对你的WEB应用系统进行攻击防御，有三种通用的方法： 1、消极(negative)安全模型：消极安全模型监控那些异常的、不常用的和通用的WEB攻击类请求。它统计每个请求的有关IP地址、应该连接、和用户帐户的异常分数，当出现较高的异常分数时，会记录日志并完全的阻止访问。 2、积极安全模开型：部署积极安全模型后，只有那些明确的请求被允许通过，其它的一律禁止。这个模式要求你对需要保护的WEB应用要非常的了解。因此积极安全模式最好是用于那种大量访问却很少更新的系统，这样才能使这种模型的维护工作量降到最低。 3、已知漏洞攻击：其规则语言使ModSecurity成为一个理想的外部修补工具，外部修补（有时是指虚拟修补）可以减少机会之窗。一些 组织修补这些应用的漏洞通常需要几周的时间，使用ModSecurity，应用系统可以从外部修补，根本不用改应用的源码（甚至时不用去管它），可以保证 你的系统安全直到有一个合适的补丁来应用到系统中。 灵活的规则引擎灵活的规则引擎是ModSecurity的核心，其实现了ModSecurity的规则语言，这是一个专用的程序语言设计的用于处理HTTP的传输 数据。ModSecurity规则语言被设计的简单易用，非常的灵活：通用的操作是简单的，而复杂的操作也是可以实现的。经过认证的 ModSecurity规则，放在ModSecurity中，包含了一整套规则，它实现了通用目的强化、协议正规化和对一些通用web应用安全问题的检 测。大量评论认为，这些规则可以用于学习研究使用。 嵌入式模式部署ModSecurity是一个可嵌入式的WEB应用防火墙，意思就是它可以做为以apache为基础的已经提供WEB服务的WEB服务器的一部分。这样的部署译意风一些特殊的优势： 1、不改变已有的网络结构。只需要花几分钟就可以为你的WEB服务器添加ModSecurity，而且由于它默认被设计为完全的被动方式，你可以自由的逐步部署并且只使用你需要的特性。同样也可以根据你的需要轻松的删除或停用它。 2、不存在单点故障。与网络设备部署方式不同，你不会给你的系统带来新的故障点。 3、绝对支持负载均衡。因为它以嵌入方式运行在WEB服务器上，ModSecurity会自动的利用附加的负载均衡特性。你不需要考虑负载均衡，除非你的系统本来就需要它。 4、极少开销。因为它在WEB服务器进程内工作，不会带来网络间接通信的负载，而且只进行最小的分析和数据交换开销。 5、加密或压缩内容没问题。许多IDS系统分析SSL流量的时候很困难，但对于ModSecurity没有麻烦，因为它工作于已解密和解压的数据环节。 基于网络的部署在基于apache的反向代理模式上ModSecurity同样能工作的很好，我们很多客户选择这样做。在这种情形下，装了ModSecurity的可以保护任一一种WEB服务器（即使它不是apache的）。 基于Wordpress Docker镜像安装ModSecurityDockerfileFROM wordpress:4.9.8-php5.6-apacheRUN apt-get update &amp;&amp; apt-get install -y libapache2-mod-security2RUN a2enmod security2 在站点配置文件中启用mod-securitySecRuleEngine On &lt;VirtualHost *:80&gt; ServerName baiyuan.wang ServerAdmin &#98;&#x6c;&#x6f;&#103;&#x40;&#109;&#97;&#105;&#108;&#x2e;&#98;&#97;&#105;&#x79;&#117;&#x61;&#x6e;&#x2e;&#119;&#97;&#x6e;&#x67; DocumentRoot &#x2F;var&#x2F;www&#x2F;html ErrorLog ${APACHE_LOG_DIR}&#x2F;error.log CustomLog ${APACHE_LOG_DIR}&#x2F;access.log cdn_combined 测试 XSS 测试 curl ‘https://baiyuan.wang/?q=&quot;&gt;alert(1)‘ SQL 注入 curl “https://baiyuan.wang/?q=&#39;1 OR 1&#x3D;1” 开源项目 https://github.com/geekeren/wordpress-env : 基于wordpress官方镜像添加HTTPS、HTTP2、Mod-Security、mod-headers支持，同时支持使用docker-compose一键构建包含mysql、redis、datadog的wordpress博客环境","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"}]},{"title":"关于持续集成-变更合并","slug":"on-continuous-integration-change-merge","date":"2019-02-21T07:47:29.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"on-continuous-integration-change-merge.html","link":"","permalink":"https://baiyuan.wang/on-continuous-integration-change-merge.html","excerpt":"","text":"发布的时候，各特性分支才merge到master，如果几个特性分支修改了相同文件并造成冲突，如果发布周期比较长的话，merge的时候可能就会造成大量冲突。个人经验，一般是尽量做到持续发布、快速迭代（尽快merge到master），其次这要求写故事卡的童鞋遵循INVEST，卡尽量小且功能无依赖并独立。在以往项目的实践一般比较灵活，小feature直接在master搞），变更比较大的在特性分支上，很少有人喜欢用feature toggle。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://baiyuan.wang/tags/CI-CD/"},{"name":"敏捷","slug":"敏捷","permalink":"https://baiyuan.wang/tags/%E6%95%8F%E6%8D%B7/"}]},{"title":"【开源】zipkin-js-instrumentation-axios: 集成axios和zipkin","slug":"zipkin-js-instrumentation-axios","date":"2019-02-19T05:47:00.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"zipkin-js-instrumentation-axios.html","link":"","permalink":"https://baiyuan.wang/zipkin-js-instrumentation-axios.html","excerpt":"","text":"Zipkin 是由Twitter公司开发并开源的分布式追踪系统，而axios则是常用的Javascript HTTP客户端。由于zipkin-js官方没有提供axios的适配，同时同类型库zipkin-jinstrumentation-axios已经破坏了axios的原有功能，为此极客人制作了本库用于集成zipkin和axios，可以支持axios原有的所有方法属性，其用法和axios完全一致。 zipkin-js-instrumentation-axiosAdds Zipkin tracing support for the axios JS HTTP client library. It supports all features of axios. Installationnpm install zipkin-js-instrumentation-axios –save UsageYou need to use wrapAxios fucntion to wrap the native axios instance, and the axios instance’s type&#x2F;functions&#x2F;attributes are not affected. As a result, you can use zipkinAxios the same as axios For example: 12345678910111213141516171819const axios = require(&#x27;axios&#x27;);const wrapAxios = require(&#x27;zipkin-js-instrumentation-axios&#x27;);const &#123; Tracer, ExplicitContext, ConsoleRecorder &#125; = require(&#x27;zipkin&#x27;);const ctxImpl = new ExplicitContext();const recorder = new ConsoleRecorder();const localServiceName = &#x27;service-a&#x27;; // name of this applicationconst tracer = new Tracer(&#123; ctxImpl, recorder, localServiceName &#125;);const remoteServiceName = &#x27;weather-api&#x27;;const zipkinAxios = wrapAxios(axios, &#123; tracer, localServiceName, remoteServiceName &#125;);zipkinAxios.get(&#x27;/user?ID=12345&#x27;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); Interceptors of Axios also supportedYou can intercept requests or responses before they are handled by then or catch. 1234567891011121314151617// Add a request interceptoraxios.interceptors.request.use(function (config) &#123; // Do something before request is sent return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;); // Add a response interceptoraxios.interceptors.response.use(function (response) &#123; // Do something with response data return response; &#125;, function (error) &#123; // Do something with response error return Promise.reject(error); &#125;); The test cases all passed123456789axios instrumentation - integration test ✓ should add headers to requests ✓ should support request shorthand (defaults to GET) ✓ should support both url and uri options ✓ should support promise callback ✓ should report 404 when path does not exist ✓ should report when service does not exist (41ms) ✓ should report when service returns 400 ✓ should report when service returns 500","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"},{"name":"微服务","slug":"微服务","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"K8S使用就绪和存活探针配置健康检查","slug":"k8s-health-examination-with-ready-survival-probes","date":"2019-01-17T10:30:19.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"k8s-health-examination-with-ready-survival-probes.html","link":"","permalink":"https://baiyuan.wang/k8s-health-examination-with-ready-survival-probes.html","excerpt":"","text":"健康检查健康检查（Health Check）可用于服务运行的状态监控，比如腾讯旗下的DNSPOD的D监控，要求配置一个访问路径以判断网站是否可以正常访问实际上就是一个健康检查，当发现健康检查失败时会发送一个邮件通知或者短信来告知网站管理员进行维修。 而在现代一些分布式系统中，用户访问不再是单台主机，而是一个由成百上千台实例组成的集群，用户请求通过负载均衡器分发到不同的实例，负载均衡帮助解决单台服务器的访问压力，同时提高了系统的高可用性，而健康检查常常作为当前实例是否“可用”的判断标准。即：当系统发现某台实例健康检查不通过，负载均衡器将不会把流量导向该实例。 现在的云服务厂商比如AWS一般都为负载均衡配备了健康检查，而Kubernetes提供了两种探针来检查容器的状态，Liveliness和Readiness，根据官方文档，Liveliness探针是为了查看容器是否正在运行，翻译为存活探针（livenessProbe），Readiness探针是为了查看容器是否准备好接受HTTP请求，翻译为就绪探针（readinessProbe）。 在Kubernetes中，Pod是Kubernetes创建及管理的最小的可部署的计算单元，一个Pod由一个或者多个容器（Docker，rocket等等）组成，这些容器共享内存，网络以及运行容器的方式。 在Kubernetes上下文中存活探针和就绪探针被称作健康检查。这些容器探针是一些周期性运行的小进程，这些探针返回的结果（成功，失败或者未知）反映了容器在Kubernetes的状态。基于这些结果，Kubernetes会判断如何处理每个容器，以保证弹性，高可用性和更长的正常运行时间。 就绪探针就绪探针旨在让Kubernetes知道你的应用是否准备好为请求提供服务。Kubernetes只有在就绪探针通过才会把流量转发到Pod。如果就绪探针检测失败，Kubernetes将停止向该容器发送流量，直到它通过。 存活探针Liveness探测器是让Kubernetes知道你的应用是否活着。如果你的应用还活着，那么Kubernetes就让它继续存在。如果你的应用程序已经死了，Kubernetes将移除Pod并重新启动一个来替换它。 工作过程让我们看看两个场景，来看看就绪探针和存活探针怎样帮助我们构建更高可用的的系统。 就绪探针一个应用往往需要一段时间来预热和启动，比如一个后端项目的启动需要连接数据库执行数据库迁移等等，一个Spring项目的启动也需要依赖Java虚拟机。即使该过程已启动，您的服务在启动并运行之前也无法运行。应用在完全就绪之前不应接收流量，但默认情况下，Kubernetes会在容器内的进程启动后立即开始发送流量。通过就绪探针探测，直到应用程序完全启动，然后才允许将流量发送到新副本。 就绪探针的工作过程 存活探针让我们想象另一种情况，当我们的应用在成功启动以后因为一些原因“宕机”，或者遇到死锁情况，导致它无法响应用户请求。 在默认情况下，Kubernetes会继续向Pod发送请求，通过使用存活探针来检测，当发现服务不能在限定时间内处理请求（请求错误或者超时），就会重新启动有问题的pod。 存活探针的工作过程 探针类型探针类型是指通过何种方式来进行健康检查，K8S有三种类型的探测：HTTP，Command和TCP。 HTTP HTTP探测可能是最常见的探针类型。即使应用不是HTTP服务，也可以创建一个轻量级HTTP服务器来响应探测。比如让Kubernetes通过HTTP访问一个URL，如果返回码在200到300范围内，就将应用程序标记为健康状态，否则它被标记为不健康。 更多关于HTTP探测可参考这里。 命令 对于命令探测，是指Kubernetes在容器内运行命令。如果命令以退出代码0返回，则容器将标记为正常。否则，它被标记为不健康。 更多关于命令探测可参考这里。 TCP 最后一种类型的探测是TCP探测，Kubernetes尝试在指定端口上建立TCP连接。如果它可以建立连接，容器被认为是健康的; 如果它不能被认为是不健康的。这常用于对gRPC或FTP服务的探测。 更多关于TCP探测可参考这里。 初始探测延迟我们可以配置K8S健康检查运行的频率，检查成功或失败的条件，以及响应的超时时间。可参考有关配置探针的文档。 存活探针探测失败会导致pod重新启动，所以配置初始探测延迟 initialDelaySeconds十分重要，要确保在应用准备之后探针才启动。否则，应用将无限重启！ 我建议使用p99启动时间作为initialDelaySeconds，或者取平均启动时间外加一个buffer。同时根据应用程序的启动时间更新这个值。 举例以下面的一个K8S的配置代码为例， apiVersion: apps&#x2F;v1beta1kind: Deployment…… readinessProbe: httpGet: path: &#x2F;actuator&#x2F;health port: 8080 initialDelaySeconds: 120 timeoutSeconds: 10 livenessProbe: httpGet: path: &#x2F;actuator&#x2F;health port: 8080 initialDelaySeconds: 60 timeoutSeconds: 10 periodSeconds: 5 K8S将在Pod开始启动后120s(initialDelaySeconds)后利用HTTP访问8080端口的 &#x2F;actuator&#x2F;health，如果超过10s或者返回码不在200~300内，就绪检查就失败 类似的，在Pod运行过程中，K8S仍然会每隔5s(periodSeconds检测8080端口的 &#x2F;actuator&#x2F;health 参考资料 【Kubernetes best practices: Setting up health checks with readiness and liveness probes】 【Kubernetes存活探针和就绪探针的最佳实践】","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"微服务","slug":"微服务","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"架构","slug":"架构","permalink":"https://baiyuan.wang/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"旧金山之行","slug":"trip-san-francisco","date":"2018-12-22T13:13:28.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"trip-san-francisco.html","link":"","permalink":"https://baiyuan.wang/trip-san-francisco.html","excerpt":"","text":"美西海岸有山，名曰“旧金山”。 忽闻海上有仙山飞机降落前的旧金山，青山如黛，江山如画，山在飘渺虚无间。 山在缥缈虚无间 鸟瞰下鳞次栉比的街道，就像美国地图一样，被切分得规规整整。 陈旧而意蕴十足的街头在旧金山的街头闲逛，没有想象中的繁华，与国内的街道对比，最大的感受就是人太少，仿佛城市的背景噪音都小了几分贝，不自觉地从内心里感觉到静谧。 估摸着旧金山的城市基建不像中国一样都是近几年修建，或者翻新重建的，整体上没有中国感觉那么新，道路坑洼不平，低低的电线也是缠绕在城市美国角落，不过建筑充满历史和艺术感，不像国内建筑千篇一律。 陈旧而意蕴十足的街头 一进入旧金山的唐人街，熟悉感和亲切感是由内而外的。走进商店，和中国的小卖部别无二致，有各色蔬菜的菜市场，有红枣、枸杞、花生干活铺，空气中都是“中国”的味道。这是一个神奇的感觉，仿佛在异国中一处家的孤岛。路上的广告牌看起来和香港街道一样，显然不是大陆的style，店主听口音大多数上台湾人和香港人。 国内品牌的方便面 在“南京小馆”吃了第一顿饱饭 金门大桥","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[]},{"title":"Cloudformation与其背后的“基础设施即代码”","slug":"cloudformation-infrastructure-code-behind-it","date":"2018-11-16T13:43:19.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"cloudformation-infrastructure-code-behind-it.html","link":"","permalink":"https://baiyuan.wang/cloudformation-infrastructure-code-behind-it.html","excerpt":"","text":"熟悉AWS的肯定不会对Cloudformation感到陌生，AWS官方对Cloudformation的定义如下： AWS CloudFormation 云资源服务可使开发人员和系统管理员轻松有序地创建、管理和更新相关 AWS 云资源模板。使用 AWS 模板或创建您自己的云资源。 为了最快地对Cloudformation在心中稍微有一个概念，我为大家提炼出下面的关键词： 利益相关者：运维或DevOps领域 一种管理云资源的服务 由AWS提供 通过模板文件（或者说配置文件、代码）管理云资源 代码 vs可视化操作联想起自己以前使用云服务的体验，初学者首先应该能想到，我是不是可以通过Cloudformation来申请主机、创建Loadbalance呢，而不是手动在AWS的控制台（Console）上“点点点”呢？ 是的。如果说Cloudformation仅仅使可视化的界面操作代码化，这或许只能激起代码爱好者的兴趣，我们知道代码化的许多好处，比如效率更高、可被机器自动执行。 然而因为不是所有人都喜欢代码。对于患“代码恐惧症”的人，或者习惯在界面上配置的专业运维人员来说，界面操作显然比代码更直观、拥有更友好的操作引导。 对于追求高效的工程实践来说，代码化还是界面操作并非“萝卜青菜，各有所爱”的兴趣爱好问题，而是生产力问题。 基础设施即代码这年头流行一个词语，叫DevOps，维基百科的定义如下： DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 而我个人的理解就是，DevOps要求能把运维纳入软件开发体系，比如运用敏捷等软件开发方法、实现自动化持续集成、测试、交付、可被代码管理等等；其次，要求开发具备运维意识，将交付基础设施作为交付软件的一部分，借助云计算给开发人员赋能从而达到端到端交付的全栈能力，从而极大地提高研发效能。 在这个意义上，Cloudformation就是这样一个工具，可以将基础设施作为代码纳入到软件开发的一部分，并运用软件工程方法管理基础架构。 “基础设施即代码”给我们带来什么在笔者所在的团队里，能写DevOps的代码已经作为开发的标配技能。在新起一个Codebase的时候，我们往往需要考虑一下内容： 一个项目的文件结构截图 基础设施代码 （&#x2F;infra目录） 持续集成流水线代码（&#x2F;pipeline目录, 这年头还有个词叫“流水线即代码”） 业务代码（包括前后端代码、测试代码，&#x2F;api, &#x2F;test 目录） 在一些大型的互联网公司来说，运维和开发的职权是完全分离的，开发可能仅仅只用关注业务代码部分。 实际上在一个项目启动后的前期，首先介入的可能是运维人员搭建出一套线上的开发环境（Dev）、测试环境（QA）、生产环境（Prod）用于开发的日常调试、测试人员测试以及发布项目；如果使用持续集成的方式的话，还要搭建持续集成（CI&#x2F;CD）流水线。 一键自动构建云环境借助AWS平台及其提供的Cloudformation（或者第三方工具如terraform），使用基础设施代码，我们就可以快速地构建一套完整的云环境。同时使用同样一套基础设施代码，再配置不同的环境变量，就可以快速地复制出不同的线上环境。 以Cloudformation为例： 编写Cloudformation代码，比如编写通过以下的代码，通过AWS提供的aws cloudformation命令，就可以实现在AWS创建一台可以弹性伸缩的实例。 ECSAutoScalingGroup: Type: ‘AWS::AutoScaling::AutoScalingGroup’ Properties: VPCZoneIdentifier: !Ref InstanceSubnetIds LaunchConfigurationName: !Ref ContainerInstances MinSize: ‘1’ MaxSize: !Ref MaxSize DesiredCapacity: !Ref DesiredCapacity ContainerInstances: Type: ‘AWS::AutoScaling::LaunchConfiguration’ Properties: ImageId: !FindInMap - AWSRegionToAMI - !Ref ‘AWS::Region’ - AMIID InstanceType: !Ref InstanceType IamInstanceProfile: !Ref EC2InstanceProfile KeyName: !Ref KeyName 同时我们可以使用AWS Cloudformation designer可视化地设计我们的基础架构及其之前的拓扑结构和关联关系，并导出代码。 AWS Cloudformation designer 借助git等实现代码的版本管理代码化后的基础设施，意味着可被git等版本控制工具进行管理，这意味着对基础设施的任何改动，比如更改服务器内存、更换可用区、修改域名、安全组等等，都可以通过review代码的方式进行跟踪。 而在过去，在控制台界面上进行的误操作导致线上环境出问题很难被记录下来，同时如果因为修改服务器环境配置导致的问题，可以很快通过git回滚代码的方式进行快速回滚服务器环境。 基础设施版本间无缝切换 声明式操作 在Cloudformation之前，AWS已经推出了命令行工具或者SDK来管理AWS的资源，与它们“命令式”操作不同的是，Cloudformation提供一种“声明式”的特性。 “命令式”操作希望你去一步步编写程序以达到最终所期望的状态，而声明式只关心你想要的资源与资源的状态，Cloudformation会自动分析达到想要的状态需要进行怎样的操作。（理解声明式和命令式的不同，可参考《声明式编程和命令式编程的比较》） 幂等性 Cloudformation的声明式操作为其提供了幂等性的特性，以为我们在任何时刻、任何版本的基础架构运行新的Cloudformation代码，AWS每次都会帮助你生成相同的基础架构。 原子性 大部分人在数据库事务中了解到“原子性”。Cloudformation同样支持一种原子操作，要么成功，要么失败。失败的话可以自动回滚，而在一次失败操作中产生的资源会在回滚时被自动删除掉。 纳入持续集成&#x2F;部署流水线（CI&#x2F;CD）“基础设施即代码”的代码化、自动化，为CI&#x2F;CD流水线管理基础设施提供了可能。 一种理想的方式是，和修改业务代码一样，当我们要对基础设施进行变更时，通过修改基础设施的代码，提交到git仓库，触发CI&#x2F;CD流水线运行基础设施代码，然后达到更新基础设施的目的。 持续集成 同时根据云计算服务商提供的反馈，更新CI&#x2F;CD流水线的部署状态：红则失败绿则失败。 QA或者团队可以根据测试结果和发布计划通过流水线，将基础设施和业务代码一起推向下一阶段。 GoCD持续集成流水线 扩展思考：2018年 ThoughtWorks 技术雷达19期为我们介绍了一款名为LocalStack的云服务的Mock框架，这意味着我们可以在本地调试基础设施代码，或者为基础架构代码做单元或集成测试。原文如下： 使用云服务时面对的一个挑战是如何在本地进行开发和测试。 LOCALSTACK 为 AWS 解决了这个问题。它提供了各种 AWS 服务的本地 测试替身 实现，包括 S3 、 Kinesis 、Dynamodb 和 Lambda 等。它基于现有的最佳工具如Kinesalite 、 Dynalite 、Moto 等构建，并增加了进程隔离与错误注入的功能。 LocalStack 的使用很简单，并附带了一个简单的 JUnit 运行器以及 JUnit 5扩展。我们在一些项目中使用过 LocalStack ，并对它印象深刻。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"沟通从远离喷子开始","slug":"communication-no-spray","date":"2018-11-11T11:00:37.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"communication-no-spray.html","link":"","permalink":"https://baiyuan.wang/communication-no-spray.html","excerpt":"","text":"喷子或者杠精可能不知道自己是喷子或者杠精，只是想通过反驳别人的观点彰显自己的存在感，满足自己的虚荣心并以此为傲。比较可惜的是，他们失去了一次是对别人思想学习与吸纳的机会。还有高级一点的喷子，不知道对方有时候说的话有他特殊的上下文，而是断章取义对方的文字，不去思考作者特定语境下的上下文，而是来找寻表面的漏洞来喷，对着这种人建议他们学习一下“语用学”。 而对于喷子，不能太在意了，有些想法如果是自己某一时刻的真知灼见，大可写下来，因为它在这一时刻的语境下是对的，如果假以时日这些想法的确是错的，也无需菲薄自己，因为这是一种成长与完善自己想法的过程。如果过分在意别人的评论，就什么也不敢说了，就永远缺乏自信了。 跟很多人深入交流以后发现，同龄人一般心智差不多，首先不要想自己把别人强很多，然后先认为别人比自己聪明，如果认为别人说错的，那看看别人有没有可取的点。带着学习的态度，而不是上来就喷的态度。那要不要纠正呢，要但不强势。纠正之前首先确定自己真的理解别人的意思，这样可能更耐心平和一点。 当然了，判定喷子的标准是对方是不是带着探讨问题的善意，这种善意遵循 “倾听-反馈-融合” 的过程，先倾听对方的观点，拉齐双方进入相同的上下文，这个时候结合自己的生活阅历或者知识储备发表自己的观点，不天马行空，扩大scope。不是抱着一股求胜心来企图“碾压”对方，而是带着“求知心”，或者是“Develop others”的心态。 所以，现在不喜欢在朋友圈发表一些观点性的文字，因为很难在朋友圈短小的文字下介绍一个完整的上下文。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"沟通","slug":"沟通","permalink":"https://baiyuan.wang/tags/%E6%B2%9F%E9%80%9A/"}]},{"title":"AWS Fargate速览","slug":"quick-overview-aws-fargate","date":"2018-11-05T02:16:48.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"quick-overview-aws-fargate.html","link":"","permalink":"https://baiyuan.wang/quick-overview-aws-fargate.html","excerpt":"","text":"AWS Fargate 发布于2017年11月的re:Invent 大会，是一项让您无需管理服务器或集群即可运行容器的技术，我们只用关心应用镜像及其所需的资源即可。 AWS Fargate在技术雷达上的位置 AWS Fargate: 关键词 DevOps、云计算领域 AWS的一个云服务 Severless：无服务器化 容器运行平台 和EC2 Instance在一个层次 支持ECS、EKS：Amazon ECS&#x2F;EKS 具有两种模式：Fargate 启动类型和 EC2 启动类型 因为ECS而具备的属性 监控 弹性伸缩 健康检查 蓝绿部署 负载均衡 ECR：AWS镜像仓库 定时任务 网络配置 Cloudformation: 基础设施即代码 从容器运行平台方面：Fargate相比EC2 Instance 的不同、优势 EC2 vs Fargate：架构 EC2 Instance vs Fargate：安全性安全职责转移给云服务厂商 AMI: 系统更新 安全漏洞 SSH SSH key 堡垒机 EC2 Instance vs Fargate：计价方式 Fargate 总费用 (以资源为单位) &#x3D; vCPU 总费用 + 内存总费用 vCPU 总费用 &#x3D; vCPU 数 x 每 CPU-秒价格 x 使用CPU持续时间 (秒) 内存总费用 &#x3D; 任务数 x 内存数 (GB) x 每 GB 价格 x 每天内存持续时间 (秒) x 天数 EC2 Instance 总费用（以Instance为单位 &#x3D; Instance Type的单价&#x2F;小时 x 小时数 从Serverless角度对比Fargate和Lambda维度 Fargate Lambda 运行单元 容器，易于迁移 Function 应用语言 无限制 语言有限，不支持复杂应用 运行时间限制 无限制 5分钟 自动扩展 可配置弹性伸缩 默认支持 存储仓库 ECR S3 部署难度 一般 简单 持久化 有状态 无状态 计价方式 资源 * 秒数 代码执行时间 （100ms为单位）* 代码触发次数","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://baiyuan.wang/tags/AWS/"},{"name":"DevOps","slug":"DevOps","permalink":"https://baiyuan.wang/tags/DevOps/"}]},{"title":"ElasticSearch增量数据同步与无缝升级","slug":"elasticsearch-incremental-data-synchronization-seamless-upgrade","date":"2018-10-07T04:32:59.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"elasticsearch-incremental-data-synchronization-seamless-upgrade.html","link":"","permalink":"https://baiyuan.wang/elasticsearch-incremental-data-synchronization-seamless-upgrade.html","excerpt":"","text":"ElasticSearch作为一款开源的全文搜索引擎在如今的软件开发得到了越来越广泛的应用，在业务功能开发方面，可以选用ElasticSearch提供比数据库查询更强大的搜索方式，同时基于搜索结果评分（权重）和高亮让我们很轻易地通过它实现一个站内的搜索引擎。 ElasticSearch VS 数据库刚接触ElasticSearch（ES）时我们经常将它与数据库类比起来学习，从结构上： Indices类似于数据库的database Type类似于数据库的table Fields类似于数据表的列 Documents类似于数据表的行（即每条记录） 同时，数据库提供的搜索语法都能在ES上找到影子，比如数据库提供AND、OR逻辑运算符，ES中有must, should，而数据库的如“like”等文字匹配功能在ES中则更加强大。 尽管如此，ES本质上的定位仍是一个搜索引擎。NoSQL和ES一样都有着相同松散的结构，虽然我们也有一些讨论是否可以用ES来替代非关系型数据库(撇开ES是不是一种NoSQL)，但是一个现实是ES和NoSQL依旧是互有利弊；再者，传统关系型数据库的事务性、多表关联结构也是ES无法提供的。 所以，在实际的开发过程中，关系型数据库、NoSQL、ES依旧是相辅相成的关系，我们一般只会在较复杂的搜索场景下会选用ES提供搜索服务，而其源数据依旧来自于数据库，所以这就引出了ES与数据库之间的数据同步问题。 全量数据导入在第一次将存储在数据库里面的数据导入到ES需要执行全量导入，当后续有数据更新时通过消息队列通知ES更新数据。 使用消息队列实现ES增量同步消息队列在软件开发领域是一个十分常见的名词。 在操作系统层面，我们可以利用消息队列做进程间的通信；在一个单体应用，比如Android应用，利用一个MessageQueue类来解决UI线程与耗时子线程之间的界面刷新问题，在物联网领域，基于发布&#x2F;订阅模型模型的MQTT协议被广泛应用于平台对海量设备的消息分发，而在分布式系统，以及最近几年日益热门的微服务架构中，是一个十分常用的实现异步消息、解耦应用、最终一致性的组件。 常见的消息队列采用“发布-订阅”模式，初入门者几乎可以认为这是个“观察者模式”。 消息队列模式-“发布-订阅”模式 目前常用的消息队列框架有Kafka、RabbitMQ。 消息队列实现增量同步的方式，是在主服务对数据库进行创建、删除、修改一条记录时，发布一条主题消息给消息队列，同时同步服务需要订阅相关主题，这样消息队列就可以将更新的记录转发给同步服务，同步服务再根据消息的内容在ES里面进行更新记录。 消息队列实现增量同步除了可以解耦主服务和同步服务，还有一个好处就是保证同步的容错性，比如当数据库添加一条记录时，如果直接采用HTTP的方式（可能是一个post请求）与同步服务取得联系时出现连接失败、post请求失败的时候，如果不采取任何措施这条记录就会无法得到同步。而消息队列的失败重发的机制可以很好的解决这个问题，同时消息队列，FIFO（先进先出）的机制也保证了消息转发的顺序。 ES索引更改后怎样做无缝重建ES索引更改发生在ElasticSearch 索引结构发生变化，比如随着业务的发展对Type中字段的增减以及字段类型的更改，或者发生在ES版本升级带来的结构变化时，例如ES 5.0版本将之前的string类型拆分为text和keyword类型，当我们希望对ES进行版本升级时，那么之前的string类型就不可再用了。 与常见的Web服务的蓝绿部署实现无宕机升级类似，ES无缝升级也可以类比实现。Web服务的蓝绿部署的原理是使用LoadBalancer（负载均衡器）做流量切换，新旧服务都有不同的访问URL，但是只有LoadBalancer的URL对外可访问，即： 服务升级前：负载均衡指向旧服务V1 服务升级中：发布新服务V2，负载均衡依旧指向旧服务，此时存在新旧服务同时存在 服务升级完成：新服务V2启动完成，负载均衡切换指向，将访问流量导向新服务V2 服务升级完成：负载均衡切换指向后停掉旧服务V1 蓝绿部署 ES索引的别名ES提供了通过索引别名（alias）来访问索引的方式：比如 curl -XPOST ‘http://localhost:9200/_aliases‘ -d{ “actions”: [ {“add”: {“index”: “test_20181007”, “alias”: “test”}} ]} 就为索引test_20181007创建了一条别名test，这样访问localhost:9200&#x2F;test&#x2F;_search和localhost:9200&#x2F;test_20181007&#x2F;_search都可以搜索索引里面的内容。 ES的别名的存在为ES的无缝升级和切换提供了可能，类似于负载均衡切换指向一样，我们可以让ES别名在升级前后，指向新旧不同版本的索引即可。 ES无缝升级 新建带版本的新索引 暂停增量更新 由于在升级期间我们不希望后续的记录更新到旧索引上，所以需要将消息队列进行暂停（pause）操作，在新索引创建成功后再开启。 执行全量数据导入 切换对外别名指向 一个别名可以指向多个索引，所以我们在添加别名到新索引的同时必须从旧的索引中删除它。这个操作需要原子化，这意味着我们需要使用 _aliases 操作： POST &#x2F;_aliases{ “actions”: [ { “remove”: { “index”: “test_v1”, “alias”: “test” }}, { “add”: { “index”: “test_v2”, “alias”: “test” }} ]} 删除旧索引 DELETE &#x2F;test_v1 开启增量更新 这样在升级过程中的数据库中有更新的记录将会在新索引上同步","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【开源】RN-ExpandableText：ReactNative长文本折叠组件","slug":"open-source-rn-expandabletextreactnative-long-text-folding-component","date":"2018-09-19T01:37:34.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"open-source-rn-expandabletextreactnative-long-text-folding-component.html","link":"","permalink":"https://baiyuan.wang/open-source-rn-expandabletextreactnative-long-text-folding-component.html","excerpt":"","text":"介绍移动开发经常会遇到这种情况：我们需要内容过长的文本做一个折叠的功能，那么在React Native，RN-ExpandableText就是一个解决这个问题的组件，它的使用方式和原生的Text组件一样，但是当你的内容超出指定行数，它会帮你把内容自动折叠。同时点击展开可以显示所有内容。 项目地址：https://github.com/geekeren/RN-ExpandableText 安装npm install rn-expandable-text --save ExpandableText Usageimport ExpandableText from ‘rn-expandable-text’ &lt;ExpandableText numberOfLines=&#123;10&#125; style=&#123;styles.expandableText&#125; unexpandView=&#123;() =&gt; null&#125; expandView=&#123;() =&gt; (&lt;View style=&#123;styles.arrow&#125; /&gt;) &#125; &gt; &#123;content&#125; &lt;/ExpandableText&gt; Demos PropertiesProp Description Default numberOfLines The max number of lines the content will be, the content exceed this value, the expandview will show. 5 expandView A callback function to return expand-view, you can customize the expand-view. when it’s null, expand-view will disappear unexpandView A callback function to return unexpand-view. Usage the same as expandView onExpand A callback when the content expands onCollapse A callback when the content collapses Follow MeFollow me on Wechat","categories":[{"name":"作品","slug":"作品","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://baiyuan.wang/tags/React-Native/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"容器即服务：AWS Fargate","slug":"an-intro-to-amazon-fargate-when-and-why-use-it","date":"2018-08-23T09:54:17.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"an-intro-to-amazon-fargate-when-and-why-use-it.html","link":"","permalink":"https://baiyuan.wang/an-intro-to-amazon-fargate-when-and-why-use-it.html","excerpt":"","text":"本文翻译自：Freecodecamp, 原文地址：An intro to Amazon Fargate: what it is, why it’s awesome (and not), and when to use it, 英文原作者为 Emmanuel Marboeuf 当亚马逊在2017年底的AWS re:Invent大会上和EKS一起宣布 Fargate的时候，它还备受冷落，当时我所关注的博客和大佬只是轻描淡写地说： 哦，有这么个新玩意，它将允许ECS用户直接在云中运行容器。 作为开发人员，这真的让我大吃一惊。让我们看看为什么。 解放生产力我觉得软件开发领域已有五次重大革命，大大提高了开发者的工作效率，并以最高效率编写与部署应用。他们都解决了一系列的重大问题： 云服务（IaaS）的出现：解决了基础架构的成本和可扩展性问题 开源社区，会议，工作坊，技术博客，StackOverflow等：让知识惠及到更多人 版本控制系统，协作工具，持续集成工具 解决了项目的并行开发和集成问题 容器化架构 无服务器计算服务（PaaS） 降低服务器和系统管理成本 这些革命中的都有一个共同特点：它们都为软件工程师赋予了更多的控制权，降低了对服务器的系统管理员，DevOps，IT支持人员等的依赖。 所以，Fargate算其中的哪一种呢？ 你的“船”才是问题所在 Life jacket is advised Docker使容器技术普及开来，便很快成为开发中被广泛采用的新标准。 不久之后，随着Kubernetes的成功，AWS推出了自己的（更基本的）容器管理服务：Amazon Elastic Container Service（ECS），它引入了任务（Task）的概念。 一个任务可以是一起工作的容器的任何实例。它可以是从运行一个服务的Web应用，多个微服务，数据库和反向代理，还可以是定期运行的批处理shell脚本。 作为使用ECS的“老司机”，我很喜欢它，曾经在一段时间内用得很爽，但到最后，我发现在管理EC2 Instance的同时，还必须管理一些额外的层（任务和容器），这让ECS变得越来越复杂。（译者注，请参考AWS“层”的概念） 同时，我对ECS的安全性也不甚满意，层越多，就越要保持警惕，而每一层都带来了更多的复杂性，以及误配置、漏洞的可能性。 使用ECS在集群中运行中的EC2 实例（Instance）配置弹性伸缩时，每个实例上可以承载多个不同的Task，每个Task都可以运行多个容器。 由于任务（Task）会在具有可用资源的相同类型的EC2实例上随机部署（默认情况下），将面临以下问题： 一个集群必须遵循相同的弹性伸缩规则，伸缩的EC2实例类型必须相同。 有些容器需要完全不同的资源（译者注，AWS将网络、虚拟机、负载均衡都称为资源），但仍需要协同工作。 某些容器不一定遵循相同的弹性伸缩规则。 有时同一任务中的多个容器都需要有自己的负载均衡，无法为同一任务设置多个负载均衡器。 面对这些问题时，首选的解决方法是： 根据需求手动部署一些具有不同资源的EC2实例 将这些EC2实例添加到您的集群 为任务运行一个容器 手动链接到您的EC2实例 在ECS上配置复杂的任务策略，把不用任务根据他它们的需求配置在适当的EC2上 这需要大量、繁琐的工作，还不易维护，这违背了使用容器的初衷。 有人不得不提出一个更好的主意。 让它们“漂”起来事实证明，AWS团队在过去一年中也遇到了同样的问题，他们考虑过并致力于解决这些问题： 我们怎样才能运行容器而不必担心服务器和集群？ 这就是AWS Fargate的意义所在。它完全抽象了底层基础架构，你可以把每个容器视为一台机器。 你只需定义每个容器所需的资源，它将为你完成复杂的任务而不必再管理多个“层”之间的访问规则，您可以像在单个EC2实例之间那样调度容器那样。 Fargate上的容器 这就让你的容器像水面上的船只拥有自己的帆、船舵、船员一样，自己可以漂流到想要去的地方。 容器即服务（CaaS）我一直坚信容器即服务（CaaS）是开发人员梦寐以求的、真正的平台及服务（PaaS）。它允许开发人员直接在云中部署他们的容器，而不必担心底层细节。 当然，已经有很多技术允许您在云上无缝运行代码，而不必担心扩展或服务器管理（比如Heroku，Lambda，甚至以自己的方式使用Google应用引擎）**，但它们都有局限性。 必须选择丧失一点灵活性 必须使用它们所支持的语言 无法使用它们所支持的语言完成拟定项目，因为可能您的项目需要在指定操作系统系统上可用的低版本的原生库 您的项目采用了尖端技术，未来几年将无法为大众所用 其中一些平台非常非常昂贵，特别是在扩展时 Fargate（或CaaS）为您带来两全其美的方案。 容器化架构为您提供所需的灵活性和控制权，它允许您在任何类型的系统中使用任何技术。而容器技术能确保你的应用在每个主机上具有相同的行为，无论是开发（Dev），测试(Testing&#x2F;QA)，预发布（Staging）还是生产(Production)环境。 我觉得这一点对众多的科技初创公司至关重要。事实上，有时您的竞争优势之一就是，您参与开发出最先进的技术，或者是把机智地原有的技术用在新的应用场景中。 无服务器部署使您可以专注于编写优秀的代码，没有配置，易于扩展。 限制CaaS vs PaaS也许确实你放弃了真正的“平台即服务”的一些优势，比如您仍然需要手动更新容器的镜像，有时您必须编写自己的Docker镜像。如果您不了解系统管理的基础知识，这的确很麻烦。 但是，这也意味着您可以放手地做任何您能想做的事情，并且在您想要使用的系统上，保证语言，工具，库和版本中的灵活性和自由度。 成本让我们直面这样的现实：云服务（IaaS）比拥有自己的基础架构更昂贵（如果你想要按需扩展你的基础架构）。同样的道理，不必关心配置、管理和扩展服务器是要需要付出代价。如果你的应用十分简单，云服务并不是最优解。 Fargate实好，但是其价格几乎是等配置EC2实例的价格的 4 倍（例如t2.medium）这让我们很难抉择，让我们期待它能够降价。 Fargate 和 EC2 价格对比 (USD) 我应该将所有ECS任务都切换到Fargate吗？当然不是。如上所述，在某些情况下，您的成本将增加三倍以上，所以在它们降低成本之前，您可能最好使用标准EC2实例。 但是，在以下情况下，Fargate可能对您更有益： 如果您无法很好地伸缩你的ECS任务，会导致大量空闲的CPU或内存，而使用Fargate，您只需为在任务中定义的资源付费。 对于按需或按定时计划运行的任务，并不需要一直运行着的EC2实例。使用Fargate，您只需在任务运行时付款。 适用于有内存和&#x2F;或CPU使用率峰值的任务。这仅仅是因为使用Fargate可以在这类情况下节省您配置和管理的时间。 彩蛋对于那些喜欢Kubernetes而非ECS的人来说，Fargate很快就会支持EKS了。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://baiyuan.wang/tags/AWS/"},{"name":"DevOps","slug":"DevOps","permalink":"https://baiyuan.wang/tags/DevOps/"},{"name":"Docker","slug":"Docker","permalink":"https://baiyuan.wang/tags/Docker/"}]},{"title":"使用Dockerhub持续构建容器镜像","slug":"using-dockerhub-continually-build-container-mirroring","date":"2018-08-22T03:35:13.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"using-dockerhub-continually-build-container-mirroring.html","link":"","permalink":"https://baiyuan.wang/using-dockerhub-continually-build-container-mirroring.html","excerpt":"","text":"ContextDocker作为一个轻量的的虚拟化容器技术，在现在的自动化运维上被广泛使用，同时伴随着各大云平台AWS、Aliyun，以及容器编排引擎kubernetes也都是基于Docker作为服务的基本单元，所以部署应用的第一步往往就是制作应用镜像，也就是编写Dockerfile，比如 From openjdk:8-jdk-alpineCOPY .&#x2F;build&#x2F;app.jar .&#x2F;CMD “java -jar app.jar” 其基本过程是： 基于一个基础镜像，比如Java:alpine 构建项目，生成一个成果物，比如jre 定义镜像的入口即ENTRYPOINT或者CMD，”java -jar xx.jre” 在实际的项目中，编写的Dockerfile远非如此简单，比如openjdk提供的基础镜像里面可能没有我们需要的环境依赖，比如我们构建一个java项目时需要gradle支持；比如有一个依赖包它发布在github上，我们需要一个git命令；又比如我们在镜像的运行时，需要用gitcrypt解密一些敏感的环境变量；这就意味着我们需要基于基础镜像对一定的改造，比如加入：RUN apk add git 当随着项目环境依赖越来越多时，我们会发现越来越臃肿的Docker镜像会严重拖慢项目构建的时间，每一次我们的CI&#x2F;CD服务器部署一次都会下载大量依赖。一个Best Practice是为项目制作自己的基础镜像，意味着下一次构建直接使用之前构建的基础镜像。 那么我们构建的基础镜像放在哪呢？ Docker Hub 如果你第一次听说Docker Hub的话，可以这么理解，软件界有两个最大的公有仓库，一个是放代码的，叫github；还有一个是放docker镜像的，叫Dockerhub。 Github &amp; Docker Hub Docker Hub是世界上最大的Docker镜像公共存储库，全世界大量的Docker开发人员，开源项目和独立软件供应商（ISV）都会在这里构建和分发他们的镜像。Docker Hub也是Docker的官方仓库，当在运行命令docker pull alpine就是从Docker Hub上拉取的alpine镜像。 我们可以从Docker Hub上免费拉取与上传我们的镜像，如果经费充裕的话，我们也可以使用Docker Hub作为私服。 在极客人的实际项目开发中，我还没有用到Docker Hub的私服属性，一方面平时用到AWS镜像仓库ECR极其廉价也方便至极。 一般，我会使用Docker Hub， Docker化自己的开源项目，方便演示 在Github开源自己的项目时，是否有演示关系到他人对项目的第一印象，使用docker可以方便快捷、无需考虑各种环境地在本地搭建出开源的项目，比如@geekeren&#x2F;magpie，就是存放在Docker Hub，你只需 docker run -p 80:80 bywang/magpie即可轻松演示。 存放团队项目的基础镜像 **基础镜像镜像并不是应用镜像，不包含我们的项目代码**，可以方便自己或他人复用我们的Docker镜像，也可以为社区做贡献。 减轻CI压力并加快构建速度 环境依赖变更的低频性决定我们的基础镜像不需要频繁更新，也无需频繁构建，将基础镜像存放于Docker Hub上可以将构建基础镜像的过程从CI中剥离。 Docker Hub的自动化构建Docker Hub自动化构建允许我们关联GitHub 、 BitBucket 项目并根据指定Dockerfile自动构建镜像，同时webhook通知更新机制可以实现当github上的dockerfile有更新时触发Docker Hub构建，从而保证镜像为最新版本。 实践下面为大家介绍怎样使用Docker Hub自动化构建 1.点击导航栏“create”选择“Automated Build” Create automated build 2.关联Github账号，中间可能要求登录Github账号 关联Github 3.选择一个Github的Dockerfile项目 这里我使用的是一个在gradle里面集成git-crypt的docker项目：https://github.com/geekeren/docker-gradle-gitcrypt 选择Github项目 4.创建一个Dockerhub Repo 5. 创建一个Dockerhub Repo 正在构建的Docker Image 这时一个Docker Hub repo已经大工告成，我们就可以在项目的应用镜像中使用： FROM geekeren&#x2F;gradle-gitcryptCOPY . .CMD xxx","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://baiyuan.wang/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://baiyuan.wang/tags/CI-CD/"}]},{"title":"【开源】Magpie - 一个基于React的滚动抽奖Web APP","slug":"magpie-an-luckey-draw-web-app-based-on-react","date":"2018-08-20T11:29:35.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"magpie-an-luckey-draw-web-app-based-on-react.html","link":"","permalink":"https://baiyuan.wang/magpie-an-luckey-draw-web-app-based-on-react.html","excerpt":"","text":"MagpieMagpie，“喜鹊”，取其“报喜”之意，故本系统是一款抽奖软件。Magpie目前采用纯前端编写而成，主要技术架构是ReactJs+Redux，部分UI的实现使用了React调用Jquery的方案。 本项目已托管在Github上，在Github上关注 使用本项目已Docker化并托管于Docker hub平台，您可以在安装了Docker环境的情况下执行： docker run -p 80:80 bywang/magpie启动Magpie抽奖服务 你也可以clone本项目，在本地使用yarn start 启动服务 预览Try online","categories":[{"name":"作品","slug":"作品","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/"}],"tags":[]},{"title":"微信小程序入门","slug":"start-up-of-wechat-mini-program","date":"2018-08-16T13:03:46.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"start-up-of-wechat-mini-program.html","link":"","permalink":"https://baiyuan.wang/start-up-of-wechat-mini-program.html","excerpt":"","text":"最近在学习微信小程序，极客人总结了一些入门经验，希望能帮助想学习小程序的同学提供参考 一、微信小程序的文件结构：▸ pages&#x2F; : 页面文件，小程序由一个个page（类比于Activity或者ReactJS里面的页面组件）组成 ▸ utils&#x2F; : 放一些工具方法 .app.js： 小程序启动，类比于Android的Application类或者MainActivity app.json :小程序的全局配置文件, 类比于Android的清单文件，声明了小程序有哪些page app.wxss :全局的css样式文件 project.config.json ：项目配置文件，定义了项目的名称，基础库版本，appId等 小程序由一个page组成，类比于Android的Activity，与其他组件化应用一样有生命周期，除此之外，小程序开发和ReactJS很像，比如React里面利用state管理界面数据，小程序有一个几乎和这一模一样的，叫data. onLaunch Function 生命周期函数–监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）。 onShow Function 生命周期函数–监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow onHide Function 生命周期函数–监听小程序隐藏 当小程序从前台进入后台，会触发 onHide onError Function 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 二、学习资料 微信小程序开发资源汇总：https://github.com/justjavac/awesome-wechat-weapp WeUI，微信官方的组件库：https://github.com/Tencent/weui 三、一点想法 个人身份可以申请注册小程序，权限还是很多的，除了支付、实时视频，其它基本都支持 微信小程序解决我们我不想安装过多APP的痛点，前途还是很看好的，最近微信推出了小程序广告，想变现的抓紧了 虽然小程序发布不久，但是现在不管官方还是社区对微信小程序的生态是十分有友好的，比如除官方提供了还算好用的IDE，其它IDE比如VSCode&#x2F;Intellij都有插件对小程序予以支持；同时社区里面又很热开发面向小程序的UI库、开发框架（比如支持Vue的mpvue）","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【译】微服务架构的监控与可视化工具","slug":"monitoring-visualization-tools-for-micro-service-architectures","date":"2018-05-04T07:44:32.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"monitoring-visualization-tools-for-micro-service-architectures.html","link":"","permalink":"https://baiyuan.wang/monitoring-visualization-tools-for-micro-service-architectures.html","excerpt":"","text":"最近一直在考虑如果有个东西展示我们的多个微服务之间调用关系，以及显示它们的状态，并通过网络拓扑图的方式显示数据的流向、错误追溯，如果做的通用起来一定是个好的框架。主要的思路就是给各个微服务制定一定的通信协议，让他们遵守一定协议上报到服务器，服务器进行UI展示。常言道，“国外的公司会玩”，才发现一些公司已经给做出来了。 本文翻译自：Tools to Monitor and Visualize Microservices Architecture | ProgrammableWeb 构建和部署分布式应用程序后，监视和可视化它至关重要，以确保软件的可靠性，可用性和预期的性能。这并不容易。 由微服务架构驱动的应用程序的异构和分布式特性使得监视，可视化和分析成为一个难题。传统的应用程序监控和性能管理（APM）解决方案不适合当今复杂的分布式应用程序。 幸运的是，在过去的几年里已经推出了几种新的APM解决方案来解决这些问题。这些APM解决方案利用人工智能（AI），机器学习和图形分析等先进技术来监控，可视化和分析微服务架构。许多现代APM解决方案还包括有效管理微服务体系结构所需的分布式跟踪和拓扑可视化功能。 分布式跟踪和拓扑可视化当前的开源分布式跟踪系统包括Zipkin，HTrace，X-Trace和Trace。还有OpenTracing项目，旨在提供与供应商无关的 API，以便可以在所有流行的平台上实施分布式跟踪和上下文传播。 Battery Ventures的技术研究员，Netflix前任首席架构师Adrian Cockcroft在最近的一次演讲中描述了分布式跟踪，他说：“分布式跟踪系统几乎实时地收集端到端延迟图（迹线）。你可以比较痕迹来理解为什么某些请求需要比其他请求更长的时间。 并非所有可用的开源分布式跟踪系统都包含拓扑可视化功能，这可能是一项重要功能。拓扑可视化对微应用架构和其他分布式应用程序中的应用程序布局进行映射或图表化。当您需要发现性能问题和其他问题时，这样做非常重要。 SimianViz演示屏幕截图，更复杂的Netflix可视化：查看现场演示。 Adrian Cockcroft最近发布了一个新的开源工具SimianViz（以前称为Spigo），它可以生成对复杂微服务的大规模模拟。公司可以使用这些模拟来进行拓扑可视化，并且可以对微服务监控解决方案进行压力测试，而无需设置大型测试配置。 Netflix和LinkedIn等主要技术公司已经建立了自己的分布式跟踪和性能监控解决方案。对于Netflix而言，由于其需要可扩展性，因此对其多种分布式跟踪工具的需求受到驱动，因为大多数商业工具无法在Netflix所需的级别进行扩展。Netflix还使用各种可视化工具，包括按需CPU 火焰图来分析和优化Java和Node.js应用程序的性能。 LinkedIn有一个实时分布式跟踪系统，它使用Apache Samza结果来构建实时呼叫图。调用图用于LinkedIn分布式架构的性能优化和根本原因分析。 大多数公司没有像LinkedIn和Netflix这样的公司的大量资源，因此从头开始构建定制的分布式跟踪和性能监控解决方案可能是不可能的。幸运的是，任何规模公司的开发人员都可以使用许多工具来监视和可视化分布式应用程序。 微服务架构的监控和可视化任何构建于微服务架构上的系统都有很多。微服务体系结构通常由几十个甚至几百个细粒度的服务组成; 每个用户交易都经历了许多这些服务。另外，事务通常是异步的，涉及多个并发服务请求。传统的APM产品通常无法监控处理多个并发服务请求的分布式应用程序。 它们固有的复杂性和高可扩展性要求导致了使用机器学习，图形分析，分布式跟踪，拓扑可视化和其他尖端技术的应用程序监视和可视化工具的创建。 以下是这些解决方案的几个示例，因此您可以了解可用的工具以帮助您了解软件中发生的情况。 AppDynamics 图片来源：AppDynamics 虽然AppDynamics已经有相当长的一段时间了，但该公司在2015年6月推出了机器学习驱动的APM产品，以监控，管理和分析诸如微服务之类的复杂体系结构。AppDynamics实时显示应用程序性能并自动发现应用程序拓扑和相互依赖关系。其APM工具还包括分布式跟踪，拓扑可视化和动态标记。 开发人员可以使用AppDynamics来确定分布式应用程序的运行状况，了解事务路径，确定服务失败的根本原因，并获得对微服务体系结构的其他重要见解。AppDynamics API可以帮助扩展和定制平台的功能。 Instana 图片来源：Instana Instana是Web应用程序的监控和管理平台，成立于2015年4月。其关键特征之一是智能虚拟机器人助理Stan。 Stan帮助Instana用户（即开发人员和DevOps）通过即时通知来监控和优化复杂的应用程序和体系结构。Stan拥有丰富的DevOps知识，并不断学习和理解尖端的应用程序组件和体系结构。机器人助手依赖于多种技术，包括动态依赖图，自动发现和传感以及组件和系统的健康预测。Instana还包含一个实时知识引擎，可自动发现应用拓扑和相互依赖关系。 Instana使用机器学习，数学算法和专有知识系统来提供动态图形和可视化。Instana公司承诺，开发人员可以测量分布式应用程序的健康状况（延迟，错误率等），了解服务关系和相互依赖性，调查特定事件和服务故障（实时和历史），并获得更好的理解的整体应用程序。 Netsil 图片来源：Netsil Netsil分布式应用监控和分析平台成立于2016年，自动发现完整的应用拓扑结构，持续监控分布式应用，执行分布式跟踪以及分析应用指标（从历史到现在）。 基于微服务的应用程序由多个服务组成，通常使用不同的语言和框架构建。虽然分布式应用程序的服务可能使用多种语言和框架，但这些服务的协议通常是相同的（REST，HTTP，RPC，pub &#x2F; sub等）。像Netsil这样的一些APM工具可以与这些通用协议监控服务集成，无论语言或框架如何。 Netsil监视和捕获分布式应用程序服务交互数据，以创建可视化，帮助开发人员发现和管理事件，衡量应用程序的整体运行状况，并理解应用程序的组件和依赖关系。 OpsClarity 图片来源：OpsClarity OpsClarity于2015年12月推出，是一款面向高速Web规模应用的智能监控和分析平台。OpsClarity承诺的功能包括自动拓扑发现和度量收集，拓扑可视化和性能监控。 它的一个组成部分是一个操作知识图表，它理解并不断学习操作数据模型，服务拓扑和其他应用程序&#x2F;系统性能基线。开发人员可以利用OpsClarity RESTful API来捕获自定义指标，为每个指标标注注释，并推送指标和事件。OpsClarity还提供了监视和分析工具，可显示自上而下的统一视图以及深入数据可视化。 OpsClarity使用AI和图形分析来可视化和分析大规模分布式应用程序。基础架构主机地图显示每台主机或服务的运行状况; 拓扑图帮助开发人员了解服务依赖性和基础架构组件; 时间线功能使开发人员能够回顾并查看以前的系统状态，以了解错误和失败的发生情况。 共同能力本文中突出显示的大多数APM工具都包含常见功能，例如自动发现应用程序拓扑和相互依赖性，监视应用程序运行状况，服务级别警报以及重播系统状态。 自动发现应用程序拓扑和相互依赖性可节省开发人员的时间，并缩短平均修复时间（MTTR）。开发人员不必花费数小时就可以找出服务关联和映射应用程序组件。应用程序拓扑的可视化可以帮助开发人员识别和减少服务依赖性中的瓶颈。 分布式应用程序中的服务可能存在延迟问题，错误和其他影响应用程序整体运行状况的问题。监视应用运行状况并提供服务级别警报的工具可帮助开发人员快速发现并修复应用程序问题 一些APM解决方案包括历史重播功能，可帮助开发人员调查和确定服务故障和错误的根本原因。系统状态的历史回放还可以帮助开发人员发现拓扑变化并更好地了解整体应用。 新一代APM工具复杂的分布式应用程序数量持续增长，需要新型的应用程序监控和可视化工具来帮助烦恼的开发人员迷失在调试迷宫中，弄清楚：“为什么不按照它应该的方式工作？ ！” 多个应用程序监视和管理平台正在尽力让开发人员洞察这些复杂的，相互关联的应用程序。这些APM平台利用了人工智能，机器学习和图形分析等先进技术。 传统的应用程序监视和管理平台已经不够用了。随着应用程序体系结构的不断发展和变得越来越复杂，监控，分析和管理应用程序的工具也必须发展。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"应用监控","slug":"应用监控","permalink":"https://baiyuan.wang/tags/%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/"}]},{"title":"多看看这世界","slug":"know-more-about-the-world","date":"2018-05-02T08:42:11.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"know-more-about-the-world.html","link":"","permalink":"https://baiyuan.wang/know-more-about-the-world.html","excerpt":"","text":"晚上，走过城市的灯红酒绿，也走过熙熙攘攘的人行天桥，这时经常看到许许多多大爷大妈在贩卖一些小东西，这和现在的繁华的城市社会看起来是脱节的。这突然让我想起了鲁迅的《阿q正传》里面的阿Q却是做这些小生意发了一笔财，而且算是小镇里的一个创新的商业模式了，我不知道现在的大爷会不会也是同样的思维或者说是受到他们那个时代的启发。所以我想说的，什么时候都不能停止学习不能停止跟随时代的脚步，不然，等我们老时就成为今天的大爷啦，就是时代变化很快了，不经意之间就被抛弃。 昨天看到一个小视频，看见李彦宏领着曾宝仪去参观百度大厦，中午休息时间员工在按摩椅上午休，李彦宏走进休息室打开灯，员工就是醒了一下，也没怎么表示。曾宝仪说，老板老了你在睡觉（而且招呼都不怎么打），这样不怕被炒嘛，实际上现在互联网公司的氛围很轻松自由了。 许多人在以传统的思维在看待世界，所以我也经常想，还是要多多见见世面啊。有哪些东西自己以为很自然很天经地义的，其实并不是所有的都是这样的。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"生活哲学","slug":"生活哲学","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"}]},{"title":"Docker in Docker","slug":"docker-in-docker","date":"2018-04-24T08:52:11.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"docker-in-docker.html","link":"","permalink":"https://baiyuan.wang/docker-in-docker.html","excerpt":"","text":"Docker run Docker？Docker技术目前在DevOps中被广泛使用，我们需要将测试或者构建的代码和自动化脚本打包成Docker镜像，然后部署在各运行环境中。而在CI&#x2F;CD中，我们常用一些CI&#x2F;CD服务器，比如Jenkins和GoCD来构建与部署我们的应用，从而实现CI&#x2F;CD的自动化。现在一些CI&#x2F;CD服务器也被Docker化运行在真实的物理机上。于是我们需要在CI&#x2F;CD服务器的Docker container里面来构建（build）与运行（run）我们的Docker镜像，这就涉及到”Docker run Docker”的问题。 一个很自然的想法是，我们是不是需要在CI&#x2F;CD服务器镜像中安装一个Docker Daemon和Docker命令呢？但是Docker里面跑Docker总感觉有些蹩脚，额外安装与运行Docker无疑增加了CI&#x2F;CD服务器镜像的大小，同时还增加Docker的深度。 实际上，我们并不需要在CI&#x2F;CD服务器上安装Docker。通过如下的命令在CI&#x2F;CD服务器上运行我们的镜像： docker run … -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \\ 原理：移花接木Docker采取的是C&#x2F;S架构，Docker的成功运行需要Docker Daemon和Docker Client(客户端)的支持，当我们运行一些docker build等命令时，实际是需要Docker Client连接Docker Daemon发送命令，Docker Daemon会在宿主机操作系统分配文件、网络等资源。 默认情况下，Docker守护进程会生成一个socket（&#x2F;var&#x2F;run&#x2F;docker.sock）文件来进行本地进程通信，而不会监听任何端口，因此只能在本地使用docker客户端或者使用Docker API进行操作。一般情况下，我们访问本机的服务往往通过 127.0.0.1:8080 这种IP：端口的网络地址方式进行通信，而sock文件是 UNIX 域套接字（UNIX domain socket），它可以通过文件系统（而非网络地址）进行寻址和访问的套接字。 从表象上看，上面的命令似乎依然是在“Docker里面run docker”，其实这是个误区。docker run提供了 -v 参数让我们将宿主的文件映射到docker里面。比如通过 _**-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock **_，我们将宿主的Docker Daemon的socket映射到Docker Container里面；当Container里面的docker 客户端通过 &#x2F;var&#x2F;run&#x2F;docker.sock 去操作Docker Daemon时，这些操作已移花接木地转移到宿主的Docker Daemon上。 延伸：操作远程主机既然docker client通过socket方式与本地的Docker Daemon进行通信，那么我们可以很自然地想到，如果想在其他主机上通过socket连接到远程DockerDaemon，是不是可以远程操作Docker主机进行镜像的构建与运行呢？答案是可以的，就需要让Docker守护进程监听一个端口，这样才能实现远程通信，同时需要修改docker客户端连接的主机是远程地址而并非本地sock文件。由于Docker C&#x2F;S 之间采取Rest API作为通信协议，这为我们使用第三方客户端（如postman）操作docker乃至自己开发client提供了扩展。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://baiyuan.wang/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://baiyuan.wang/tags/CI-CD/"}]},{"title":"【5】双目摄像头的实时图像传输-Pcduino平台下的智能小车","slug":"5-of-binocular-camera-pcduino-real-time-image-transmission-platform-of-smart-car","date":"2018-03-27T12:27:16.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"5-of-binocular-camera-pcduino-real-time-image-transmission-platform-of-smart-car.html","link":"","permalink":"https://baiyuan.wang/5-of-binocular-camera-pcduino-real-time-image-transmission-platform-of-smart-car.html","excerpt":"","text":"一、Mjpg-streamer开源库由于开发实时视频推送系统，可能会涉及到流媒体服务器的实现，但是通过“MJPG-streamer”开源工具可以快捷地实现。“MJPG-streamer”是成熟的轻量级的视频服务器软件，可以利用它获取摄像头画面然后发布在实时视频服务器。MJPG-streamer采用模块化的设计思路，包括输入模块和输出模块，输入模块定义了输入来源，比如摄像头、文件等等，MJPG-streamer然后将视频通过输出模块输出，比如有http等网络输出，也有文件的本地输出[8]。 本文采用支持UVC协议的双目摄像头作为图像数据的输入来源，选用http协议推送视频流，所以涉及的组件有output_http输出组件和input_uvc输入组件。通过MJPG-streamer，可以方便地将pcDuino上双目摄像头的视频通过http协议推送。 二、实现与测试使用MJPG-streamer库开发实时图像传输系统方便高效，其安装命令如下： sudo apt-get install cmake libjpeg8-dev -fsudo mkdir -p &#x2F;home&#x2F;workspace&#x2F;mjpg-streamercd &#x2F;home&#x2F;workspace&#x2F;mjpg-streamersudo git clone https://github.com/jacksonliam/mjpg-streamer.gitcd mjpg-streamer&#x2F;mjpg-streamer-experimental&#x2F;sudo make &amp;&amp; sudo make install 安装完毕可以使用命令： mjpg_streamer -i “input_uvc.so -d &#x2F;dev&#x2F;video0 -y -r 1280x480 -f 10” -o “output_http.so -p 8090 -w &#x2F;var&#x2F;www&#x2F;mjpg_streamer” mjpg_streamer安装后可作为系统服务启动，同时配置输入输出参数才能正常工作。在上述命令上涉及以下命令： -i “input_uvc.so -d &#x2F;dev&#x2F;video0 -y -r 1280x480 -f 10”部分是输入参数， so表示使用input_uvc.so作为输入模块 -d &#x2F;dev&#x2F;video0 定义了访问的摄像头的设备路径为&#x2F;dev&#x2F;video0。 -r 1280x480 定义了摄像头的分辨率为1280x480 -f 定义了实时视频的帧率为每秒10帧 -y 表示启用mjpg_streamer的YUV模式。由于mjpg_streamer处理的视频数据格式为MJPEG，而本设计采用的摄像头是YUV格式，启用mjpg_streamer的YUV模式就是为了兼容摄像头的视频流格式。 -o “output_http.so -p 8090 -w &#x2F;var&#x2F;www&#x2F;mjpg_streamer”部分是输出参数， so表示使用output_http.so作为输出模块 -p定义了http输出端口为8090 -w 定义了http服务的根目录 在命令行中启动后如下： 启动mjpg_streamer视频服务器后，可以在Chrome浏览器中输入智能车的IP和服务端口测试。mjpg_streamer默认视频端口是8090，当然也可以在启动参数进行设置。 假设智能车IP为192.168.137.2，则可访问http://192.168.137.2:8090/?action=stream访问动态的视频流，访问http://192.168.137.2:8090/?action=snapshot访问静态的抓拍图片。 当在浏览器访问上面的URL时，浏览器实际上渲染的页面源代码是： &lt;img src&#x3D;”http://192.168.137.2:8090/?action=snapshot ”&#x2F;&gt; &lt;img src&#x3D;”http://192.168.137.2:8090/?action=stream”&#x2F;&gt; 也就是说浏览器使用了img图片标签显示双目摄像头视频，值得注意的是即使是当action参数为stream时，这个img标签竟然可以持续地、动态地拉取和显示来自与服务器的视频流，这是一件很有趣的现象： 当然，使用img标签显示动态视频流并不是在所有浏览器都得到支持，例如IE就不行。 为了研究img标签显示视频流问题，可使用Chrome调试工具“审查元素”对这个HTTP请求进行分析： 依上图所示，根据这个HTTP请求的响应头，可以知道其文件扩展名Content-Type(Mime-Type)为multipart&#x2F;x-mixed-replace。 HTTP超文本协议中，HTTP请求的响应消息由状态行、消息报头、正文组成 [10] ，其中消息报头是一些描述响应数据的描述性信息，包括服务器信息、状态码、缓存控制策略等等，其中包括的Content-Type(Mime-Type)是为了告知浏览器当前传输数据的数据格式、类型。 Web服务器在响应客户端的HTTP请求时，返回的数据使用MIME报文格式进行封装。一般来说，一个HTTP响应只能包含一个数据块，但是，MIME有一种特殊的MIME类型：“multipart&#x2F;mixed”， 这种MIME类型可用一个HTTP响应数据块来表示多个数据块。其中 multipart&#x2F;x-mixed-replace MIME类型就是 “multipart&#x2F;mixed”中的一种，其中 “replace”表示每一个新数据块都会代替前一个数据块，这告诉浏览器，这种类型的新数据块不是追加到旧数据块后面，而是替代它[15]。本文中浏览器中img标签显示视频流也正是这个原因，它意味着视频图片帧会被不断刷新，最后形成连贯的视频。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://baiyuan.wang/tags/IoT/"}]},{"title":"【4】通讯指令设计-Pcduino平台下的智能小车","slug":"4-pcduino-communication-instruction-design-platform-of-smart-car","date":"2018-03-27T12:12:37.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"4-pcduino-communication-instruction-design-platform-of-smart-car.html","link":"","permalink":"https://baiyuan.wang/4-pcduino-communication-instruction-design-platform-of-smart-car.html","excerpt":"","text":"一、指令数据包协议设计在远程控制智能车系统中，远程客户端通过指令通信对智能车进行控制。在本文设计中仅涉及速度方向控制指令，为了考虑系统的可扩展性：因为后续需求可能出现更多类型的指令，本文为指令数据设计了指令代号，指令由指令代号和指令数据区组成；考虑到客户端和服务端更好地进行指令处理，指令字长为32位，与int数据类型字长相等，在服务端和和客户端进行socet套接字收发数据时可等同于int数据进行处理。在与本设计类似的课题研究中，往往使用char字符来控制方向，我觉得是不足取的，因为一个char类型如果进行分位存取数据可以节省网络流量和尽可能保证实时性的。 指令代号(4bit) 指令数据区(28bit) 当指令代号为1，表示发送车的速度方向控制指令，指令数据包为示意图： 0 3 4 11 12 13 20 21 31 指令代号 (4bit) 舵机角度 (8bit) 方向 (1bit) 速度 (8bit) 预留字段 (11bit) *1.舵机角度：8bit，控制舵机的偏转角度(A)，取值范围0-180 A&#x3D;90度时，舵机处于中间位置； A&lt;90时，舵机偏右； A&gt;90时，舵机偏左。 *2.方向：1bit，控制车的前进与后退*(D)，取值0或1* D&#x3D;0，表示小车后退； D&#x3D;1，表示小车前进。 3.速度：8bit，控制车的的行进速度****(S) 取值范围为Arduino PWM引脚可写入的数据范围，为0-255。 **4.**预留字段 用于后续可能出现的需求的扩展 二、指令数据包的封包与解包根据上一小节对指令的协议设计，我们可以通过对int数据的移位运算和逻辑运算进行封包和解包。 指令的封包就是在32位数据结构的相应位置存放对应的指令数据。 下面以指令内容为指令代号（code）c&#x3D;1，角度（angle）a&#x3D;40，方向（direction）d&#x3D;1，速度v&#x3D;150的封包与解包过程为例(为了阅读更加直观，下面的计算值使用32位二进制表示)： 将指定代号c&#x3D;1左移28位: c&lt;&lt;28 &#x3D; 0001 0000 0000 0000 0000 0000 0000 0000 将a的二进制（101000）表示左移20位： a&lt;&lt;20 &#x3D; 0000 0010 1010 0000 0000 0000 0000 0000 将d的二进制（1）表示左移19位： d&lt;&lt;19 &#x3D; 0000 0000 0000 1000 0000 0000 0000 0000 将v的二进制（10010110）表示左移11位： d&lt;&lt;19 &#x3D; 0000 0000 0000 0100 1011 0000 0000 0000 将上述计算的临时值进行或运算即可得到最终的指令： cmd &#x3D; 0001 0010 1010 11001011 0000 0000 0000 综上所述，我们得到指令封包计算公式： cmd &#x3D; (c&lt;&lt;28) | (a&lt;&lt;20) | (d&lt;&lt;19) | (v&lt;&lt;11) 等同于 ((c&lt;&lt;17)|(a&lt;&lt;9)|(d&lt;&lt;8)| v ) &lt;&lt; 11 指令的解包就是从收到的指令数据（int）的对应位置取出数据。 下面以收到的指令为cmd &#x3D; 313307136(二进制：0001 0010 1010 11001011 0000 0000 0000)为例进行数据的解包： 将cmd右移11位，剔除保留字段，这时速度数据区（8位）的最后一位移到末位，将结果赋值给cmd, 通过与运算“取出”移位后的末尾8位，即为速度： cmd &gt;&gt; 11 &#x3D; 0001 0010 1010 11001011 0 v &#x3D; cmd | (1111 1111) &#x3D; 1001 0110 cmd右移8位，剔除速度字段，这时方向数据区（1位）的最后一位移到末位，将结果赋值给cmd, 通过与运算“取出”移位后的末尾最后1位，即为方向： cmd &gt;&gt; 8 &#x3D; 0001 0010 1010 1 d &#x3D; cmd | (1) &#x3D; 1 cmd右移8位，剔除速度字段，这时方向数据区（1位）的最后一位移到末位，将结果赋值给cmd, 通过与运算“取出”移位后的末尾最后8位，即为角度： cmd &gt;&gt; 1 &#x3D; 0001 0010 1010 d &#x3D; cmd | (1111 1111) &#x3D; 0010 1010 综上所述，我们得到指令解包计算公式： cmd &#x3D; cmd &gt;&gt; 11; v &#x3D; cmd &amp; 0xFF; d &#x3D; (cmd &gt;&gt; 8) &amp; 1; a &#x3D; (cmd &gt;&gt; 9) &amp; 0xFF; 三、指令数据包封包、解包的程序实现定义汽车速度方向“向量”结构体： struct CarVector{int angle; &#x2F;&#x2F;角度bool direction;&#x2F;&#x2F;方向int speed;&#x2F;&#x2F;速度}; 根据上述的封包计算公式，可以使用如下C++代码实现封包函数，传入汽车向量结构体返回int数据： int createCmd(struct CarVector carVector) { int code &#x3D; 1;&#x2F;&#x2F;命令代号 return ((code &lt;&lt; 17) | (carVector.angle &lt;&lt; 9) | (carVector.direction &lt;&lt; 8) | carVector.speed) &lt;&lt; 11;} 实现解包函数把int数据传给carVector结构体指针 void parseCmd(int cmd, struct CarVector *carVector) { cmd &#x3D; cmd &gt;&gt; 11; carVector-&gt;speed &#x3D; cmd &amp; 0xFF; carVector-&gt;direction &#x3D; (cmd &gt;&gt; 8) &amp; 1; carVector-&gt;angle &#x3D; (cmd &gt;&gt; 9) &amp; 0xFF;} 四、通信指令封包解包测试编写如下程序进行实验测试，本程序通过先构造一个速度为40，后退，舵机偏角为150的CarVector，将其封包后在进行解包，解析出的速度、方向、偏角值与CarVector相同，表明测试通过。 int main() {struct CarVector sendCarVector&#x3D;{40,false,150},receiveCarVector; int cmd &#x3D;createCmd(sendCarVector); printf(“发送命令%d(10)\\n”,cmd); parseCmd(cmd,&amp;receiveCarVector); printf(“角度：%d\\n方向：%d\\n速度：%d”,receiveCarVector.angle,receiveCarVector.direction,receiveCarVector.speed); return 0;}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://baiyuan.wang/tags/IoT/"}]},{"title":"【3】系统架构与组装-Pcduino平台下的智能小车","slug":"3-system-architecture-assembly-pcduino-platform-of-smart-car","date":"2018-03-27T12:07:06.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"3-system-architecture-assembly-pcduino-platform-of-smart-car.html","link":"","permalink":"https://baiyuan.wang/3-system-architecture-assembly-pcduino-platform-of-smart-car.html","excerpt":"","text":"一、系统设计本文设计中，智能车通信控制系统主要由飞思卡尔小车模型、pcDuino开发板及其外接模块、远程控制客户端（智能手机）、无线局域网设备组成，其系统结构示意图如下： 依图所示，为了使用pcDuino对智能车模型的电机、舵机进行控制，本文使用L298P扩展模块插入pcDuino主板上的Arduino兼容硬件接口，由于L298P和pcDuino主板电平不匹配的原因，两者中间通过T board模块完成电平转换。双目摄像头通过USB接口接入pcDuino，由于pcDuino配备了无线WIFI模块，可以通过无线局域网和外部的远程客户端完成组网，实现远程通信和控制。 为了使用智能手机客户端对智能车系统进行控制，本设计中采用智能手机连入局域网向智能车系统发送命令来实现，系统结构是典型的C&#x2F;S（客户端-服务器）结构，这意味着智能车pcDuino开发板作为服务器，同时pcDuino借助Arduino接口完成电机、舵机等控制。客户端服务器之间的通信指令设计在4.2节中进行了详细论述。除了控制指令，客户端获取实施视频会借助MJPG-streamer来完成，这会在4.3节中详细介绍。 二、模块组装本系统中的硬件模块及其型号如下： 电源：5v 2A可充电锂电池，容量10000mAh；本设计中使用了通用的智能手机使用的移动电源来充当智能车的电源模块，由于pcDuino和电机的要求，2A的电流参数是很必要的。 pcDuino V3 3B 双核A20高性能 Cortex-A7开发板； KS352双目摄像头，1280*480分辨率，广角160°； 飞思卡尔智能车模型，带舵机电机； L298P Motor Shield 步进 直流电机驱动模块 pcDuino V23.3V到5电平转换板 pcDuino通过USB OTG与移动电源进行连接，通过USB与双目摄像头连接。将电平转换板插接在pcDuino接口上后，再将L298P和电平转换板进行连接。L298P中MA、MB一共四个接头可驱动两个电机，本文使用MA驱动，其引脚号为12；L298P上的9号引脚与舵机相连。 其连接示意图如下：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://baiyuan.wang/tags/IoT/"}]},{"title":"《2018年中国互联网公司加班报告非专业版》","slug":"chinese-internet-company-work-overtime-report-2018-nonprofessional-edition","date":"2018-03-22T13:33:33.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"chinese-internet-company-work-overtime-report-2018-nonprofessional-edition.html","link":"","permalink":"https://baiyuan.wang/chinese-internet-company-work-overtime-report-2018-nonprofessional-edition.html","excerpt":"","text":"无意中打开博客的访问数据，突然发现出几个有趣的结论，“大数据”显示: 1. 周期性的波谷是周末周日，因为大家周末一般放假； 2. 2月14到2月22有个长期的波谷，因为春节放假 3. 同一周周六的访问几乎无例外地比周日访问量高 4. 春节比周六周日访问量更低 再基于一些事实，访问本博客大都是国内程序员，可以有以下结论: 1. 中国互联网IT公司，倾向选择周六加班 2. 春节应该大家都不加班的，这个时候的访问量是一下常规基本流量，可以把周末的访问量(E)减去春节期间的访问量（S），除以一周波峰(MAX)减去春节可以计算出周末的加班比例（E - S）&#x2F; (MAX - S)，导入数据并经过平均计算得: 中国IT行业的加班比例为：周六21.53%， 周日 17.22%","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【2】模块控制-Pcduino平台下的智能小车","slug":"2-module-pcduino-platform-of-smart-car","date":"2018-03-19T14:04:10.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"2-module-pcduino-platform-of-smart-car.html","link":"","permalink":"https://baiyuan.wang/2-module-pcduino-platform-of-smart-car.html","excerpt":"","text":"一、 L298P电机控制L298P扩展板可以通过接口电路来实现PWM调速以及控制电机正反方向转动实现前进和后退。PWM调速的基本原理是通过晶体管的开关特性来调制固定电压的直流电源,通过按照一个特定的频率来实现电路的接通和断开,并根据需要改变一个周期内接通和断开时间的长短,通过改变直流伺服电动机上电压的占空比，从而改变平均电压的大小来控制电动机的转速。 基于上述论述,可以写出以下测试代码对直流电机进行速度控制，运行下面测试代码将会使直流电机缓缓加速，到达最大速度后维持3s后停止，并如此反复。 int E1 &#x3D; 10;int M1 &#x3D; 12;int E2 &#x3D;11;int M2 &#x3D; 13;void setup(){ pinMode(M1,OUTPUT); pinMode(M2,OUTPUT);} void loop(){ {int value; for(value &#x3D; 0 ; value &lt;&#x3D; 255; value+&#x3D;5) { digitalWrite(M1,LOW); digitalWrite(M2,LOW); analogWrite(E1,value); &#x2F;&#x2F;PWM调速 analogWrite(E2,value); &#x2F;&#x2F;PWM调速 delay(30); }delay(3000);analogWrite(E1,0analogWrite(E2,0);}} 二、舵机转向控制舵机控制模块是由直流电机、减速齿轮组、控制电路组成的转向控制系统。通过舵机的控制信号，可以指定输出轴的旋转角度，当输入特定角度的控制信号后，舵机会产生偏向这个角度的转动，如果控制信号持续一段时间，舵机会偏到这个角度之后保持静止。舵机模块除了应用于汽车模型的转向，还应用于机器人手臂控制、航模等等。 舵机的控制信号进入信号调制芯片，获得一个直流偏置电压，它的内部有一个产生周期为20ms，宽度为1.5ms的基准信号的基准电路，将获得的直流偏置电压与电位器的电压比较，产生电压差输出，电压差的正负输出到电机的驱动芯片就可以决定电机的正反转。当电机转速一定时，通过齿轮带动电位器旋转，如果电压差为0，电机则停止转动。 舵机的控制一般需要一个20ms左右的时基脉冲，该脉冲的高电平部分一般为0.5ms到2.5ms范围内的角度控制脉冲部分。以180度角度伺服为例，0.5ms的高电平脉冲将产生0度偏转，1.5ms的高电平脉冲将产生90度，此时可以控制小车的舵机偏到中间， 2.5ms的高电平脉冲将产生180度 #define PWM_PERIOD 20000&#x2F;&#x2F;向pin号引脚在20ms内输出pulse微秒高电平void servoSetPulse(int pin,int pulse){ digitalWrite(pin,HIGH);&#x2F;&#x2F; 输出高电平 delayMicroseconds(pulse);&#x2F;&#x2F;延时pulse 微秒 digitalWrite(pin,LOW); &#x2F;&#x2F; 输出低电平 delayMicroseconds(PWM_PERIOD - pulse); &#x2F;&#x2F;延时（PWM_PERIOD – pulse）微秒}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://baiyuan.wang/tags/IoT/"}]},{"title":"【1】概述-pcduino平台下的智能小车","slug":"1-overview-pcduino-platform-of-smart-car","date":"2018-03-19T13:36:50.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"1-overview-pcduino-platform-of-smart-car.html","link":"","permalink":"https://baiyuan.wang/1-overview-pcduino-platform-of-smart-car.html","excerpt":"","text":"本文使用飞思卡尔汽车模型，它配备了直流电机和模拟电路控制舵机，用来模拟真实汽车。汽车模型上搭载的PcDuino开发板，搭载了Ubuntu操作系统，并兼容Arduino扩展实现硬件控制，与开发板连接的双目摄像头可以采集两路视频并通过网络实时传输，为双目视觉测距提供支持；同时开发出“视觉辅助导航系统”Android端应用，可以远程实时查看智能汽车周围实况和控制汽车。 一、概论Arduino开源硬件平台的出现大大提高了硬件开发的效率，即使是没有任何硬件基础的软件程序员，只要通过使用Arduino提供的开源库，就可以编写简单的代码对硬件进行控制，使用Arduino平台大大降低了本设计的难度。 Arduino还提供了多种型号的扩展板， Arduino生态圈的强大，许多开发者为Arduino开发出周边扩展模块，例如电机模块，红外线控制模块，触摸模块，这些模块大大增强了Arduino的功能，我们可以根据项目需求购买模块，就像拼接积木一样创造出自己的创新作品。但是，Arduino无法胜任大量运算和高复杂度的工程应用，只能做一些对性能要求不高的简单工作，这是受到Arduino的硬件和软件两方面限制的。 目前大部分的Arduino主板都使用MCU作为处理器, 例如Arduino Uno的ATmega328单片机,主频只有16MHz, 内存是只有2KB的SRAM，所以运行速度、代码规模、计算能力都十分有限。此外，如果有一些复杂的工程，需要Linux操作系统支持，Arduino显然是不能达到要求的，比如你想通过一个Arduino做openCv人来做人脸识别。 而pcDuino的出现则解决了这一问题，它基本相当于一款Mini PC，配备高性能的ARM处理器，同时，它又兼容Arduino硬件平台，并能运行Linux和Android操作系统系统，是一个软硬件相结合的开放应用开发平台。[2] 兼容Arduino意味着pcDuino不仅可以使用Arduino的扩展模块，还能兼容Arduino的项目代码，在pcDuino完成Arduino编程。 二、硬件选型PcDuino开发平台根据需求有众多的版本的开发板，由于本文需要远程控制小车（需要WIFI功能），同时能获取两路摄像头视频（可扩展的USB接口），于是选用了配备1GHz主频的AllWinner A20 SoC ARM中央处理器、无线Wifi网卡的PcDuino 3B型号。 电机驱动模块L298P智能控制的关键之一是对速度的控制,本文使用L298P电机驱动模块对智能小车进行驱动。L298P Shield直流电机驱动器可直接驱动直流电机，驱动电流达2A，并可以通过PWM进行调速，可插接到Arduino上使用，同时它还配备了一个舵机控制插口控制舵机，和蜂鸣器可用于倒车警报。 舵机控制模块舵机控制模块是由直流电机、减速齿轮组、控制电路组成的转向控制系统。通过舵机的控制信号，可以指定输出轴的旋转角度，当输入特定角度的控制信号后，舵机会产生偏向这个角度的转动，如果控制信号持续一段时间，舵机会偏到这个角度之后保持静止。舵机模块除了应用于汽车模型的转向，还应用于机器人手臂控制、航模等等。 飞思卡尔车模 双目摄像头双目摄像头就是具有两个镜头的摄像头，随着VR和3D视频技术的发展，双目摄像头在一些VR摄像机、手机上得到广泛的应用。双目摄像头模仿人的双眼，通过两个摄像头拍摄的不同画面，可以应用于计算机视觉测距。 下图为市场上购买的双目摄像头模块，可以通过USB接口与PC、开发板等相连，同时支持UVC协议。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://baiyuan.wang/tags/IoT/"}]},{"title":"Women in IT","slug":"women-in-it","date":"2017-08-27T14:59:42.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"women-in-it.html","link":"","permalink":"https://baiyuan.wang/women-in-it.html","excerpt":"","text":"In ThoughtWorks, there are three pillars: continuous business(P1), software excellence(P2), social and economic justice(P3). Taking P3 as a mission of company makes ThoughtWorks unique in all companies.In This week, The founder of ThoughtWorks ,Roy ,has sold ThoughtWorks to APAX, a private equity investment group in Europe, After that the topic about whether P3 will be reserved in the missions of ThoughtWorks is actively discussed among ThoughtWorkers. Social and economic justice is a serious topic in ThoughtWorks. In TWU, this topic will be talked about almost every week. The social respect for information technology affects women’s information technology, and the work of IT is considered to be very hard and programers work overtime. In China , girls are expected to find a job with little strength. We have done some research to know about the general situation about women in IT.The first problem is gender imbalance.we have found the proportion of women at entry levels in IT are very low, and it tends to worsen as women become more senior. A study shows that In USA, IT jobs held by women is only 25%. The second situation we have found there is common pay gap between men and women.In 2015,women working full time in the united states were paid just 80% of what men were pay, it means it’s a gap of 20% percent. The another problem is about sexual harassment, a fact really surprize me that a study shows that 60% of women in silicon valley have experienced sexual harassment.","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[]},{"title":"我们走过的人生境界","slug":"we-walked-through-life-realm","date":"2017-05-11T02:09:45.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"we-walked-through-life-realm.html","link":"","permalink":"https://baiyuan.wang/we-walked-through-life-realm.html","excerpt":"","text":"小时候，我们觉得这个世界天真烂漫，一切都是那么美好，世界就像花园一样，蜂飞蝶舞，阳光明媚； 长大一点，我们读了一些书，见过更多的人，看到更多人生百态，慢慢发现这世界有许多的阴暗面，人怎么能那么坏，那么龌龊，这个国家太黑暗了，社会太无可救药了，我们简直生活在层层阴霾下惶惶终日，随着时间的推移，这阴霾感觉越来越重。 后来，我走过许多路，见过更多的事，经历过人生的许许多多的炎凉，感悟过许多先贤的箴言，理解了许多当初自认为恶人的心境，发现生活一点一滴的感动与温暖，我慢慢发现世界不是我想象的那么黑暗的，芸芸众生里掺杂着多少无奈，有许多人有着不为浅薄的我所不理解的睿智。我当初是片面了吗，不，我相信认识是需要一个过程的。 破茧成蝶，返璞归真，江山如此多娇啊！世界是那么真实，那么辽阔，我解开种种疑惑，冲破心里的种种阴霾，见到久违的阳光，世界越来越光明；人生突然豁然开朗，世界不是蓝天白云，而是如同晚霞下的那种壮美啊！ 有一天，你独上高楼望尽天涯路的时候，有人对你说，你还在第一境界啊，幼稚！我希望，你能自信这是别人的浅薄，并用仁慈的胸怀容纳别人的虚妄。","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"生活哲学","slug":"生活哲学","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"},{"name":"旅行","slug":"旅行","permalink":"https://baiyuan.wang/tags/%E6%97%85%E8%A1%8C/"}]},{"title":"软件不仅是开发那么简单","slug":"software-development-not-only-that-simple","date":"2017-03-09T13:26:55.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"software-development-not-only-that-simple.html","link":"","permalink":"https://baiyuan.wang/software-development-not-only-that-simple.html","excerpt":"","text":"许多“有抱负”或者热爱编程的程序员，对全栈工程师可能都是孜孜以求。全栈是一种极客精神，对软件的每一种编程语言、每一个开发平台都有着浓厚的兴趣，并愿意为之付出努力，全栈工程师应该对软件各个方面都有广泛的接触面，对软件有深刻的洞察力，这种广而深的见识将让我们开发出更加高效率地开发应用。 我们周遭的人对全栈的描述往往是“我熟悉C&#x2F;C++，java；swift，Ruby都会一点，还能开发IOS、Android、Windows应用，Web前端后端都做过。用过这些框架：……” 全栈元素周期表，来自xebialabs 是的，在没有接触ThoughtWorks之前，我对全栈的定义就是这样的，什么语言都“会”，至少写过，各个平台上的开发都有经验。在这种定义下，我会略自负地讲自己算是一个全栈工程师吧。甚至，哈哈，除了上面讲的这些，我还开发过硬件平台上的软件（Arduino)，自己用PS为自己的Android客户端设计过界面、图标，鼓捣过图标字体。是呀，想想这就骄傲，突然发现自己会那么东西。（当然了，理性地讲，其实自己心知肚明也就是“会一点”。） 窃认为我本人是一个对生活比较有想法的人，当我发现生活中有一些可以用软件来解决问题的时候，我喜欢自己开发出软件来解决：比如 我曾因为看到大学请假不方便，然后开发出给学生、辅导员、任课老师使用的请假APP，这个最后作为我Android开发实践课的大作业作品，老师打了100分；由于学校会经常让学生签到，我和几个同学利用微信公众号首先让学生在微信上签到并且获取他们的地理位置；由于在火车上无聊，我和几个同学做出一个在火车上搭建局域网然后借助我们的系统让乘客在火车上点餐、看电影、看火车沿途风景直播、到站提醒的应用……。在这个过程中，我得到很大的满足感和成就感，也学会了更多的软件技术，似乎离“全栈”更近了一步。 产品不仅是有想法就去干，而是持之以恒的打磨，它许多软件开发的多个角色地合力完成暑假在腾讯实习的两个月，学习到的技术实际上是其次的；甚至因为实习颠覆了之前对BAT神一样存在的看法。他们的代码质量的确很高，但是并不是不食人间烟火，他们也会写Hard code，也会满百度、谷歌地贴代码。实习中让我看到的更多的是，一个好的互联网企业善于让多个角色之间进行良好的互动，它有一个成熟地为开发代码而做的系统；与我们在学校里不同的是，一个来自与产品和测试的需求、Bug工单流传到开发有一个完善严格的流程。 我做过的许多东西，实际很多都没有投入使用，仅仅是自己的自娱自乐，一个软件产品真正投入大规模使用，需要大量人力去做产品、运营。然后，我热爱开发，但是觉得产品、运营是个麻烦事。 入坑越久，你以为越渊博，实际上不自知视野变小了校招，加入了我一个很喜欢的公司：ThoughtWorks（TW），TW是一个崇尚分享的公司，她期望我们把我们自己的想法用文章的形式表达出来。在周末时间，公司安排了职前培训，其中有一项任务是让我们在简书上写我们的学习过程、分享心得感受。同时公司的培训团队（“思沃大讲堂”）还会定期统计我们的文章，统计方式是做了一个爬虫抓取简书上的文章信息然后汇总输出报告。 当时，我正在学习Ruby网络请求的知识，看见每周一次发来的文章统计报告，我就萌生了做一个Ruby爬虫的想法。做出来以后我输出了一篇文章到简书，负责TW培训的李鹏大哥（下称“总理”）看到以后，便决定让我的代码来做帮助同学们统计文章的工作，之后让我专门成立了一个小团队：思沃大讲堂爬虫项目组 我最初想成立这个项目组的目的，帮我们统计文章只是其一，更重要的是我想通过这个项目带动自己的Ruby学习进程。而总理的目的则是，希望学习项目开发的过程，让更多的人参与、合作。 到今天，几个月过去了，虽然爬虫组虽然基本能定期给参加思沃大讲堂的同学们发送一份统计报告，但是远远没有达到初衷。个人的出发点，本来想把报告做的更漂亮一点，页面中加入一些图片、报表等直观的视觉效果，加入文章排行提高同学们的活跃度，通过简单的算法实现好文章、优秀作者的推荐，找出最贴心的小buddy等等。从这些我想达到的初衷讲，这个项目显然失败了，而失败的原因，也正是总理 想要我们通过这一项目培养的项目开发、交流合作等方面的能力不足。 这个项目中，作为项目发起人，我最早为项目勾画了一个蓝图，搭建起项目的框架。一个在自己看起来很简单的一个需求点，对于自己看来实现起来也十分简单，但是传达给项目成员并实施却十分困难；首先，对于项目发起人，可能会根据自己的一些经验提出一些需求点，虽然这些需求在提出时就经过自己的大脑过滤是可实现的，但是对于没有相关经验的其它团队成员来说，他们认为的可不一定有那么简单。作为作为软件工程科班出身的学生，在我们“稚嫩”的认识中，软件的世界里似乎只有程序员这一个角色，当然“只有”这个词说的太偏执，诚然我还知道产品、测试、运营、运维等角色，但是长期囿于学校里小型项目的学生，往往长期忽略了产品甚至测试的重要性，产品，提需求的是我们；测试，我们写代码的自己测，不重要的地方就省掉吧；运维，随便搭个服务器呗。我们把软件开发的绝大部分重心放在开发上面，做软件就是开发，这一意识的植入，将会导致深重的开发本位思想，或者做事情的都站在开发的角度。比如作为一个项目发起人，我负责这个项目要实现什么样的功能，带着开发思维，是这样提“工单”的： 实现数据库中插入和更新文章信息（封装成一个方法），用于以后在爬虫抓取文章信息后直接调用 甚至我还会写明大家使用Sqlite3数据库。这样的工单开发思维就比较重了，作为项目发起人、作为产品、作为BA（业务分析），这样的单子就严重越权了，我们的职责应该是作为一个角色，要达到什么效果，这样做有什么价值（As a role，I want to …, so that …），具体怎么做应该交给开发，而不是用什么技术都要规划好。当总理指出我的错误，我却依旧带着“开发”的思维来规划项目时，我想我“入坑”依旧了。 或许，对于一个个人项目，我们可能有非常清晰的意图知道自己接下来做什么，然而，做一个较大的项目始终依托团队来完成，作为“世界上最复杂的逻辑实体”，软件是越来越难被一个人完成的。 我所看到“市面”上的“软件工程师”，坦诚地讲，往往等同于“码农”，或者通俗地讲就是“写代码的”。写代码，码农，从“软件工程”的学科定义来讲，并不能算的上是软件工程师的，更谈不上全栈软件工程师。作为一名“科班出身”的“软件工程”专业的学生，教科书上的定义翻译成通俗点的话是这样的：用工程化的方法来开发软件。 而我想，作为工程，应该是怎样规划“施工”，怎样管理团队，怎样让工程更加高效、有序地进行，而这正是软件工程师与“写代码的”之区别本质所在。而全栈，也不仅仅是局限于开发技术上的全栈，而是包括业务分析、项目管理等等软件工程应用上的全栈。 版权印为您的作品印上版权22104666","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"软件开发","slug":"极客视点/软件开发","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"React Native中添加Base64支持","slug":"adding-base64-react-native-support","date":"2017-03-08T08:43:49.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"adding-base64-react-native-support.html","link":"","permalink":"https://baiyuan.wang/adding-base64-react-native-support.html","excerpt":"","text":"最近极客人在使用React Native制作的自己的博客客户端，客户端在调用Wordpress Rest API时有些操作需要使用HTTP认证，而HTTP认证中主要就是在HTTP请求中的头部加入 “Authorization”字段，Authorization字段的内容时 用户名:密码 的base64编码 环境依赖Base64编解码算法在Nodejs的buffer组件中有支持，首先我们需要在React Native项目根目录下运行命令行安装buffer依赖： npm install buffer --save 安装完毕后，React Native根目录的app.json中的dependencies便会自动加入下面一条： React Native中添加Base64支持 使用方式引入var Buffer = require(&#39;buffer&#39;).Buffer 编码var base64Str= new Buffer(rawStr).toString(&#39;base64&#39;); 解码var b &#x3D; new Buffer(base64Str, ‘base64’)var s &#x3D; b.toString(); Buffer项目主页：更多buffer的使用方法参考Buffer主页：https://github.com/feross/buffer","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://baiyuan.wang/tags/React-Native/"}]},{"title":"Ubuntu下利用Java CV获取双目摄像头图像","slug":"by-using-java-cv-for-binocular-camera-image-under-ubuntu","date":"2017-03-06T12:08:25.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"by-using-java-cv-for-binocular-camera-image-under-ubuntu.html","link":"","permalink":"https://baiyuan.wang/by-using-java-cv-for-binocular-camera-image-under-ubuntu.html","excerpt":"","text":"毕业设计的项目是做一个通过双目摄像头测出物体的距离，然后控制模型车避开较近的障碍物，所以需要将安装在模型车上双目摄像头的图像传输，发送到电脑端进行双目测距算法的计算，然后电脑将计算的结果发送到小车，小车控制行驶方向从而避开障碍物。小车上使用Pcduino开发板，安装Ubuntu系统，外插Arduino扩展板，连接小车的硬件部分。 从淘宝上买回的双目摄像头后，使用java cv获取到双目摄像头图像的方式与单目摄像头的方式是类似的。不同的地方是要想分离双目摄像头的画面需要设置代码中的分辨率参数。 package cn.wangbaiyuan.doublecamera; import javax.swing.JFrame; import org.bytedeco.javacv.CanvasFrame;import org.bytedeco.javacv.OpenCVFrameConverter;import org.bytedeco.javacv.FrameGrabber.Exception;import org.bytedeco.javacv.OpenCVFrameGrabber; &#x2F;*** 调用本地摄像头窗口视频* @author BrainWang* @version 2017年3月6日*&#x2F; public class Camera{public static void main(String[] args) throws Exception, InterruptedException{OpenCVFrameGrabber grabber &#x3D; new OpenCVFrameGrabber(1);&#x2F;&#x2F;设备号，你的电脑上可能有多个摄像头，0和1自己试试分别对应哪一个grabber.start(); &#x2F;&#x2F;开始获取摄像头数据CanvasFrame canvas &#x3D; new CanvasFrame(“摄像头”);&#x2F;&#x2F;新建一个窗口canvas.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);canvas.setAlwaysOnTop(true); while(true){if(!canvas.isDisplayable()){&#x2F;&#x2F;窗口是否关闭grabber.stop();&#x2F;&#x2F;停止抓取System.exit(2);&#x2F;&#x2F;退出} canvas.showImage(grabber.grab());&#x2F;&#x2F;获取摄像头图像并放到窗口上显示， 这里的Frame frame&#x3D;grabber.grab(); frame是一帧视频图像 Thread.sleep(50);&#x2F;&#x2F;50毫秒刷新一次图像}}} 如果不对分辨率进行任何的设置，得到的效果是这样的： 双目摄像头画面 是不是似曾相识，我们在电影院看3D电影不戴眼镜看到的就是这样的。对于开发者来说两路图片混合在一起显然不是好事，需要在代码里做如下设置。 int captureWidth &#x3D; 1280; int captureHeight &#x3D; 480; grabber.setImageWidth(captureWidth); grabber.setImageHeight(captureHeight); 因为笔者手中的摄像头每一只分辨率为640_480,所以将分辨率改成1280_480，可以成功的将图片分离。 package cn.wangbaiyuan.doublecamera; import javax.swing.JFrame; import org.bytedeco.javacv.CanvasFrame;import org.bytedeco.javacv.OpenCVFrameConverter;import org.bytedeco.javacv.FrameGrabber.Exception;import org.bytedeco.javacv.OpenCVFrameGrabber; &#x2F;** * 调用本地摄像头窗口视频 * @author BrainWang * @version 2017年3月6日 *&#x2F; public class Camera{ public static void main(String[] args) throws Exception, InterruptedException { OpenCVFrameGrabber grabber &#x3D; new OpenCVFrameGrabber(1); int captureWidth &#x3D; 1280; int captureHeight &#x3D; 480; grabber.setImageWidth(captureWidth); grabber.setImageHeight(captureHeight); grabber.start(); //开始获取摄像头数据 CanvasFrame canvas = new CanvasFrame(&quot;摄像头&quot;);//新建一个窗口 canvas.setDefaultCloseOperation(JFrame.EXIT\\_ON\\_CLOSE); canvas.setAlwaysOnTop(true); while(true) &#123; if(!canvas.isDisplayable()) &#123;//窗口是否关闭 grabber.stop();//停止抓取 System.exit(2);//退出 &#125; canvas.showImage(grabber.grab());//获取摄像头图像并放到窗口上显示， 这里的Frame frame=grabber.grab(); frame是一帧视频图像 Thread.sleep(50);//50毫秒刷新一次图像 &#125; &#125; } 图片分离以后的效果是这样的： 双目摄像头图像分离 代码使用了java cv的库，如果是maven项目，需要这样配置依赖： 在pom.xml中project节点下添加： org.bytedeco javacv-platform 1.3.1 更多的环境配置可以访问 java cv的官方Github主页。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"}]},{"title":"怎样释放Android手机存储空间","slug":"how-release-android-mobile-phone-storage-space","date":"2017-02-23T05:38:34.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-release-android-mobile-phone-storage-space.html","link":"","permalink":"https://baiyuan.wang/how-release-android-mobile-phone-storage-space.html","excerpt":"","text":"Android应用在运行之中会产生一些数据，比如图片的缓存，数据库文件，配置文件等等。我们开发时可能会有这样的一个需求清除应用内缓存的数据，可以让用户选择删除应用内产生的数据，这也是比较人性化的设计点。过多的缓存会占用手机的存储空间，据说也会降低手机的IO性能。 下面这是简书Android APP中提供了清除缓存的设计： 那么Android应用在运行中会产生哪些数据呢？它们都被存放在哪里？然后我们根据产生数据的位置实现清除功能 首先简单讲讲Android的四种数据存储方式1、SharePreferenc一种轻型的数据存储方式，实际上是基于XML文件存储的“key-value”键值对数据；通常用来存储程序的一些配置信息。 SharePreference的存储目录：其存储在“data&#x2F;data&#x2F;程序包名&#x2F;shared_prefs目录下。 SharePreference修改和存储数据 根据Context的getSharedPrerences(key, [模式])方法获取SharedPreference对象； 利用SharedPreference的editor()方法获取Editor对象； 通过Editor的putXXX()方法，将键值对存储数据； 通过Editor的commit()方法将数据提交到SharedPreference内 2、SQLiteSQLite是一个轻量级关系型数据库，既然是关系型数据库，那操作起来其实跟mysql、sql server差不多的。 Android提供了强大数据库管理库，同时也支持运行哦原生命令，实现数据库的增删改查 3、 File Android中可以在设备本身的存储设备或外接的存储设备中创建用于保存数据的文件。在默认状态下，文件是不能在不同程序间共享的。 File可以通过FileInputStream和FileOutputStream对文件进行操作。 4、ContentProviderContentProvider相对于其它的方式比较复杂，当然其功能相对于其它的方式也是革命性的改变。它能够实现跨应用之间的数据操作。利用ContentResolver对象的delete、update、insert、query等方法去操ContentProvider的对象，让ContentProvider对象的方法去对数据操作。 实现方式为： 在A程序中定义一个ContentProvider，重载其增删查改等方法； 在A程序中的AndroidManifest.xml中注册ContentProvider； 在B程序中通过ContentResolver和Uri来获取ContentProvider的数据，同样利用Resolver的增删查改方法来获得和处理数据 Android应用的数据存储路径应用内数据的所有路径和对应的数据清除代码： &#x2F;data&#x2F;data&#x2F;com.xxx.xxx&#x2F;cache - 应用内缓存（注：对应方法getCacheDir() ） public static void cleanInternalCache(Context context) { deleteFilesByDirectory(context.getCacheDir()); } &#x2F;data&#x2F;data&#x2F;com.xxx.xxx&#x2F;databases - 应用内数据库 public static void cleanDatabases(Context context) { deleteFilesByDirectory(new File(“&#x2F;data&#x2F;data&#x2F;“ + context.getPackageName() + “&#x2F;databases”)); } &#x2F;data&#x2F;data&#x2F;com.xxx.xxx&#x2F;shared_prefs - 应用内配置文件 public static void cleanSharedPreference(Context context) { deleteFilesByDirectory(new File(“&#x2F;data&#x2F;data&#x2F;“ + context.getPackageName() + “&#x2F;shared_prefs”)); } &#x2F;data&#x2F;data&#x2F;com.xxx.xxx&#x2F;files - 应用内文件（注：对应方法getFilesDir()) public static void cleanFiles(Context context) { deleteFilesByDirectory(context.getFilesDir()); } 由于Android应用数据存储的权限比较宽泛，一个Android应用几乎可以在SD卡任意位置创建一个目录和文件，所以上面的几个存储路径只是Android应用最基本的存储路径。更多的清除代码实现在下面的清除工具类中将于更详细的讲解 清除工具类的代码实现为了方便使用，下面时我封装好的数据清除工具类： package cn.wangbaiyuan.utils; &#x2F;** * Created by BrainWang on 2017-02-21. *&#x2F;import java.io.File;import java.io.IOException;import java.math.BigDecimal;import android.content.Context;import android.os.Environment; &#x2F;** * 清除缓存 * *&#x2F;public class CleanDataUtil { /\\*\\* \\* 清除本应用内部缓存(/data/data/com.xxx.xxx/cache) * * @param context */ public static void cleanInternalCache(Context context) &#123; deleteFilesByDirectory(context.getCacheDir()); &#125; /\\*\\* \\* 清除本应用所有数据库(/data/data/com.xxx.xxx/databases) * * @param context */ public static void cleanDatabases(Context context) &#123; deleteFilesByDirectory(new File(&quot;/data/data/&quot; \\+ context.getPackageName() + &quot;/databases&quot;)); &#125; /\\*\\* \\* \\* 清除本应用SharedPreference(/data/data/com.xxx.xxx/shared_prefs) * * @param \\* context */ public static void cleanSharedPreference(Context context) &#123; deleteFilesByDirectory(new File(&quot;/data/data/&quot; \\+ context.getPackageName() + &quot;/shared_prefs&quot;)); &#125; /\\*\\* \\* 按名字清除本应用数据库 \\* \\* @param context * @param dbName */ public static void cleanDatabaseByName(Context context, String dbName) &#123; context.deleteDatabase(dbName); &#125; /\\*\\* \\* 清除/data/data/com.xxx.xxx/files下的内容 * * @param context */ public static void cleanFiles(Context context) &#123; deleteFilesByDirectory(context.getFilesDir()); &#125; /\\*\\* \\* \\* 清除外部cache下的内容(/mnt/sdcard/android/data/com.xxx.xxx/cache) * * @param \\* context */ public static void cleanExternalCache(Context context) &#123; if (Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED)) &#123; deleteFilesByDirectory(context.getExternalCacheDir()); &#125; &#125; /\\*\\* \\* 清除自定义路径下的文件，使用需小心，请不要误删。而且只支持目录下的文件删除 \\* \\* @param filePath */ public static void cleanCustomCache(String filePath) &#123; deleteFilesByDirectory(new File(filePath)); &#125; /\\*\\* \\* 清除本应用所有的数据 \\* \\* @param context * @param filepath */ public static void cleanApplicationData(Context context, String... filepath) &#123; cleanInternalCache(context); cleanExternalCache(context); cleanDatabases(context); cleanSharedPreference(context); cleanFiles(context); for (String filePath : filepath) &#123; cleanCustomCache(filePath); &#125; &#125; /\\*\\* \\* 删除方法 这里只会删除某个文件夹下的文件，如果传入的directory是个文件，将不做处理 * * @param directory */ private static void deleteFilesByDirectory(File directory) &#123; if (directory != null &amp;&amp; directory.exists() &amp;&amp; directory.isDirectory()) &#123; for (File item : directory.listFiles()) &#123; item.delete(); &#125; &#125; &#125; /\\*\\* \\* 清除所有缓存，相当于设置里应用管理中的“清除数据”，清除数据时应用将会退出 \\* @param context */ public static void clearAppUserData(Context context) &#123; try &#123; Runtime.getRuntime().exec(&quot;pm clear &quot; + context.getPackageName()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; } 系统设置应用管理的”清除数据“的实现方法在Android系统设置的应用管理中，提供了”清除数据“的功能，这一功能对应用数据的清除更加彻底，我们可以在代码中实现类似的需求，不过下面代码的执行将使应用退出： &#x2F;** * 清除所有缓存，相当于设置里应用管理中的“清除数据”，清除数据时应用将会退出 * @param context *&#x2F; public static void clearAppUserData(Context context) { try { Runtime.getRuntime().exec(“pm clear “ + context.getPackageName()); } catch (IOException e) { e.printStackTrace(); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"【图片去霾算法实践】NDK下二维数组的传递","slug":"practice-photo-haze-algorithm-under-ndk-two-dimensional-array","date":"2017-01-16T04:05:07.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"practice-photo-haze-algorithm-under-ndk-two-dimensional-array.html","link":"","permalink":"https://baiyuan.wang/practice-photo-haze-algorithm-under-ndk-two-dimensional-array.html","excerpt":"","text":"最近看到了一篇关于图片“去霾算法”的文章，一下子就有了兴趣，所以想着能不能实现。由于数学能力捉急，无法理解文章的思想和相关论文。于是在Github上找到了相关的Java代码，算法的效果十分明显： 去霾前的图片 去霾算法处理后的图片 不知道是不是算法太复杂，还是Java效率相对较低的缘故，一个3M的JPG图片处理下来需要近20秒的时间。 效果明显的算法让我萌生了开发一款去霾相机的想法，为了获得更快的处理速度，在研究Java去霾算法代码后，我决定将其写成C++代码，然后通过NDK（Android原生开发）移植到Android平台。 项目的基本思想是在Android&#x2F;Java下获得图片的Bitmap将其像素点转成二维的int二维数组，然后将int二维数组传入JNI层，交给NDK层C++代码处理，NDK层处理完毕后返回去霾后的int二维数组，由Java层转成Bitmap重新显示或保存。 经过一天的奋斗，我终于实现了用C++代码实现“去霾”算法并顺利移植到Android原生开发中。效果已实现，目前还有很多BUG，图片大小稍大时算法耗费的时间和内存过大. Android 图片去霾 本文预计会写一个系列，后续根据情况可能会开源。如果你对去霾算法实践感兴趣，可以关注我的简书和博客：http://baiyuan.wang ,后续将持续更新 本篇文章介绍NDK和Java层怎样互传二维数组 NDK-&gt;C++ndkArray[mHeight][mWidth]-&gt;cppArray[mHeight][mWidth]int \\*\\*cppArray= new int \\*\\[mHeight\\]; for (int i = 0; i &lt; mImageHeight; i++) &#123; cppArray\\[i\\] = new int\\[mWidth\\]; jintArray intdata = (jintArray) env-&gt;GetObjectArrayElement(ndkArray, i); cppArray\\[i\\] = env-&gt;GetIntArrayElements(intdata, 0); env-&gt;DeleteLocalRef(intdata);//释放内存，防止内存泄漏 &#125; &#125; C++-&gt;NDKcppArray[mHeight][mWidth]-&gt;ndkArray[mHeight][mWidth] jobjectArray ndkArray&#x3D; env-&gt;NewObjectArray(mHeight,env-&gt;FindClass(“[I”),NULL); for (int i &#x3D; 0; i &lt; mHeight; i++) { jintArray jintArray&#x3D; env-&gt;NewIntArray(mWidth); env-&gt;SetIntArrayRegion(jintArray, 0, mWidth, out[i]); env-&gt;SetObjectArrayElement(ndkArray, i, jintArray); env-&gt;DeleteLocalRef(jintArray); } return ndkArray;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"微信小程序背后的思考","slug":"thinking-behind-wechat-small-programs","date":"2017-01-11T05:34:57.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"thinking-behind-wechat-small-programs.html","link":"","permalink":"https://baiyuan.wang/thinking-behind-wechat-small-programs.html","excerpt":"","text":"1月9日，万众期待的微信小程序正式发布；朋友圈早早地被微信小程序的相关信息所刷屏，极客人也耐不住心里的好奇心，也关注了几个微信小程序尝了尝鲜儿。从技术的角度上，微信小程序个人认为谈不上有什么可圈点的创新；但是在软件应用的生态上，可能会产生巨大的影响。 微信公众号 大一统早在一年多前，那时候还没有人任何微信小程序的风声，极客人在和同学的交流过程中，就曾“预言”了“小程序”的出现。那时候微信公众号只有 订阅号和服务号，我说，微信公众号应该可以加一个“应用号”，一年多以后，微信小程序横空出世，微信公众号也真的多了一个类型 “应用号”，名字和我当初起的都一模一样。当然，我在这里并不是想炫耀自己前瞻眼光，而是想表明，微信小程序的出现是软件开发中一个很正常的产物。 在软件开发繁荣的今天，编程语言越来越多，软件开发的平台不尽相同，软件开发商为了迎合不同使用平台的用户，不得不开发各个平台上的应用，IOS、Android作为移动操作系统的两大巨头，每个都有巨大的用户群，这意味着软件厂商要做一个同样的软件，都要编写两套代码：Android上的JAVA，IOS上的Object C&#x2F;Swift，这无疑提高了成本。从近几年的软件开发的趋势来看，虽然大家都以标榜自己“全栈开发工程师”为荣，但是我却认为这也只是无奈之举，如果有一套代码在所有平台都能跑的话而且都拥有绝佳的性能的话，没人吃饱着撑着，造出各种开发语言。 软件开发百花齐放的今天，无论是程序员，还是软件厂商，都希望能够有一个“大一统”来结束这个既繁荣又混乱的局面。前几年，HTML5开发移动APP企图基于各平台的浏览器实现跨平台；Web中的前端开发中的“响应式布局”实现一套代码在 PC、平板、手机上智能化显示最适合的界面；QT开发工具希望用一套C++代码开发出在Windows、Linux、Android、IOS的原生APP；最近，React 正在用JS统治Web、IOS、Android的路上越走越远…… 微信小程序要做的，就是开发一套代码，在IOS、Android拥有相同的用户体验，而它基于的是HTML。HTML无疑在各个平台拥有最好的兼容性，哪里有浏览器，哪里就可以解析HTML。 虚拟化如果让我用一些关键词来概括软件开发的特点的话，在我的答案中一定有一个词就是“虚拟化”。操作系统完成了底层硬件的虚拟化，让上层应用不需要关心底层硬件的操作细节和差异。虽然运行着windows操作系统的计算机数以亿计，它们的CPU、网卡、磁盘等都各不相同，通过Windows系统的Win32 API，程序员和上层应用不必理会底层环境的差异性，程序员运用相同的代码就可以对不同型号的硬件进行操作。同理的还有Java虚拟机。 可以这么说，微信的小程序，就是以微信为平台，通过相同的代码，可以在IOS和Android上拥有相同的操作，比如布局、支付、定位等等，微信虚拟化了布局、支付、定位这一层在Android和IOS上的细节 。在这个意义上，可以说微信是个“操作系统”。当然这样就把操作系统说的太简单，更准确的是微信应该是一个虚拟机。 插件化带来的思考能预言到“微信小程序”的出现，是不足为奇的，现在许多软件在完成各自职能的同时，往往自身也作为平台出现。 平台是什么？牛顿说，“如果说我看得比别人更远些，那是因为我站在巨人的肩膀上。”。那么这个巨人就是牛顿的平台了。虚拟化带来的结果，就是为上层应用带来更坚实的平台。在平台之上，我们可以忽略平台下面的实现细节。 作为平台出现的软件，可以实现诸多的扩展。极客人的博客是使用wordpress CMS平台搭建的，在wordpress上面，我们可以利用安装插件的方式实现防垃圾评论等等功能；在Chrome浏览器上，我们通过安装插件实现了广告屏蔽；而QQ内置查看word文档的功能，也是通过插件实现的（极客人实习的时候看过QQ的源代码）。 插件是平台之外的扩展，基于平台的插件，忽略了底层细节，同时让平台的功能更加丰富，走得更远。同时，开放的平台，也让平台更加活跃，为自己的生存灌输了青春。 微信小程序在某种意义上也是微信的插件，在极客人尝试了用wordpress、Chrome装插件后，我想，预知“应用号”的出现不会是什么难事。 用完就想卸载曾经看过一篇文章，每个软件厂商都希望让自己开发的软件在用户的PC、手机上不被卸载，而其中的关键就是占领用户的桌面和状态栏。然而现在的应用市场上的APP千千万，由于过多的APP会导致手机的速度变慢、可用ROM变小，许多用户都是装完一个APP就马上卸载。 由于微信小程序的即用即删性，符合了用户的“洁癖”心理，在一些不常用的应用上，微信小程序必定大受欢迎。 姗姗来迟的谷歌Instant App在微信小程序发布之前，谷歌在2016年谷歌大会上，曾计划推出一种类似的”小程序”—Android Instant APP;通过谷歌Deep link，用户点击一下链接即可以运行应用，目前仅支持比较简单而基础的应用，可以说它介于纯粹的Web应用和应用程序之间，“Instant Apps”将应用下载大小限制为最高4MB，并向下兼容到安卓4.1操作系统。 我们如今手机安装的应用，占用内存动辄百兆起步，许多应用添加了我们根本不需要的功能，应用间的相互串联也是让我们苦不堪言。如今Instant Apps为我们开启了一扇新的大门，我们手机目前也有点击网页跳转应用的功能，与此不同的是，Instant Apps的跳转直接并非转往完整的应用，而是根据用户的需要，跳转至拥有某个特定功能的APP，比如说我们在网页观看视频，需要转往应用观看，然而该视频应用十分卡顿，经常推送一些无用信息，若该视频应用开发了Instant Apps，那么我们会跳转到该视频的Instant Apps界面，该界面仅包含视频播放的相关功能，十分简洁流畅。 这么一来，若许多购物应用和社交应用都开发了Instant Apps，那么我们的用户体验将会有很大提升，手机的负担也不会那么沉重。从开发者的角度讲，这类应用的推广难度降低，甚至不需提交至应用商店，仅需分享应用的相关连接即可，十分省心。用户点击即用，倒也快捷 基本应用场景和微信小程序类似，个人认为的最大优点可能是原生开发性能会优于微信。但是由于微信小程序拥有微信这个大流量的入口，而且已经先发制人地发布了，我想，Instant APP至少在中国地区胎死腹中。 目测腾讯广告收入不久会出现一个高潮目前微信小程序里里面还没有广告，但是不久的将来，目测微信很快就会提供财付通的广告SDK方便开发者接入，这么应用转向微信小程序，腾讯的广告收入必定迎来一波大幅度增长。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1/"}]},{"title":"Ruby图片处理基本算法（二）二值、灰度、浮雕...","slug":"ruby-basic-image-processing-algorithm-2-binary-grayscale-emboss","date":"2016-12-30T07:20:45.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ruby-basic-image-processing-algorithm-2-binary-grayscale-emboss.html","link":"","permalink":"https://baiyuan.wang/ruby-basic-image-processing-algorithm-2-binary-grayscale-emboss.html","excerpt":"","text":"一、灰度算法彩色照片每一个像素的颜色值由红、绿、蓝三种值混合而成，红绿蓝的取值分别由很多种，于是像素的颜色值也可以有很多种颜色值，这就是彩色图片的原理，而灰度照片则只有256种颜色，一般的处理方法是将图片颜色值的RGB三个通道值设为一样，这样图片的显示效果就会是灰色。 灰度处理一般有三种算法： 1 最大值法：即新的颜色值R＝G＝B＝Max(R，G，B)，这种方法处理后的图片看起来亮度值偏高。 2 平均值法：即新的颜色值R＝G＝B＝(R＋G＋B)／3，这样处理的图片十分柔和 3 加权平均值法：即新的颜色值R＝G＝B＝(R ＊ Wr＋G＊Wg＋B＊Wb)，一般由于人眼对不同颜色的敏感度不一样，所以三种颜色值的权重不一样，一般来说绿色最高，红色其次，蓝色最低，最合理的取值分别为Wr ＝ 30％，Wg ＝ 59％，Wb ＝ 11％ 下面是加权平均值法的Ruby实现： #灰度化图片 #取RGB三色平均值 def self.grey(bmp) for i in 0 .. bmp.height - 1 for j in 0 .. bmp.width - 1 rgb &#x3D; bmp.getRGB(i, j) grey &#x3D; rgb.r.to_f * 0.3+rgb.g.to_f *0.59 +rgb.b.to_f * 0.11.to_i bmp.setRGB(i, j, RGB.new(grey, grey, grey)) end end end 灰度效果： out_grey.jpg 二、二值化图像二值化就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。所有灰度大于或等于阈值的像素被判定为属于特定物体，其灰度值为255表示，否则这些像素点被排除在物体区域以外，灰度值为0，表示背景或者例外的物体区域。 图像二值化常常用于破解验证码等图片识别应用上 #二值化图片 #小于一定阈值设为0 0 0，大于设置为255 255 255 def self.binarization(bmp) imageGreyLevel &#x3D; bmp.getGreyLevel for i in 0 .. bmp.height - 1 for j in 0 .. bmp.width - 1 rgb &#x3D; bmp.getRGB(i, j) if rgb.getGreyLevel&lt;imageGreyLevel bmp.setRGB(i, j, RGB.new(0, 0, 0)) else bmp.setRGB(i, j, RGB.new(255, 255, 255)) end end end end 二值化效果 out_binary.jpg 三、底片底片效果的实现很简单，就是将RGB的每一个通道值取反，就是用255去减 #底片化图片 #RGB取反色255- def self.contraryColor(bmp) for i in 0 .. bmp.height - 1 for j in 0 .. bmp.width - 1 rgb &#x3D; bmp.getRGB(i, j) bmp.setRGB(i, j, rgb.getContrary) end end end 底片效果 out_contrary.jpg 四、浮雕效果浮雕的算法相对复杂一些，用当前点的RGB值减去相邻点的RGB值并加上128作为新的RGB值。由于图片中相邻点的颜色值是比较接近的，因此这样的算法处理之后，只有颜色的边沿区域，也就是相邻颜色差异较大的部分的结果才会比较明显，而其他平滑区域则值都接近128左右，也就是灰色，这样 就具有了浮雕效果。 在实际的效果中，这样处理后，有些区域可能还是会有”彩色”的一些点或者条状痕迹，所以最好再对新的RGB值做一个灰度处理。 #浮雕效果 #浮雕的算法相对复杂一些，用当前点的RGB值减去相邻点的RGB值并加上128作为新的RGB值。由于图片中相邻点的颜色值是比较接近的， #因此这样的算法 处理之后，只有颜色的边沿区域，也就是相邻颜色差异较大的部分的结果才会比较明显，而其他平滑区域则值都接近128左右， #也就是灰色，这样就具有了浮雕效果。 #在实际的效果中，这样处理后，有些区域可能还是会有”彩色”的一些点或者条状痕迹，所以最好再对新的RGB值做一个灰度处理。 def self.emboss(bmp) preRGB=RGB.new(128, 128, 128) for i in 0 .. bmp.height - 1 for j in 0 .. bmp.width - 1 currentRGB=bmp.getRGB(i, j) r=(currentRGB.r-preRGB.r)*1+128 g=(currentRGB.g - preRGB.g)*1+128 b=(currentRGB.b-preRGB.b)*1+128 bmp.setRGB(i, j, RGB.new(r,g,b).getGreyRGB) preRGB = currentRGB end end end 浮雕效果 out_emboss.jpg 项目主页geekeren&#x2F;RubyImageProcess","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"https://baiyuan.wang/tags/ruby/"}]},{"title":"Ruby解析bmp文件及图片处理算法（一）","slug":"ruby-parser-bmp-file-image-processing-algorithm-on","date":"2016-12-30T06:37:26.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ruby-parser-bmp-file-image-processing-algorithm-on.html","link":"","permalink":"https://baiyuan.wang/ruby-parser-bmp-file-image-processing-algorithm-on.html","excerpt":"","text":"一、BMP文件格式详解（BMP file format）BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式 下面以Notepad++为分析工具，结合Windows的位图数据结构对BMP文件格式进行一个深度的剖析。 BMP文件的数据按照从文件头开始的先后顺序分为四个部分： bmp文件头(bmp file header)：提供文件的格式、大小等信息 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息 调色板(color palette)： 可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表 Ø 位图数据(bitmap data)：就是图像数据啦^_^ 下面结合Windows结构体的定义，通过一个表来分析这四个部分。 BMP文件数据结构 我们一般见到的图像以24位图像为主，即R、G、B三种颜色各用8个bit来表示，这样的图像我们称为真彩色，这种情况下是不需要调色板的，也就是所位图信息头后面紧跟的就是位图数据了。因此，我们常常见到有这样一种说法：位图文件从文件头开始偏移54个字节就是位图数据了，这其实说的是24或32位图的情况。这也就解释了我们按照这种程序写出来的程序为什么对某些位图文件没用了。 BMP文件头数据结构 Paste_Image.png 位图信息头数据结构 位图信息头数据结构 位图数据每个像素占一个字节，取得这个字节后，以该字节为索引查询相应的颜色，并显示到相应的显示设备上就可以了。 注意：由于位图信息头中的图像高度是正数，所以位图数据在文件中的排列顺序是从左下角到右上角，以行为主序排列的。 也即我们见到的第一个像素60是图像最左下角的数据，第二个人像素60为图像最后一行第二列的数据，…一直到最后一行的最后一列数据，后面紧接的是倒数第二行的第一列的数据，依此类推。 如果图像是24位或是32位数据的位图的话，位图数据区就不是索引而是实际的像素值了。下面说明一下，此时位图数据区的每个像素的RGB颜色阵列排布： 24位RGB按照BGR的顺序来存储每个像素的各颜色通道的值，一个像素的所有颜色分量值都存完后才存下一个下一个像素，不进行交织存储。 32位数据按照BGRA的顺序存储，其余与24位位图的方式一样。 像素的排布规则与前述一致。 对齐规则 讲完了像素的排列规则以及各像素的颜色分量的排列规则，最后我们谈谈数据的对齐规则。我们知道Windows默认的扫描的最小单位是4字节，如果数据对齐满足这个值的话对于数据的获取速度等都是有很大的增益的。因此，BMP图像顺应了这个要求，要求每行的数据的长度必须是4的倍数，如果不够需要进行比特填充（以0填充），这样可以达到按行的快速存取。这时，位图数据区的大小就未必是 图片宽×每像素字节数×图片高 能表示的了，因为每行可能还需要进行比特填充。 填充后的每行的字节数为： ，其中BPP（Bits Per Pixel）为每像素的比特数。 在程序中，我们可以表示为： int iLineByteCnt &#x3D; (((m_iImageWidth * m_iBitsPerPixel) + 31) &gt;&gt; 5) &lt;&lt; 2;** 这样，位图数据区的大小为： **m_iImageDataSize &#x3D; iLineByteCnt * m_iImageHeight;** 我们在扫描完一行数据后，也可能接下来的数据并不是下一行的数据，可能需要跳过一段填充数据： **skip &#x3D; 4 - ((m_iImageWidth * m_iBitsPerPixel)&gt;&gt;3) &amp; 3; 二、Ruby实现BMP图片的解析根据上面的BMP图片格式的介绍，我可以写出以下Ruby代码。 @file = File.open(file, &quot;rb+&quot;) @bitMapFileHeader = @file.read(14).unpack(&#39;a2LS2L&#39;) @type=@bitMapFileHeader\\[0\\] #文件类型，BM：BMP图片 if @type!=&quot;BM&quot; puts &quot;不是BMP图片&quot; exit end @size=@bitMapFileHeader\\[1\\] #文件大小 @offBits=@bitMapFileHeader\\[4\\] #图像数据的偏移字节 @bitMapInfoHeader = @file.read(40).unpack(&#39;L3S2L6&#39;) @infoSize=@bitMapInfoHeader\\[0\\] #图片信息字段大小 @width=@bitMapInfoHeader\\[1\\] #图片宽度 @height=@bitMapInfoHeader\\[2\\] #图片高度 @planes=@bitMapInfoHeader\\[3\\] #平面数 @bitCountPerPixel=@bitMapInfoHeader\\[4\\] #图片位数 @compression=@bitMapInfoHeader\\[5\\] @imageDataSize=@bitMapInfoHeader\\[6\\] #图片数据段大小 @xPelsPerMeter=@bitMapInfoHeader\\[7\\] @yPelsPerMeter=@bitMapInfoHeader\\[8\\] @ClrUsed=@bitMapInfoHeader\\[9\\] @ClrImportant=@bitMapInfoHeader\\[10\\] @skipByteALine = 4 - ((@width * @bitCountPerPixel)&gt;&gt;3) &amp; 3 if @bitCountPerPixel == 24 iLineByteCnt = (((@width * @bitCountPerPixel) + 31) &gt;&gt; 5) &lt;&lt; 2 @file.seek @offBits @imageDataArray= @file.read(@imageDataSize).unpack(&quot;C*&quot;) end file对象中的read(length)是从文件指针开始读出length个字节的数据，数据类型是字符串，通过unpack函数，我们可以通过传入unpack参数解析出bmp图片的数据结构。 以@file.read(14).unpack(&#39;a2LS2L&#39;)为例，根据上面的BMP文件数据结构的分析，read(14)是读出bmp文件的前14个字节的文件头，参数’a2LS2L’可以将14个字节的数据解析为 两个字符（1*2字节）、一个Long型（1*8字节）、两个Short型（2*2字节），分别取出bmp图片的文件类型（“BM”）、文件大小、两个保留字段、 图像数据偏移量（@imageDataSize） 。 Paste_Image.png 再从文件中读入@imageDataSize个字节的数据，解析为字符数组，里面除了一些因对齐规则以外的数据都是图片的数据； @imageDataArray&#x3D; @file.read(@imageDataSize).unpack(“C*”) 如果是24位BMP图片，那么每个像素占据三个字节，分别为RGB中的B、G、R值。 以一个height&#x3D;2，width&#x3D;2的图片为例，其图片数据部分转成单字节数组如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 124 254 258 123 212 21 221 56 107 204 251 100 52 100 111 59 其中每一行的无效数据：skipByteALine &#x3D; 4 - ((2 * 24)&gt;&gt;3) &amp; 3&#x3D;2 为了更形象地表示图片像素与RGB数据的对应关系，在此我以二维矩阵的方式展示上面的一维数组： Paste_Image.png 由于对齐原则，第一行的7 、8，第二行的15、16元素将被丢弃。 基于以上考虑，可以通过以下Ruby代码获取指定像素位置的RGB值 #图片（i，j）位置的RGB,二维坐标到一维坐标的映射，同时考虑到一个像素的位数以及skip量def getRGB(i, j) linearIndex &#x3D; (@width*i+j)*(@bitCountPerPixel&gt;&gt;3)+i*@skipByteALineRGB.new(@imageDataArray[linearIndex+2], @imageDataArray[linearIndex+1], @imageDataArray[linearIndex])end 通过以下Ruby代码设置指定像素位置的RGB值 def setRGB(i, j, rgb) linearIndex &#x3D; (@width*i+j)*(@bitCountPerPixel&gt;&gt;3)+i*@skipByteALine @imageDataArray[linearIndex+2] &#x3D; rgb.r@imageDataArray[linearIndex+1] &#x3D; rgb.g@imageDataArray[linearIndex] &#x3D; rgb.bend 三、Ruby处理图片通过上面介绍的setRGB和getRGB方法来修改bmp的图片数据字节数组，我们就可以对bmp的指定像素进行操作了，下面介绍将图片灰度化： #灰度化图片，取RGB三色平均值 #灰度化图片 #取RGB三色平均值 def self.grey(bmp) for i in 0 .. bmp.height - 1 for j in 0 .. bmp.width - 1 rgb &#x3D; bmp.getRGB(i, j) grey &#x3D; rgb.getGreyLevel bmp.setRGB(i, j, RGB.new(grey, grey, grey)) end end end 上面的代码我取得所有像素的RGB，然后求出R、G、B值的平均值，RGB值三值相同时像素呈现为灰色 上面的操作只会修改图像数据字节数组，修改完毕需要保存到磁盘，保存方法如下： def save(file)@saveFile &#x3D; File.open(file, “wb”)@saveFile.write(@bitMapFileHeader.pack(‘a2LS2L’))@saveFile.write(@bitMapInfoHeader.pack(‘L3S2L6’))@saveFile.write(@imageDataArray.pack(‘C*’))@file.close @saveFile.closeend 原图： raw.jpg 处理效果： out_grey.jpg 下篇文章我将介绍二值化、浮雕滤镜、底片滤镜等图像处理算法 预览： Paste_Image.png 项目主页geekeren&#x2F;RubyImageProcess 参考文章http://blog.csdn.net/hzqnju/article/details/5927825 http://www.jianshu.com/p/30fbaab6d0a6 http://blog.csdn.net/hxker/article/details/50013303 http://blog.csdn.net/o_sun_o&#x2F;article&#x2F;details&#x2F;8351037","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"https://baiyuan.wang/tags/ruby/"}]},{"title":"用Ruby简书爬虫统计用户文章信息","slug":"in-ruby-jane-books-crawler-statistics-users-post-information","date":"2016-12-16T04:59:15.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"in-ruby-jane-books-crawler-statistics-users-post-information.html","link":"","permalink":"https://baiyuan.wang/in-ruby-jane-books-crawler-statistics-users-post-information.html","excerpt":"","text":"思沃大讲堂培训，要求我们把自己学习的心得感悟输出在简书上，公司还会统计大家的文章，包括文章数量、评论量、被喜欢量等等。这么多人，人工统计起来自然很麻烦，当然程序员会把这么艰巨光荣繁琐的工作交给代码，于是他们就写了一个爬虫。适值极客人正在学习Ruby，所以就突发奇想写了一个Ruby爬虫统计简书用户的文章，带动自己的Ruby学习。 如果让我抓取一个网站的内容，我的第一想法可能会是抓取它的HTML，不过也会反过来问自己一句这个网站有没有Rss订阅源地址，RSS的订阅源的内容是xml，相比html更加简洁和高效，而且由于xml的结构稳定一点（html可能那天换一个css可能就会导致我的爬虫用不了啦），解析起来会更加方便一点。在考察完简书没有提供RSS后，我就决定选择html来暴力地抓取简书了。 分析简书网址 首页：**http://www.jianshu.com/** 用户主页：**http://www.jianshu.com/users/用户ID（暂估计这么说）** 我们可以获取用户的关注、粉丝、文章、字数、收获喜欢等信息 Paste_Image.png 用户最新文章**http://www.jianshu.com/users/用户ID（暂估计这么说）/latest_articles** 我们可以获取用户文章列表，以此统计用户文章的评论量、阅读量等等，通过遍历文章列表将评论量、阅读量相加即可获取评论总量、阅读总量 需要指出的是，由于文章列表页不能把用户的文章全部列出来，而是列出10条，用户在浏览器中滚动到文章列表底部会自动加载，是用js向后台请求数据然后在前端多次拼接出来，所以想一次性地抓一次就把用户的评论总量、阅读总量是不行的，用户列表页分页的。所以我采取分页抓取的方式，那么怎么知道用户文章一共有多少页呢？我们从用户主页中获取了用户的文章总数，所以除以10加1可以获取页数 用户列表页分页的，10条&#x2F;页，其中第 m 页URL： http://www.jianshu.com/users/用户ID（暂估计这么说）/latest_articles?page&#x3D;m Paste_Image.png 抓取网页，获取htmlRuby提供的HTTP访问方法十分简洁高效，当然方法不止一种，对其他方法感兴趣的同学我自行Google，在此我贴出自己的代码： h &#x3D; Net::HTTP.new(“www.jianshu.com“, 80)resp &#x3D; h.get “&#x2F;users&#x2F;#{authorInfo.id}&#x2F;latest_articles”latest_articles_html &#x3D; resp.body.to_s 顾问生义，我想不需要解释代码的意思了吧 根据上面介绍的简书网址规则，就可以通过上述代码抓取到相应网页的HTML 分析抓取内容的结构获取完相应网页的HTML内容后要做的就是分析HTML的内容和结构。我们用眼睛很容易看出网页上的内容，但是爬虫看到的只有html源代码。下面我从抓取的HTML中提取了下列有用的代码： 用于提取用户的关注量、粉丝量、文章数、字数、收获喜欢数 38关注 22粉丝 9文章 9938字数 41收获喜欢 用于提取用户文章评论总量、阅读总量 极客人 · 4天之前 Hello,Ruby! 阅读 23 · 评论 4 · 喜欢 1 &lt;/div&gt; &lt;/div&gt; 极客人 · 9天之前 Html5语义化标签的启示 阅读 182 · 评论 1 · 喜欢 10 &lt;/div&gt; &lt;/div&gt; ..... 极客人 · 18天之前 网站自动跳转到Cjb.Net的惊险之旅 阅读 21 · 评论 3 · 喜欢 3 &lt;/div&gt; &lt;/div&gt; 正则匹配， 抠出关键信息上面我已经提取出有用的关键的HTML，现在要做的是让爬虫做同样的事情。所以我用到啦正则匹配。 正则匹配出粉丝”, “关注”, “文章”, “字数”, “收获喜欢” #从html中加载基本用户信息def loadAuthorBaseInfoFromHtml(authorInfo, latest_articles_html)infoKeys&#x3D;[“粉丝”, “关注”, “文章”, “字数”, “收获喜欢”]infoValues &#x3D; Array.new(infoKeys.length) if &#x2F;&lt;ul class&#x3D;\\“clearfix\\“&gt;([\\s\\S]?)&lt;\\&#x2F;ul&gt;&#x2F; &#x3D;~ latest_articles_html then authorInfoHtml&#x3D; $1.force_encoding(“UTF-8”) for i in 0 .. infoKeys.length-1 if &#x2F;#{“([0-9])#{infoKeys[i]}“.force_encoding(“UTF-8”)}&#x2F;&#x3D;~ authorInfoHtmlinfoValues[i]&#x3D; $1 end end endauthorInfo.setBaseInfo(infoValues[0], infoValues[1], infoValues[2], infoValues[3], infoValues[4])end 其他匹配代码请参看源代码 整合信息，多样化地输出成果物当统计出用户的文章信息后，就是把统计信息输出来。为了让输出的产物更加丰富和自定义程度更高，所以我采取了渲染模板的方式，将数据和界面分离。 模板文件： @{title} 统计时间：@{time} 序号 姓名 文章数 字数 阅读量 收到评论 收到喜欢 小buddy姓名 @{content} @{footer} 然后在Ruby代码中加载模板文件，并将@{title}、@{time}、 @{content}、 @{content}替换真实的统计信息 def out2Html(title) tplFile &#x3D; open @tpl tplContent &#x3D; tplFile.read tplFile.close content &#x3D;”” for i in 0 .. @authorList.length-1 author &#x3D; @authorList[i] content+&#x3D;format(“ %s &lt;a target&#x3D; \\“_blank\\“ href&#x3D;\\“http://jianshu.com/users/%s\\\\&quot;&gt;%s %s %s %s %s %s %s “, i, author.id, author.name, author.post_count, author.word_count, author.read_count, author.comment_count, author.liked_count, author.buddy) end today = Time.new; timeStr= today.strftime(&quot;(%Y-%m-%d %H:%M:%S)&quot;); footer=&quot;Powered By &lt;a target=\\\\&quot;_blank\\\\&quot; href=\\\\&quot;http://baiyuan.wang\\\\&quot;&gt;BrainWang@ThoughtWorks&lt;/a&gt;&quot; out = tplContent.gsub(/@\\\\&#123;title\\\\&#125;/, title) out = out.gsub(/@\\\\&#123;content\\\\&#125;/, content) out = out.gsub(/@\\\\&#123;footer\\\\&#125;/, footer) out = out.gsub(/@\\\\&#123;time\\\\&#125;/, timeStr) timeStr= today.strftime(&quot;(%Y-%m-%d)&quot;); file=open(&quot;output/#&#123;title+timeStr&#125;.html&quot;,&quot;w&quot;) file.write out print &quot;\\\\n输出文件位于&quot;, Pathname.new(File.dirname(\\_\\_FILE\\_\\_)).realpath,&quot;/&quot;,file.path file.close end 当然，那天只要加一个out2json就可轻松做一个API，实现更高的定制化效果啦 项目主页https://github.com/geekeren/jianshu_spider 使用方法 下载项目代码并运行 git clone &#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;:geekeren&#x2F;jianshu_spider.git cd jianshu_spider&#x2F; ruby main.rb 更详细的项目介绍请移步Github项目主页","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"Html5，你为什么要语义化标签？","slug":"html-5-you-why-want-semantic-tags","date":"2016-12-07T16:05:29.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"html-5-you-why-want-semantic-tags.html","link":"","permalink":"https://baiyuan.wang/html-5-you-why-want-semantic-tags.html","excerpt":"","text":"语义化标签，顾名思义也就是可以直接读懂的标签。最早接触HTML5的时候，对HTML5的语义化并没有太深的理解，只是对Html几个新增的功能很感兴趣，比如画布；Html5的语义化标签，header，footer，nav等，这些本质上就是Div，在html4时代，我们用div id&#x3D;”header”,”footer”，也能漂亮地完成header、footer这些标签相同的效果，html5为什么要多此一举把这些div单独分离出来作为新的标签呢？ 专注内容与结构在HTML5之前，DIV+CSS实际上就能很好渲染出一个web页面。HTML5已不仅仅满足于怎样将一个网页表现出来了，而是更加专注网页的结构，更加务实地关注网页的内容。 我们用div来表示页面元素，但是这些div都没有实际意义。为了区分不同的结构，我们往往给这些div设置不同id，ID名称标记了这个Div负责的区块。而HTML5则为这些不同的区块创造不同的标签。 我们浏览过成千上万的网页，或看新闻，或听音乐，或看视频，最终你发现其实发现千万个网页实际上有着大同小异的结构：导航条、标题、内容、底部，几乎“万变不离其宗”，html5干脆使用不同的语义化的标签来各司其职地代表网页的不同部分。当使用了这些语义化的标签后，可以帮助你更好地理解网页的框架。 即使在没有CSS的情况下，HTML页面也能呈现出很好地内容结构、代码结构。 我们来回顾几个HTML5几个语义化标签： 1):article标签:装载显示一个独立的文章内容。 例如一篇完整的论坛帖子，一则网站新闻，一篇博客文章等等，一个用户评论等等 artilce可以嵌套，则内层的artilce对外层的article标签有隶属的关系。 例如，一个博客文章，可以用article显示，然后一 些评论可以以article的形式嵌入其中。 2):section 标签:定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 3):aside 标签: 用来装载非正文类的内容。例如广告，成组的链接，侧边栏等等。 4):hgroup 标签:用于对网页或区段的标题元素（h1-h6）进行组合。 例如，在一个区段中你有连续的h系列的标签元素，则可以用hgroup将他们括起来。 &lt;hgroup&gt;&lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;/hgroup&gt; 5):header 标签:定义文档的页面组合，通常是一些引导和导航信息。 6):footer 标签:定义 section 或 document 的页脚。 在典型情况下，该元素会包含创作者的姓名、文档的创作日期以及&#x2F;或者联系信息。 实例: &lt;footer&gt; © 2012 Baidu 使用百度前必读 京ICP证030173号 &lt;/footer&gt; 7):nav 标签:导航链接放在nav标签里。 nav标签里应该放入一些当前页面的主要导航链接。 例如在页脚显示一个站点的导航链接（如首页，服务信息页面，版权信息页面等等），就可以使用nav标签，当然，这不是必须的。 8):time 标签:定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。 该元素能够以机器可读的方式对日期和时间进行编码,搜索引擎也能够生成更智能的搜索结果 9):mark 标签:定义带有记号的文本。请在需要突出显示文本时使用 标签。 10):figure标签:规定独立的流内容（图像、图表、照片、代码等等）。 figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 11):figcaption 标签:定义 figure 元素的标题（caption）。 语义化标签的默认CSS语义化标签不是html5的“专利”，比如html5之前的h1、h2等等就是语义化标签，他们表示几级标题；虽然我们在html没有引入任何css时，我们仍然可以看到h标签有字体放大加粗的效果。 实际上，html本身是没有表现的，我们看到例如 h1标签是粗体，字体大小2em，加粗；strong是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。 浏览器默认的CSS 模块化，便于团队开发和维护不同的语义化标签实际上为我们将网页划分了不同的模块，结构分明更利于分解模块，利于团队的合作和维护。或者当你自己审查元素的时候，当你看到“header”是自然知道这应该是网页的头部，你进入这个标签可能还会发现一个nav标签，你会很快联想到这是个导航条。你可以迅速顾名思义让自己或他人知道网页的结构，而不是看见一堆div让自己头大。 不同标签，其内容可能有不同的关注度一个网页有不同的部分，但是不一定每一部分都是你感兴趣的，比如当你看到我写的这边文章时，你可能更加关注我的文章内容，可能不那么关注我叫什么名字，不会关注我有多少个粉丝。更夸张一点，当你看到一段精彩的电影时，不会关注旁边弹出的膏药一样的广告，相反广告只会让你恼怒。不同的语义化标签，实际上分割了不同的内容。 语义化标签更加标准化，让机器更懂HTML读到上面的时候，你可能会说，用户看网页的时候，一般不会像那些程序员哥哥那样强迫症般地查看源代码来看看用了那些语义化标签（程序员哥哥。。。不好意思，好像说的是我自己），谁知道不同的模块，用了哪个语义化标签。对于人来说，不管你是语义化标签还是div，看到的都是活生生的、渲染好的网页啊！ 其实，语义化标签，或许并不是给人看的（没有骂程序猿GG的意思），可能还是机器看的。 讲个例子，极客人在使用wordpress时装过一个为文章生成目录的插件。这个插件的原理就是遍历文章提取内容中的h标签，然后生成目录。实际上就是通过识别语义化标签的方式提取内容。 再讲一个类似的但是不是通过识别语义化标签的例子， 见过别人用过一些爬虫插件，就是把别人家网站的博客内容抓下来然后发布到自己的博客上，原理是需要在后台输出要抓取网页的网址，然后过滤网页内容中div的class属性来把文章的导航链接（往往是目录链接）、内容页分离出来。比如有的网站的文章目录使用div class&#x3D;”nav”的css样式，内容使用div class&#x3D;”content”的css，我们可以正则匹配一下nav、content把需要的信息过滤出来。但是不是所有的网站都是使用这种class名称，有的网站也许用div class&#x3D;”post”来表示文章内容。也就是说class&#x3D;”nav”,class&#x3D;”content”，不是一个标准化的名称。然后nav,article语义标签则为我们可以提供了一个标准化。如果我们很严格按照html5语义标签的使用规则来设计自己的网页，将很利于爬虫“看懂”我们的网页。 内容权重差异化，给SEO会带来变革吗前面讲到，语义化标签更利于机器看懂我们写的html，同时不同的内容有着不同的关注度。个人绝对这对SEO可以带来一定的变革的。 当我们使用搜索引擎时，很恼火地搜到和搜索词完全不相干的内容。仔细一看才发现自己的搜索词实际上仅仅出现在一个网站的广告词。如果我们可以通过语义化标签，将网页的重点：比如文章的内容，放在一个article，不太重点的广告词、文章推荐列表放在aside里，就可以成功分化不同内容的权重。实际上搜索引擎可以给某些语义化标签更高一点的权重，从而提高搜索精准度。 当然，这是个人对搜索引擎的期待。若如此，这势必可以给SEO带来变革。 有许多个人观点希望大家交流斧正！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"Emmet优雅地搭建起Html骨架","slug":"emmet-elegantly-set-up-html-skeleton","date":"2016-12-05T03:44:58.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"emmet-elegantly-set-up-html-skeleton.html","link":"","permalink":"https://baiyuan.wang/emmet-elegantly-set-up-html-skeleton.html","excerpt":"","text":"曾经看见一位学长在PHP-Storm上输入一段奇怪的代码，当他按下了Tab键后，神奇的事情就发生了。 如果HTML也是一种编程语言的话，私以为Html会是我们接触到的最多的编程语言。可能有人并不知道什么是HTML（超文本标记语言），但是当他人生中第一次上网打开浏览器浏览网页的时候，他与HTML的邂逅就开始了……只是当初，他不知道纷繁绚丽的网页的背后，是HTML语言在默默支撑； HTML+JS+CSS是前端的三大语言。如果把网页比作人的话，HTML给了人以骨架，CSS未知赋予了血肉、发肤以至衣物、妆饰，而JS则给了他运动的灵魂。 这边文章从HTML讲起，对于HTML的基本知识在此就不便赘述了，Google一下，你就知道。在此，我主要讲的是怎样快捷地搭建起HTML的骨架。 把HTML比作骨架并非我心血来潮，我只是在告诉自己写HTML页面要有搭框架的意识。不瞒你说，我以前的HTML的代码都是拼凑而成的。哪里不对改哪里，效率很低。正向箭头 + 标签名+反响箭头这种重复的代码，写多了就觉得腻了。那么有没有什么快捷的方式让我们关注HTML的架构本身，而不是繁杂的html语言本身呢？ 用Emmet Tab一下 Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML&#x2F;CSS代码编写的速度 Emmet 的语法极客人目前还只是刚刚入门，这里主要是抛砖引玉一下，给大家几个例子，更专业的介绍与教程，给大家推荐下面文章：http://www.iteye.com/news/27580 ，在此我也就不大篇幅地复制粘贴了。 ** 输入“!”或“html:5”，然后按Tab键： ** * ** 连续输入元素名称和ID，比如输入p.foo： ** 还有一些较复杂的用法大家自行研究，在此不做赘述，因为我的作用就是抛砖引玉，勾起大家的兴趣。 ** 要见证奇迹的话建议自己亲手试一下！！** 一个例子：实现列表我要实现的效果如下： 按照搭建骨架的意识，我们得弄清这个列表的结构是什么样子： ** 最外层一个无序列表，这个无序列表每个列表项都嵌套一个有序列表，这个有序列表有两个列表项，每个列表项含有个无序列表 ** Emmet语法如下：ul&gt;((li&gt;ol&gt;(li&gt;ul&gt;li*2)*2)*2) Tab一下： 然后把文字填进去 Javascript 第一章 const let 第二章 function object Java 第一章 class package 第二章 private public 效果预览 Javascript 第一章 const let 第二章 function object Java 第一章 class package 第二章 private public 参考文章： * http://www.iteye.com/news/27580 * http://www.powerxing.com/emmet-syntax-cheatsheet/","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法语言","slug":"技术/算法语言","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/"},{"name":"软件开发","slug":"技术/算法语言/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://baiyuan.wang/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"Ubuntu初见","slug":"ubuntu-first","date":"2016-12-03T02:19:07.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ubuntu-first.html","link":"","permalink":"https://baiyuan.wang/ubuntu-first.html","excerpt":"","text":"一、UI大一的时候就喜欢装各种系统玩，所以在公司要求体验Ubuntu系统前就尝过鲜。对于一个初级用户来说，对一个操作系统最初的接触便是它的UI，我对Ubuntu系统的第一感觉是比较好看的Linux系统，它和Mac系统有点像，但是没有Mac好看。对于习惯了windows的操作系统的用户来说，我还是比较喜欢Windows7和Windows10的UI。不知道是系统本身的原因还是ubuntu对PC显卡支持的不太好的缘故，总有一种Ubuntu的界面渲染不够细腻的感觉。 不论怎样，Ubuntu在接触到的linux系统中是比较美观的一个，可视化操作的支持也是比较好的。如果你还抱怨Ubuntu不及windows漂亮的话，可以尝试在centos上安装一个KDE或者GNOME的桌面环境，就会发现Ubuntu是一个多么美观的Linux系统啦。 二、Linux的发行版对Ubuntu的定义，最基本的就是Linux的发行版啦。以前总听说发行版这个词，却从来不知道发行版到底是个什么意思。于是查了一下资料在此和大家分享一下。 就Linux的本质来说，它只是操作系统的核心，负责控制硬件、管理文件系统、程序进程等，并不给用户提供各种工具和应用软件。所谓工欲善其事，被必先利其器，一套在优秀的操作系统核心，若没有强大的应用软件可以使用，如C&#x2F;C++编译器、C&#x2F;C++库、系统管理工具、网络工具、办公软件、多媒体软件、绘图软件等，也无法发挥它强大的功能，用户也无法仅仅使用这个系统核心进行工作，因此人们以Linux核心为中心，再集成搭配各种各样的系统管理软件或应用工具软件组成一套完整的操作系统，如此的组合便称为Linux发行版。 个人感觉，Linux和Ubuntu的关系与Android和MIUI的关系有一点像。不过Ubuntu在定制方面做的应该更多一点。纯净的Linux系统内核编译出来网上说只有几M大小，最小的Linux系统ttylinux 是一个只需要8M磁盘空间的小型发行版，最低要求是12M 内存。 三、推荐几个良心的GUI应用wpswps office LInux版，强大的文字、表格、PPT办公软件。现在Android和Windows平台上的WPS office广告越来越多，而Linux上的却相当纯净。 下载地址：http://community.wps.cn/download/ 网易云音乐发布不久后我就安装了，和Windows下桌面版和UWP版长得一模一样，支持在线和本地音乐播放，桌面歌词。 下载地址：http://music.163.com/#/download Wine QQLinux下的QQ客户端，基本功能有的，但是感觉Bug比较多，因为和windows上2012年版的QQ差不多，现在好久没有更新了。 * 下载地址：http://www.ubuntukylin.com/applications/showimg.php?lang=cn&amp;id=23 四、分享几个小技巧多桌面和热区下载Unity Tweak Tool，和Mac一样支持将鼠标移到屏幕的边缘显示桌面、窗口平铺、任务切换等。这个在同时打开很多窗口的情况下十分方便用户操作。 调出命令行窗口快捷键Ctrl + Alt + T 更多使用技巧欢迎大家分享交流！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://baiyuan.wang/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://baiyuan.wang/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"我的博客","slug":"my-blog","date":"2016-11-18T11:46:41.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"my-blog.html","link":"","permalink":"https://baiyuan.wang/my-blog.html","excerpt":"","text":"一个偶然的机会，帮一个网站做了一个月左右的论坛版主和SEO优化。当基本了解网站的运营与优化后，我就想着是不是自己可以单独做个网站。在多次寻觅免费网站空间和域名后，经历空间从德国到美国，再从香港到日本的迁徙，最后确认了博客这个网站模式。网站的建站系统是wordpress，主题的部分代码经过本人修改。 博客有两个大的分类：文墨与IT技术。爱因斯坦曾经说过；“没有宗教的科学是跛子,没有科学的宗教是瞎子”。设立这两个大门类的初衷是，文化气息与科技涵养对于一个人同样重要。我认为：技术立身，文墨怡情。当有“闲情逸致”在QQ空间里发表一些意义较少甚至无聊的说说，何不写一写有真知灼见的文章呢。从高考后，大学里很少有心情写周记了，我觉得这是很可惜的一件事，我很怀念高中那段写周记的时光，每每读及情之深处，倍感温馨充实，甚至有莫名的一种暖流涌上心头。 对于学习IT的人来说，我觉得写博客是一件很有意义的事情，它可以对学习中遇到的问题进行总结，同时可以提升自己组织语言的能力。还有一点，通过对网页代码进行修改，会有一种学以致用的快感。 愿意把把我的博客副标题“博学广问，自律静思”拿出来与诸君分享，同时也再次表达本博客的主旨：记录生活，镌刻心路；泼洒文墨，分享技术!","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[]},{"title":"网站自动跳转到cjb.net的惊险之旅","slug":"automatically-jump-breathtaking-journey-of-cjbnet-website","date":"2016-11-07T15:40:10.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"automatically-jump-breathtaking-journey-of-cjbnet-website.html","link":"","permalink":"https://baiyuan.wang/automatically-jump-breathtaking-journey-of-cjbnet-website.html","excerpt":"","text":"极客人昨天在访问王柏元的博客时发现，网站时不时地“抽风”地跳转向www.cjb.net这个网址，几乎刚一打开baiyuan.wang就跳，访问其它的网址都没有遇到这等怪事。这种情况最开始只出现在360极速浏览器上，即使我下意识地清除缓存、cookie，依然没有奏效。最后我换了其它的浏览器，才发现就360极速浏览器才遇到这种情况，而且还是偶然出现的；在尝试网上的方法卸载浏览器插件等的方法解决未果的情况下我只得作罢。兴许360极速浏览器中毒了吧，呵呵，360还号称安全呢！ 今天晚上，我发现自动跳转到cjb.net的恼火现象再次出现，而且这次不管什么浏览器都是如此，包括Edge、IE。这才让我觉得是不是网站被“入侵”了，而且”入侵“的方式很明显，植入了含有跳转代码的js。因为当我审查元素”禁用js“时跳转情况就不会出现。然后我看了看，王柏元的博客一个文章页就引用30个js，只要其中一个js文件植入了恶意跳转代码就会出现自动跳转，如此盲目地找谈何容易。 由于网址跳转得极为迅速，我相信这个js文件是在html的head 部分，最后发现我的头部引用一个新浪CDN的jquery.min.js，网址为： http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js；这是我的wordpress主题提供的一个Jquery CDN源，当我把Jquery源由 CDN改成使用本地Jquery时，问题解决了，无疑是新浪的Jquery源被劫持了。打开这个js一看，难怪了： 而且lib.sinaapp.com域名下不管什么链接都是这个内容；最后发现网上推荐的Jquery CDN中，使用新浪的CDN还不少，估计这回中招的人应该不止我一个啊。最后我果断换成了百度的Jquery CDN：http://libs.baidu.com/jquery/1.9.1/jquery.min.js；当然，出现自动跳转到cjb.net的情况不一定和我是同一个原因，但是你可以按照我这个思路去找哪个js文件被污染了。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"解决htacess RewriteRule中含有？的问题","slug":"htacess-rewriterule-contain-problem-of-draw","date":"2016-11-07T14:23:46.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"htacess-rewriterule-contain-problem-of-draw.html","link":"","permalink":"https://baiyuan.wang/htacess-rewriterule-contain-problem-of-draw.html","excerpt":"","text":"最近分别用PHP和java写个一个IP寻找地理位置的在线API，由于想让自己的URL看起来更加漂亮，便使用了htaccess Rewrite语法对URL进行了重写，其中出现无法匹配“？”的情况，最后解决了，在此给大家分享一下： 我想实现的效果是把 api.php?format&#x3D;js&amp;ip&#x3D;10.22.56.0 重写为 api.js?ip&#x3D;10.22.56.0 api.php?format&#x3D;json&amp;ip&#x3D;10.22.56.0 重写为 api.json?ip&#x3D;10.22.56.0 于是很容易写了下面规则： RewriteRule api\\.(txt|html|json|js)\\?(.*)$ api.php?format&#x3D;$1&amp;$2 [L] 然后始终无法实现相关效果，初步原因是rewrite不能把带问号的QUERY_STRING进行匹配，最后使用下面的规则成功了： RewriteRule api\\.(txt|html|json|js)(.*)$ api.php?format&#x3D;$1&amp;%{QUERY_STRING} [L] %{变量名}可以获取请求的参数","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"Android监听底部导航栏展开与隐藏","slug":"android-monitor-navigation-bar-at-bottom-of-expansion-hidden","date":"2016-08-12T13:49:12.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-monitor-navigation-bar-at-bottom-of-expansion-hidden.html","link":"","permalink":"https://baiyuan.wang/android-monitor-navigation-bar-at-bottom-of-expansion-hidden.html","excerpt":"","text":"现在有些android手机具有底部虚拟按键的导航栏，这一设计去掉了物理按键，进一步增加了智能手机的屏占比。但这有时带来一些兼容性问题。 为了防止导航栏遮住布局，可以在布局上面添加“fitSystemWindows&#x3D;true”属性。 如果要想监听导航栏的隐藏与显示，我们可以在布局文件的根节点下添加一个宽度和高度都“match_parent”的空布局，同时在布局上面添加“fitSystemWindows&#x3D;true”属性，然后监听此布局的onLayoutChange事件，即可监听导航栏。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"Gradle下利用配置文件对构建工具版本集中控制","slug":"gradle-using-configuration-files-build-tools-version-under-centralized-control","date":"2016-08-12T02:17:00.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"gradle-using-configuration-files-build-tools-version-under-centralized-control.html","link":"","permalink":"https://baiyuan.wang/gradle-using-configuration-files-build-tools-version-under-centralized-control.html","excerpt":"","text":"由于Android studio和Android相关SDK和构建工具具有极快的更新速度。对相关版本的修改有时候是一件比较敏感的事情，尤其是在团队项目中，个人在本地修改了相关工具的版本并且不小心提交到远程代码库，别人更新下来往往出现各种问题。Android studio项目文件中版本字段十分分散，当SDK环境出现改变时，修改起来还是比较麻烦的。本文章利用配置文件对构建工具版本集中控制。 在项目根目录下gradle.properties文件定义版本信息并赋值GradleBuildVersion&#x3D;2.1.2AndroidMinSDKVersion&#x3D;16AndroidTargetVersion&#x3D;23AndroidCompileSDKVersion&#x3D;23AndroidBuildToolsVersion&#x3D;23.0.1 在使用版本信息的地方引用gradle变量Dependenciesdependencies { compile fileTree(include: [‘*.jar’], dir: ‘libs’) testCompile ‘junit:junit:4.12’ compile ‘com.android.support:appcompat-v7:’+project.AndroidBuildToolsVersion} build.gradle(project)buildscript { repositories { jcenter() } dependencies { classpath ‘com.android.tools.build:gradle:’+project.GradleBuildVersion &#x2F;&#x2F; NOTE: Do not place your application dependencies here; they belong &#x2F;&#x2F; in the individual module build.gradle files }} build.gradle(module)Android { compileSdkVersion Integer.parseInt(project.AndroidCompileSDKVersion) buildToolsVersion project.AndroidBuildToolsVersion defaultConfig &#123; applicationId &quot;cn.wangbaiyuan.plugintest&quot; minSdkVersion Integer.parseInt(project.AndroidMinSDKVersion) targetSdkVersion Integer.parseInt(project.AndroidTargetVersion) versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &#125; &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"歪脖子树与花痴","slug":"crooked-neck-tree-with-hc","date":"2016-06-24T03:34:53.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"crooked-neck-tree-with-hc.html","link":"","permalink":"https://baiyuan.wang/crooked-neck-tree-with-hc.html","excerpt":"","text":"我们家的“歪脖子”小时候，我家门前有一棵歪脖子大梧桐。梧桐很大，打我出生时就在那，打小就是歪脖子。那时我小，我问爸爸：“这个好丑啊，种在家门口一点都不好看，砍掉吧。”，爸爸笑着说：“傻孩子，这棵树用处可大着咧！这棵树有感情，须得一颗真心待她。”我不懂，人怎么和树有感情。 后来在夏夜里，妈妈给我讲起歪脖子大梧桐的”光荣事迹“： 我们家建在临近水库的陡坡上。与水库的相接的坡十分陡峭，近乎垂直，坡离我家房屋不远。 歪脖子大梧桐本来不歪脖子的，身体匀称，枝繁叶茂。后来一年夏天，黄梅县起了一场大风，并伴随大雨。大风吹倒了公路旁的108颗行道树，连根拔起，七倒八歪地横在路旁。许多人家的房屋都被掀起砸中路上的车和人，还有人家主屋外面的厨房被倒下的大树砸中，生生被敲掉了一个边角。妈妈说，那是她出生以来见过的最大的一场大风雨了。 ”那咱家呢？咱家怎么样了？“ ”咱家的房瓦也掀起了不少，这还不是主要的。因为我们家靠近陡坡，那天雨很大，大雨冲刷着陡坡。雨水裹挟着上面不经风雨的小花小草，冲垮了一层又一层黄沙。眼看就要垮到了我们家房子……“ ”啊…“我听着妈妈的话简直吓呆了，眼里几乎泛起泪来。 ”后来，陡坡知道跨到了那颗梧桐树下。梧桐大半的根系尽漏，清清楚楚地可以看见它们在地底下的纵深绵延，粗壮的根系在冲刷下露出了一道道沟壑……”，妈妈的记忆仿佛又回到那场大风雨中，“最后，另一侧的根仍旧死死抓住土地，而在梧桐的后面，再也没有沙石被冲垮掉；可是大梧桐在那场风暴中被吹歪向水库那侧，半边的大树干被吹断”。 “所以，梧桐被吹断了一半，就变成歪脖子了？”，我的心里对大歪脖子梧桐油然而生一种敬意。从此，小学的作文里，《我们家的‘歪脖子’》被我炒了一次又一次剩饭。 自从听完妈妈的故事，我再也不说砍掉歪脖子大梧桐的话了。而且我还会偷偷拿些家里装修完剩下的石灰，涂在歪脖子被吹掉半边树干留下的“伤口”上，防止虫儿咬，鸟儿做窝。我明白爸爸所说的一颗”真心“待树的奥义了。 歪脖子树，陪我度过温馨的童年，曾记得无数个夏夜，我偎依在妈妈怀里，妈妈坐在小木凳子上，听爸爸给我讲故事背唐诗，我们仨就在枝繁叶茂的大梧桐下乘凉，看黑幕下星星眨眼，看月过梧桐的如同冰霜，看萤火虫漫天飞舞的微微荧光。我就这样沉睡入温柔的梦乡中，梦里，我们仨，还有一棵”歪脖子“。 “花痴”爸爸喜欢捣弄些果树种在家后面，比如无花果，石榴、李子树啊，偶尔会间杂一些花草。布局匀整，花木多二不杂；后来只要有人到我家，都会看看我家的”后花果园“，多是称赞溢美之词。也有人会说：”老王啊，种些花多好看，家旁边种果树多俗，你家又不靠卖果子挣钱；还是多种花好看“。 种花是情趣，种果是实用。养花是修身养性的很好的方式，处一方繁华簇锦之所，赏花色、闻花香，享受在心里——一个理想主义的好去处；而在无趣之人的眼里，自然是果树实在，摸在手里，吃在肚里，真真切切。 无一例外的是，凡是参观我家”后花果园的“人都会注意到”鹤“立在花团中的歪脖子树：“老王啊，你们养的花也好，种的果也好，就是这颗大树不好。歪向一边，还掉叶子，不好看，也麻烦，砍掉算了，可以腾出一大块地方养花”。 爸爸总是笑笑说：“这棵树，防风固沙，对我家房子有救命之恩，丑点有什么关系，关键有感情”。我知道，爸爸是以待人之真心待树。 不然人家怎么说，爸爸还是没有砍树，这一直到高中。只是，果树都被砍掉，换成了花草，最后我们家的邻里也都种起了花草。几家之间”争芳斗艳“，乐此不疲。 生活总需要点点花草装束，热爱生活，就应该懂得生活的情趣。 后来我上了初中，读了高中，再也没有在作文里无休止地炒”我家的‘歪脖子树’“的剩饭，歪脖子看惯了，也就觉得没什么大不了的。 直到高二的一次周五回家，刚进家，就闻见一股油锯汽油味，然后是一阵轰鸣声。我跑到后院，爸爸正在拿着油锯锯我们家的”歪脖子“，在油锯的震动下，梧桐叶哗哗划下，落了后院满地；旁边是两位叔伯，拿着绳索困住”歪脖子“的枝干，在下面用力地拉住绳索把大梧桐往水库那边拽，防止魁梧的大梧桐倒下的时候砸向房子。我有点发愣，很惋惜，很不解，但是在几位叔伯面前。我不能暴露作为高中生却像孩子一样的稚气。 油锯声轰鸣了半小时便停止了，梧桐的主干几欲伐断。爸爸和叔伯几个一起拉住绳子，叫我来帮忙，他们几个吆喝着，使劲力气将梧桐最后的交连的主干拉扯断。伴随着”吱吱“的撕裂声，歪脖子倒下了，枝叶打在水面上，如同呜咽，水库上残页铺面，还有滚下的鸟窝。 大歪脖子的生命就这样走向终结。 后面的事你肯定能想到，大歪脖子被大卸八块，被斧子劈开。主干卖给了木料厂，枝干成了灶里的可燃物。 我不解，我问爸爸，为什么要砍歪脖子，不是说了不砍它吗。 ”树大了，占地方，放在院子里也不好看“。 ”不好看有什么关系呢？不是防风固沙么“ ”现在不需要了“，原来由于我家房子临近水库，政府加固道路在坡上砌成一堵水泥和大理石浇筑而成的石墙。 我还想接着问：”不是有感情吗，不是房子的救命恩人么“，出于不让别人看出我”稚气“的心理，我不再追问。不过作为接受了科学教育的我，明明就知道，梧桐护房，只是它根系粗壮而已，也可以认为是生命的本能。 万物本无情，本自人多情。当初留你是真心，现在放弃你也是真心。当初为你辩护留你是真心话，现在下决心放弃你的诸多理由也是真心话，不是虚伪。 人和树，怎么可能有感情？傻瓜！ 爸爸在除掉梧桐空留的地方又种上了花，花的品种也换了一批又一批。他常常向别人打听什么季节应该种什么花，我们家种什么花最好看，许多他从来没见过的但自己觉得喜欢的花都给种上，可最后这些花还是被换掉。 最后，我不知道他养花是不是真的爱花，还是真的是”花痴“。 我想，养花无可厚非，砍掉大脖子树也无必伤心。只是花木而已，没必要上纲上线到”喜新厌旧“的层面上来。 直到多年以后，我发现自己也变成了那颗大歪脖子树。是啊，不论弃与留，都是真心。 缺月挂疏桐，漏断人初静。拣尽寒枝不肯栖，寂寞沙洲冷。 2016年6月24日上午 情节完全虚构，如有雷同，纯属你抄我","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"生活哲学","slug":"生活哲学","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"}]},{"title":"为什么要写作","slug":"why-do-you-want-write","date":"2016-06-23T13:43:13.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"why-do-you-want-write.html","link":"","permalink":"https://baiyuan.wang/why-do-you-want-write.html","excerpt":"","text":"初中高中的时候，我度过人生最苦痛的时候。所谓穷而后工，我喜欢上了写作，经历过一些事情，许多事看得更明白。一点新想法，一点对社会、政治、军事的思考，都喜欢诉诸笔底。生活的苦痛，自言自语地倾诉在周记本上，就是最好的疗养与调节。写周记是我高中时代最幸福的事情，也是最孤独的阶段，笔尖下的一撇一捺，是孤独行者心路的足迹。这条路上虽然只有你自己，但写作后的周记本，仿佛成为了解你全部的挚友。 初中的我语文很差，其实也不算差，只是语文在我的数理化面前相形太见绌。我很喜欢也很感谢初三的沈老师，她让我养成了写周记的习惯，经过一些事情“多愁善感”与无人理解的独语中，我喜欢上写作，那时的文字很多消极的语调，但是好在老师并没有给出所谓的“批评指正”，或许在我现在看来因为那些或许是每个人人生必经的负能量，让学生发泄一下是最好的引导解惑；相反，她还多次对我的所思、所痛表示赞赏与理解。写作，让我最后获得比同龄人更深沉的文字，也没让我走向消极与抑郁。 大学，尤其是今年，我想我又迎来人生思想涌动变化的高潮；关乎工作与时俱进的行业思维，关乎为人处世的世界观，关乎幸福的爱情婚姻观，都在发生变化。以前眼中自以为熟悉甚至视其为知己的人，一朝会变得完全不认识；对一个人的看法时而恨之极，时而爱之切。在思想的彷徨和爱与恨的交错间，曾经自认为稳重有沉淀的我再次在心中卷起狂风大浪。我认为，写作，能让我头脑更加清晰，心灵更加澄澈。头脑的混乱很容易让人对人对事发生误判，乃至对世界都充满恶意。做一个乐观积极的人，是那种经过锤炼依旧保持初心的乐观积极。初心决定前行的方向，锤炼让初心更强大。","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"Android webview广告过滤的实现","slug":"realization-of-android-webview-advertising-filtering","date":"2016-05-02T03:46:38.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"realization-of-android-webview-advertising-filtering.html","link":"","permalink":"https://baiyuan.wang/realization-of-android-webview-advertising-filtering.html","excerpt":"","text":"现在大部分的android平台的浏览器都具有广告过滤的功能，同时大部分网站都有广告。广告行业是个盈利巨大的产业，就我看来，现在绝大部分的互联网产品，一般有两种营利模式：免费有广告和会员无广告；他们大部分（包括网站和APP等）盈利来源就是广告。作为用户而言，对广告十分反感，但是互联网上的服务我们能免费享受与支撑这些服务得以延续与成长却得益于广告。 百度了一下，网上竟然没有Android浏览器屏蔽广告的代码实现，所以极客人只能自己动手了。网页上的广告一般是站长在网页植入一段js代码，要想屏蔽广告只需要将这些js屏蔽掉即可。 WebViewClient的几个回调函数要想对Webview实现一些高级操作，首先要学习WebViewClient的用法，这是Webview几个常用回调函数 1、public boolean shouldOverrideUrlLoading(WebView view, String url) ： 在点击请求的是链接是才会调用，重写此方法返回true表明点击网页里面的链接还是在当前的webview里跳转，不跳到浏览器那边。 2、**public void onReceivedSslError(WebView view, SslErrorHandler handler, android.net.http.SslError error)**： 重写此方法可以让webview处理https请求。 3、**public boolean shouldOverrideKeyEvent(WebView view, KeyEvent event)**：重写此方法才能够处理在浏览器中的按键事件。 4、 public void onLoadResource(WebView view, String url) ：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。 5、 public void onPageStarted(WebView view, String url, Bitmap favicon) ：在页面加载开始时调用。 6、public void onPageFinished(WebView view, String url) ：在页面加载结束时调用。 初看上面的回调函数，极客人发现了一个巨大的坑，拦截广告就是拦截加载广告的js，上面的onLoadResource似乎是很合适的函数，只要判断onLoadResource的参数url是否是加载广告js的即可，如果不是广告相关的url正常加载，如果是则不加载。但是在使用onLoadResource之后才发现根本不行。 这里引用WebViewClient另外一个回调函数：public WebResourceResponse shouldInterceptRequest(WebView view, String url) shouldInterceptRequest有两种重载。 public WebResourceResponse shouldInterceptRequest (WebView view, String url) 从API 11开始引入，API 21弃用 public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request) 从API 21开始引入 这里极客人暂且使用shouldInterceptRequest (WebView view, String url)完成对webview广告的拦截。 拦截广告资源URL在Webview加载资源时会回调shouldInterceptRequest函数，我们可以通过重写shouldInterceptRequest函数实现对webview的资源请求进行处理。进行处理后返回数据。如果主程序返回的数据为null，WebView会自行请求网络加载资源。这里有个坑：不是shouldInterceptRequest函数返回null就能屏蔽掉请求！正确的屏蔽请求的方式： @Override public WebResourceResponse shouldInterceptRequest(WebView view, String url) { url &#x3D; url.toLowerCase(); if (!ADFilterTool.hasAd(context, url)) { return super.shouldInterceptRequest(view, url);&#x2F;&#x2F;正常加载 }else{ return new WebResourceResponse(null,null,null);&#x2F;&#x2F;含有广告资源屏蔽请求 } } 下面是极客人写的屏蔽广告的**NoAdWebViewClient类： **只需使用webview.setWebViewClient(NoAdWebViewClient webclient)即可屏蔽指定webview的广告。 package cn.wangbaiyuan.webviewadblock; import android.content.Context;import android.util.Log;import android.webkit.WebResourceResponse;import android.webkit.WebView;import android.webkit.WebViewClient; &#x2F;** * Created by BrainWang on 05&#x2F;01&#x2F;2016. *&#x2F;public class NoAdWebViewClient extends WebViewClient { private String homeurl; private Context context; public NoAdWebViewClient(Context context,String homeurl) &#123; this.context = context; this.homeurl = homeurl; &#125; @Override public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; url = url.toLowerCase(); if(!url.contains(homeurl))&#123; if (!ADFilterTool.hasAd(context, url)) &#123; return super.shouldInterceptRequest(view, url); &#125;else&#123; return new WebResourceResponse(null,null,null); &#125; &#125;else&#123; return super.shouldInterceptRequest(view, url); &#125; &#125; } 判断URL是否含广告的ADFilterTool类：该类通过判断url是否包含在广告拦截库中 ADFilterTool.javapackage cn.wangbaiyuan.webviewadblock; import android.content.Context;import android.content.res.Resources;import android.util.Log; &#x2F;** * Created by BrainWang on 05&#x2F;01&#x2F;2016. *&#x2F;public class ADFilterTool { public static boolean hasAd(Context context, String url) { Resources res &#x3D; context.getResources(); String[] adUrls &#x3D; res.getStringArray(R.array.adBlockUrl); for (String adUrl : adUrls) { if (url.contains(adUrl)) { return true; } } return false; }} 广告url资源文件（广告拦截库可自行百度更新）：AdUrlString.xml所谓广告拦截库，实际上是请求广告资源的url合集，网络上有大量的广告拦截库，读者可以定期更新一下文件来实现对广告的高效过滤。本文屏蔽的方式比较粗暴，凡是含有广告资源的域名统统禁止。要想实现更精准的过滤，访友你可以使用通配符匹配url的方式进行拦截，现在PC端的浏览器正是这样做的。 ubmcmm.baidustatic.com cpro2.baidustatic.com cpro.baidustatic.com s.lianmeng.360.cn nsclick.baidu.com pos.baidu.com cbjs.baidu.com cpro.baidu.com images.sohu.com/cs/jsfile/js/c.js union.sogou.com/ sogou.com/ a.baidu.com c.baidu.com &lt;/string-array&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"一个简单的局域网UDP实时视频","slug":"local-area-network-lan-simple-udp-video-calls","date":"2016-04-12T08:50:02.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"local-area-network-lan-simple-udp-video-calls.html","link":"","permalink":"https://baiyuan.wang/local-area-network-lan-simple-udp-video-calls.html","excerpt":"","text":"之前一直有打算做一个局域网上基于UDP通信的视频通话软件，一直不知道视频流在网络上以怎样的形式传输，虽然知道几个视频流的编码格式，但是其实一直没有进行付诸实践； 最近在学习安卓手表开发时，在github上看到一个将手机的实时视频传输到手表的项目，发现一个似乎低级但是在局域网应该还是比较实用的局域网视频传输方法：直接将从摄像头获取的图像压缩以后进行发送。本项目GitHub主页：https://github.com/retravel/AndroidRealTimeVideo 获取摄像头实时图片、UDP发送图片private void initCanmera() { int cameras &#x3D; Camera.getNumberOfCameras(); Camera.CameraInfo info &#x3D; new Camera.CameraInfo(); for (int i &#x3D; 0; i &lt; cameras; i++) { Camera.getCameraInfo(i, info); if (info.facing &#x3D;&#x3D; Camera.CameraInfo.CAMERA_FACING_FRONT) { camera &#x3D; Camera.open(i); break; } } &#x2F;&#x2F;没有前置摄像头 if (camera &#x3D;&#x3D; null) camera &#x3D; Camera.open(); try { camera.setPreviewDisplay(surfaceHolder); camera.setPreviewCallback(this); } catch (Exception e) { camera.release();&#x2F;&#x2F;释放资源 camera &#x3D; null; } } @Override public void onPreviewFrame(byte\\[\\] data, Camera camera) &#123; Camera.Size previewSize = camera.getParameters().getPreviewSize(); int\\[\\] rgb = decodeYUV420SP(data, previewSize.width, previewSize.height); Bitmap bmp = Bitmap.createBitmap(rgb, previewSize.width, previewSize.height, Bitmap.Config.ARGB_8888); int smallWidth, smallHeight; int dimension = 200; if (previewSize.width &gt; previewSize.height) &#123; smallWidth = dimension; smallHeight = dimension * previewSize.height / previewSize.width; &#125; else &#123; smallHeight = dimension; smallWidth = dimension * previewSize.width / previewSize.height; &#125; Matrix matrix = new Matrix(); matrix.postRotate(mCameraOrientation); Bitmap bmpSmall = Bitmap.createScaledBitmap(bmp, smallWidth, smallHeight, false); Bitmap bmpSmallRotated = Bitmap.createBitmap(bmpSmall, 0, 0, smallWidth, smallHeight, matrix, false); ByteArrayOutputStream baos = new ByteArrayOutputStream(); bmpSmallRotated.compress(Bitmap.CompressFormat.WEBP, 80, baos); up.sendMsg(baos.toByteArray()); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; initCanmera(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; int currentCamera = Camera.CameraInfo.CAMERA\\_FACING\\_FRONT; Camera.Parameters parameters = camera.getParameters();//得到相机设置参数 Camera.Size size = camera.getParameters().getPreviewSize(); //获取预览大小 parameters.setPictureFormat(PixelFormat.JPEG);//设置图片格式 Camera.CameraInfo info = new Camera.CameraInfo(); camera.getCameraInfo(currentCamera, info); int rotation = this.getWindowManager().getDefaultDisplay().getRotation(); int degrees = 0; switch (rotation) &#123; case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; &#125; int resultA = 0, resultB = 0; if (currentCamera == Camera.CameraInfo.CAMERA\\_FACING\\_BACK) &#123; resultA = (info.orientation - degrees + 360) % 360; resultB = (info.orientation - degrees + 360) % 360; camera.setDisplayOrientation(resultA); &#125; else &#123; resultA = (360 + 360 - info.orientation - degrees) % 360; resultB = (info.orientation + degrees) % 360; camera.setDisplayOrientation(resultA); &#125; camera.setPreviewCallback(this); parameters.setRotation(resultB); mCameraOrientation = resultB; camera.setParameters(parameters); camera.startPreview();//开始预览 &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; if (camera != null) &#123; camera.setPreviewCallback(null); camera.stopPreview(); camera.release(); camera = null; &#125; &#125; UDP serverpackage cn.wangbaiyuan.androidsocketav; &#x2F;** * Created by BrainWang on 2016&#x2F;3&#x2F;21. *&#x2F; import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;import java.net.SocketAddress;import java.net.SocketException; &#x2F;** * 基于UDP协议的服务器端，对来自客户端的数据包进行应答 * * @author 王柏元 *&#x2F;public class UDPServer { &#x2F;** * 端口 *&#x2F; &#x2F;&#x2F;int port&#x3D;1888; DatagramSocket socket; String lastString &#x3D; (-1 + “”); int sameTime &#x3D; 0; public handleReceiveData callback; public UDPServer(int port) throws SocketException &#123; socket = new DatagramSocket(port); //服务端DatagramSocket System.out.println(&quot;服务器启动。&quot;); &#125; public void setReceiveCallback(handleReceiveData call) &#123; callback = call; &#125; public void service() throws IOException &#123; while (true) &#123; DatagramPacket dp = new DatagramPacket(new byte\\[102400\\], 102400); socket.receive(dp); //接收客户端信息 byte\\[\\] data = dp.getData(); callback.handleReceive(data); &#125; &#125; public void start() throws SocketException, IOException &#123; service(); &#125; public void sendMsg(final byte\\[\\] data) &#123; Thread send = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; if (socket != null) &#123; SocketAddress socketAddres = new InetSocketAddress(&quot;192.168.1.110&quot;, 8804); socket.send(new DatagramPacket(data, data.length, socketAddres)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); send.start(); &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"火车局域服务系统","slug":"train-local-service-system","date":"2016-03-19T15:58:45.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"train-local-service-system.html","link":"","permalink":"https://baiyuan.wang/train-local-service-system.html","excerpt":"","text":"长长的火车，长长的旅程，常常长达20多小时的火车行程，令我们疲惫不堪。我们发现，封闭的火车就像一个迷你的大千世界，我们想在火车上建立一个局域网相连的信息“生态系统”。传统的火车订餐，需要乘务员拉着餐车询问乘客，常常无功而返；火车进入隧道时，我们的手机讯号全无，仿佛与世隔绝；有时我们和同道人不在邻座，换座十分麻烦。。。我们可以做一个基于火车环境的局域网信息系统： 在火车每个车厢放一个路由器，将所有路由器进行桥接，建立一个局域网，搭建服务器，提供一下服务： 一、订餐；乘务人员定点送餐，送餐地点为乘客座位号 二、乘客沟通换座与聊天； 三、替代当前的乘务人员对讲机； 四、火车到站提醒； 五、火车到站推送当地风土人情，趁机植入广告； 六、资源共享，乘客访问火车服务器观看上面的电影、听音乐、收听电台等；","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"软件开发","slug":"极客视点/软件开发","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"奇思妙想","slug":"奇思妙想","permalink":"https://baiyuan.wang/tags/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"}]},{"title":"【语言-java】1、\"==\"和\"equal\"的区别","slug":"language-java-1-difference-between-equal","date":"2016-03-18T12:08:36.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"language-java-1-difference-between-equal.html","link":"","permalink":"https://baiyuan.wang/language-java-1-difference-between-equal.html","excerpt":"","text":"对于一些基本数据类型，int，long，bool，还有char!，“&#x3D;&#x3D;”都是表示值相等的意思，没有equal方法。 equal方法是object对象里面的方法，java中String不是基本数据类型，而是一个类，它们都是继承object类，还有Integer和int的区别也是Integer是一个类！ 在object类中，equal方法与“&#x3D;&#x3D;”是等同的，“&#x3D;&#x3D;”不是表示值相等，而是比较对象的地址是否相等！Integer和String都重写了（没错！就是重写，重载是写多个函数名相同但参数不同的函数；重写是对父类的方法重新定义，体现了多态性），equal方法经过String、Integer重写后，是比较值而非地址。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"应聘复习","slug":"应聘复习","permalink":"https://baiyuan.wang/tags/%E5%BA%94%E8%81%98%E5%A4%8D%E4%B9%A0/"}]},{"title":"百度地图API位置偏移的校准算法","slug":"baidu-map-api-position-offset-calibration-algorithm","date":"2016-02-17T04:17:28.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"baidu-map-api-position-offset-calibration-algorithm.html","link":"","permalink":"https://baiyuan.wang/baidu-map-api-position-offset-calibration-algorithm.html","excerpt":"","text":"在开始使用百度地图API进行开发时可能会遇到一件相当奇怪的事情，使用百度定位的经纬度在地图上显示相当不准确，这一问题我在微信开发和安卓开始时都遇到过。第一次使用百度地图api获取位置并在地图上显示是在微信开发的时候，那是不知道具体原因无奈在微信获取的地理位置上加了一个偏移量进行校准，虽能勉强解决，但是不太准确。后来在安卓开始也同样遇到了这个问题，才发现百度地图API定位偏移已经不是一个偶然问题了。 百度地图API定位偏移的原因以下来自互联网： 一、坐标体系首先我们要明白，开发者能接触到哪些坐标体系呢？ 第一种分类：1、 GPS，WGS-84，原始坐标体系。一般用国际标准的GPS记录仪记录下来的坐标，都是GPS的坐标。很可惜，在中国，任何一个地图产品都不允许使用GPS坐标，据说是为了保密。GPS坐标形式如图，度分秒形式的经纬度： 百度地图API位置偏移的校准算法1 百度地图API位置偏移的校准算法2 2、 GCJ-02，国测局02年发布的坐标体系。又称“火星坐标”。在中国，必须至少使用GCJ-02的坐标体系。比如谷歌，腾讯，高德都在用这个坐标体系。GCJ-02****也是国内最广泛使用的坐标体系。 3、 其他坐标体系。一般都是由GCJ-02进过偏移算法得到的。这种体系就根据每个公司的不同，坐标体系都不一样了。比如，百度和搜狗就使用自己的坐标体系，与其他坐标体系不兼容。 第二种分类：首先明白，所有坐标体系的原点，都是非洲。 百度地图API位置偏移的校准算法3 1、 经纬度。这个是球面坐标，对于北京来说，就是(116.38817139.935961)这样的坐标。比如腾讯、高德、百度都是这样的经纬度坐标。谷歌是经纬度顺序写反的经纬度坐标。 如果是度分秒坐标，需要进行转换，才能得到这样的经纬度坐标。详见坐标转换。 2、 墨卡托坐标。平面坐标，相当于是直线距离，数字一般都比较大，像这样的。(215362.00021333335 99526.00034912192) 墨卡托坐标，主要用于程序的后台计算。直线距离嘛，加加减减几乎计算方便。 搜狗地图API就是直接使用的墨卡托坐标。 二、坐标转换在各种web端平台，或者高德、腾讯、百度上取到的坐标，都不是GPS坐标，都是GCJ-02坐标，或者自己的偏移坐标系。 比如，你在谷歌地图API，高德地图API，腾讯地图API上取到的，都是GCJ-02坐标，他们三家都是通用的，也适用于大部分地图API产品，以及他们的地图产品。 例外，百度API上取到的，是BD-09坐标，只适用于百度地图相关产品。 例外，搜狗API上取到的，是搜狗坐标，只适用于搜狗地图相关产品。 例外，谷歌地球，google earth上取到的，是GPS坐标，而且是度分秒形式的经纬度坐标。在国内不允许使用。必须转换为GCJ-02坐标。 1、度分秒坐标转换为经纬度比如，在GPS记录仪，或者google earth上采集到的是39°31’20.51，那么应该这样换算，31分就是31&#x2F;60度，20.51秒就是20.51&#x2F;3600度，结果就是39 + 31&#x2F;60 + 20.51&#x2F;3600 度。 2、 GPS转换为GCJ-02坐标谷歌，高德，腾讯的地图API官网上，都不直接提供这样的坐标转换。如果要得到GCJ-02坐标，最好在他们的地图上直接取点，或者通过地址解析得到。（这个工具我后续会贴出来的。我就爱干这样的事情，哈哈。） 不过，在网上搜到了这样的接口，该接口的type&#x3D;1就是GPS转到GCJ-02的墨卡托坐标。请大家对接口保密，哈哈。详见： http://map.sogou.com/api/documentation/javascript/api2.5/interface\\_translate.html#late\\_intro 3、GCJ-02与BD-09之间互转国测局GCJ-02坐标体系（谷歌、高德、腾讯），与百度坐标BD-09体系的转换，在CSDN上有很详细的讲解： http://blog.csdn.net/coolypf/article/details/8569813 不过也有更简单的算法，线性算法（lat和lng是经纬度，球面坐标）： To_B是转到百度，To_G是转到GCJ-02。 var TO_BLNG &#x3D; function(lng){return lng+0.0065;}; var TO_BLAT &#x3D; function(lat){return lat+0.0060;}; var TO_GLNG &#x3D; function(lng){return lng-0.0065;}; var TO_GLAT &#x3D; function(lat){return lat-0.0060;}; 4、经纬纬度转成墨卡托网上也有详细讲解： http://bbs.esrichina-bj.cn/esri/viewthread.php?tid=78245 （大家发现没，高德是api，腾讯和百度是mapapi，说明什么？） 三、坐标偏移 如果您的坐标在转换之后，还有偏移，那么考虑以下几个方面。 A、原始坐标系弄错，比如以为自己是GPS坐标，但其实已经是GCJ-02坐标。 解决方案：请确保采集到的数据是哪个坐标体系，需要转换到哪个坐标系，再进行坐标转换。 B、原始坐标准确度不够 解决方案：如果您是GPS坐标，请确保采集GPS数据时，搜到至少4颗以上的卫星。并且GPS数据准不准，还取决于周围建筑物的高度，越高越不准，因为有遮挡。 如果本来就是GCJ-02坐标，在不同地图放大级别的时候，看到的地方可能不一样。比如你在地图级别4（国家）取到的坐标，放大到地图12级（街道）时，坐标就偏了。请确保在地图最大放大级别时，拾取坐标。 C、度分秒的概念混淆 比如，在google earth上采集到的是39°31’20.51，那么应该这样换算，31分就是31&#x2F;60度，20.51秒就是20.51&#x2F;3600度，结果就是39 + 31&#x2F;60 + 20.51&#x2F;3600 度。 D、经纬度顺序写反了 有些公司（比如高德，百度，腾讯）是先经度，再纬度，即Point(lng lat)。但谷歌坐标的顺序恰好相反，是(lat lng)。 相关问题的百度解释：http://developer.baidu.com/map/question.htm 百度地图API位置偏移的校准算法package cn.wangbaiyuan.translate.tools; &#x2F;** * 各地图API坐标系统比较与转换; * WGS84坐标系：即地球坐标系，国际上通用的坐标系。设备一般包含GPS芯片或者北斗芯片获取的经纬度为WGS84地理坐标系, * 谷歌地图采用的是WGS84地理坐标系（中国范围除外）; * GCJ02坐标系：即火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。 * 谷歌中国地图和搜搜中国地图采用的是GCJ02地理坐标系; BD09坐标系：即百度坐标系，GCJ02坐标系经加密后的坐标系; * 搜狗坐标系、图吧坐标系等，估计也是在GCJ02基础上加密而成的。 chenhua *&#x2F;public class PositionUtil { public static final String BAIDU\\_LBS\\_TYPE = &quot;bd09ll&quot;; public static double pi = 3.1415926535897932384626; public static double a = 6378245.0; public static double ee = 0.00669342162296594323; /\\*\\* \\* 84 to 火星坐标系 (GCJ-02) World Geodetic System ==&gt; Mars Geodetic System \\* \\* @param lat \\* @param lon \\* @return */ public static Gps gps84\\_To\\_Gcj02(double lat, double lon) &#123; if (outOfChina(lat, lon)) &#123; return null; &#125; double dLat = transformLat(lon - 105.0, lat - 35.0); double dLon = transformLon(lon - 105.0, lat - 35.0); double radLat = lat / 180.0 * pi; double magic = Math.sin(radLat); magic = 1 - ee * magic * magic; double sqrtMagic = Math.sqrt(magic); dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi); dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi); double mgLat = lat + dLat; double mgLon = lon + dLon; return new Gps(mgLat, mgLon); &#125; /\\*\\* \\* \\* 火星坐标系 (GCJ-02) to 84 * * @param lon * @param lat * @return \\* */ public static Gps gcj\\_To\\_Gps84(double lat, double lon) &#123; Gps gps = transform(lat, lon); double lontitude = lon * 2 - gps.getWgLon(); double latitude = lat * 2 - gps.getWgLat(); return new Gps(latitude, lontitude); &#125; /\\*\\* \\* 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 将 GCJ-02 坐标转换成 BD-09 坐标 \\* \\* @param gg_lat \\* @param gg_lon */ public static Gps gcj02\\_To\\_Bd09(double gg\\_lat, double gg\\_lon) &#123; double x = gg\\_lon, y = gg\\_lat; double z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi); double theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * pi); double bd_lon = z * Math.cos(theta) + 0.0065; double bd_lat = z * Math.sin(theta) + 0.006; return new Gps(bd\\_lat, bd\\_lon); &#125; /\\*\\* \\* \\* 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 * * 将 BD-09 坐标转换成GCJ-02 坐标 * * @param \\* bd\\_lat * @param bd\\_lon * @return */ public static Gps bd09\\_To\\_Gcj02(double bd\\_lat, double bd\\_lon) &#123; double x = bd\\_lon - 0.0065, y = bd\\_lat - 0.006; double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi); double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * pi); double gg_lon = z * Math.cos(theta); double gg_lat = z * Math.sin(theta); return new Gps(gg\\_lat, gg\\_lon); &#125; /\\*\\* \\* (BD-09)--&gt;84 \\* @param bd_lat \\* @param bd_lon \\* @return */ public static Gps bd09\\_To\\_Gps84(double bd\\_lat, double bd\\_lon) &#123; Gps gcj02 = PositionUtil.bd09\\_To\\_Gcj02(bd\\_lat, bd\\_lon); Gps map84 = PositionUtil.gcj\\_To\\_Gps84(gcj02.getWgLat(), gcj02.getWgLon()); return map84; &#125; public static boolean outOfChina(double lat, double lon) &#123; if (lon &lt; 72.004 || lon &gt; 137.8347) return true; if (lat &lt; 0.8293 || lat &gt; 55.8271) return true; return false; &#125; public static Gps transform(double lat, double lon) &#123; if (outOfChina(lat, lon)) &#123; return new Gps(lat, lon); &#125; double dLat = transformLat(lon - 105.0, lat - 35.0); double dLon = transformLon(lon - 105.0, lat - 35.0); double radLat = lat / 180.0 * pi; double magic = Math.sin(radLat); magic = 1 - ee * magic * magic; double sqrtMagic = Math.sqrt(magic); dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi); dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi); double mgLat = lat + dLat; double mgLon = lon + dLon; return new Gps(mgLat, mgLon); &#125; public static double transformLat(double x, double y) &#123; double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y \\+ 0.2 * Math.sqrt(Math.abs(x)); ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0; ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0; ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0; return ret; &#125; public static double transformLon(double x, double y) &#123; double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 \\* Math.sqrt(Math.abs(x)); ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0; ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0; ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0 \\* pi)) * 2.0 / 3.0; return ret; &#125; public static void main(String\\[\\] args) &#123; // 北斗芯片获取的经纬度为WGS84地理坐标 31.426896,119.496145 Gps gps = new Gps(31.426896, 119.496145); System.out.println(&quot;gps :&quot; + gps); Gps gcj = gps84\\_To\\_Gcj02(gps.getWgLat(), gps.getWgLon()); System.out.println(&quot;gcj :&quot; + gcj); Gps star = gcj\\_To\\_Gps84(gcj.getWgLat(), gcj.getWgLon()); System.out.println(&quot;star:&quot; + star); Gps bd = gcj02\\_To\\_Bd09(gcj.getWgLat(), gcj.getWgLon()); System.out.println(&quot;bd :&quot; + bd); Gps gcj2 = bd09\\_To\\_Gcj02(bd.getWgLat(), bd.getWgLon()); System.out.println(&quot;gcj :&quot; + gcj2); &#125; } C++算法#include const double x_pi &#x3D; 3.14159265358979324 * 3000.0 &#x2F; 180.0; void bd_encrypt(double gg_lat, double gg_lon, double &amp;bd_lat, double &amp;bd_lon){ double x &#x3D; gg_lon, y &#x3D; gg_lat; double z &#x3D; sqrt(x * x + y * y) + 0.00002 * sin(y * x_pi); double theta &#x3D; atan2(y, x) + 0.000003 * cos(x * x_pi); bd_lon &#x3D; z * cos(theta) + 0.0065; bd_lat &#x3D; z * sin(theta) + 0.006;} void bd_decrypt(double bd_lat, double bd_lon, double &amp;gg_lat, double &amp;gg_lon){ double x &#x3D; bd_lon - 0.0065, y &#x3D; bd_lat - 0.006; double z &#x3D; sqrt(x * x + y * y) - 0.00002 * sin(y * x_pi); double theta &#x3D; atan2(y, x) - 0.000003 * cos(x * x_pi); gg_lon &#x3D; z * cos(theta); gg_lat &#x3D; z * sin(theta);}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"微信","slug":"微信","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"}]},{"title":"webview显示富文本与JS和java的交互","slug":"webview-shows-rich-text-interact-with-js-java","date":"2016-01-15T05:56:51.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"webview-shows-rich-text-interact-with-js-java.html","link":"","permalink":"https://baiyuan.wang/webview-shows-rich-text-interact-with-js-java.html","excerpt":"","text":"WebView是安卓下显示网页的控件，使用它可以实现一个简单的浏览器，访问互联网上的网页。也可以当作一个本地的文本显示控件，和textView类似。用 WebView 或者 TextView 来显示 HTML 内容，其交互的实现方式有较大的区别，以在 HTML 内容中的图片点击事件为例，在 WebView 模式下，开发人员需要通过注入 JavaScript 代码来进行点击事件的响应，Android 系统提供了 WebView 中 JavaScript 网页脚本调用 Java 类方法的机制；而在 TextView 中，图片会被解析为 ImageSpan，通过在 ImageSpan 上注册点击事件来响应。 webview显示富文本 一、webview显示富文本比如iniHtml为一段String类型的html代码，使用 webView.loadDataWithBaseURL(null, iniHtml, “text&#x2F;html”, “utf-8”, null); 即可在webview上显示这段html。 二、webview显示项目资源中网页文件我们可以将一个html文件index.html放在项目的assets文件下，使用WebView.loadUrl(“file:&#x2F;&#x2F;&#x2F;android_asset&#x2F;index.html”)来显示这个html文件，在这个html文件如果要引用asserts文件夹下的css、js文件，同样使用file:&#x2F;&#x2F;&#x2F;android_asset&#x2F; ; 来访问。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0&quot;&gt; &lt;title&gt;王柏元的博客&lt;/title&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;file:///android_asset/style.css&quot;/&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;file:///android_asset/scripts/jquery.js&quot;&gt;&lt;/script&gt; 三、java中调用javascript函数使用loadurl调用java代码 webview.loadUrl(“javascript: window.backAction();”); 四、javascript怎样调用java函数在webview使用javascript调用外部的java函数可以让android的webview显示富文本有一种更加原生的体验，而不会让使用者感觉他在使用一个浏览器在查看你的显示文本。为了能让javascript调用java中代码，安卓采取将javascript的一个window下的对象M与java中的对象N做一个绑定或者说是映射，这样在javascript下对M的操作就相当于在java下N的操作。 实现方法：webview启用javascript，绑定js对象webview.getSettings().setJavaScriptEnabled(true);webview.addJavascriptInterface(javaobject,”JSInterface”); addJavascriptInterface(Object object, String name)函数中第一个参数object是java下的对象，name是映射到javascript下的对象名。你可以为java下的object比如当前的activity申明一个click()函数，在javascript下使用window.name.click() 即可出发java下click函数。 需要指出的是在java中的click函数需要添加声明 @JavascriptInterface","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"网页添加链接调用APP与跳转下载网址","slug":"page-add-links-call-app-jump-download-url","date":"2016-01-09T15:22:02.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"page-add-links-call-app-jump-download-url.html","link":"","permalink":"https://baiyuan.wang/page-add-links-call-app-jump-download-url.html","excerpt":"","text":"在京东、百度糯米等网站的手机端网页上，常常有有个悬浮提示“点击打开客户端”，如果用户在手机上安装了客户端，将会自动调用客户端打开与当前网页内容一致的客户端页面；如果用户没有安装这些APP，浏览器将会跳转到下载网址，让用户下载客户端。在王柏元的博客客户端中也实现了这一功能。 之前在《安卓实现打开指定链接调用其他应用程序》介绍了如果让客户端点击特定链接（APPLINK）时自动调用客户端软件，在此再次重复一遍： 在打开指定链接需要跳转到的Activity的AndroidManifest.xml清单文件中中加入一条intent-filter标签，并如下面的例子设置scheme、HOST等属性。 怎样链接到客户端指定页面通过 category android:name&#x3D;”android.intent.category.BROWSABLE” &#x2F;&gt; 这一Intent调用Activity不仅能在applink被点击时启动该APP，还支持类似HTTP的GET传值，这就是跳转到网页对应的客户端页面的前提。 比如：王柏元的博客客户端注册了android:scheme&#x3D;”wbyblog” android:host&#x3D;”baiyuan.wang” android:pathPrefix&#x3D;”&#x2F;post” 的Intent的postActivity，在浏览器打开链接：”wbyblog:&#x2F;&#x2F;baiyuan.wang&#x2F;post?postid&#x3D;1234**&amp;title&#x3D;网页添加链接调用APP与跳转下载网址 “时，将把postid:1234**和title:网页添加链接调用APP与跳转下载网址 传入postActivity；在postActivity中通过下列代码实现获取传入的值。 Intent intent&#x3D;getIntent(); String action &#x3D; intent.getAction(); if(Intent.ACTION_VIEW.equals(action)){ Uri uri &#x3D; intent.getData(); if(uri !&#x3D; null){ String title &#x3D; uri.getQueryParameter(“title”); postid&#x3D; uri.getQueryParameter(“postid”); &#125; 这样你就可以根据传值显示特定的app页面了 网页端实现已安装客户端则调用、无则下载在服务端我们需要动态生成当前网页对应的APPLINK，并通过一个悬浮固定的div显示applink，以便醒目吸引用户点击。比如极客人实现的在手机网页、文章页面，生成有该链接的div（电脑不予显示）： 博客app自动链接调用下载 ID; $posttitle=$post->post_title; echo '王柏元的博客客户端已发布 点击打开'; echo ' function isInstalled(){ var the_href=\"http://mobile.baidu.com/#/item?docid=8613180\";//获得下载链接 window.location=\"wbyblog://baiyuan.wang/post?postid='.$postid.'&title='.$posttitle.'\";//打开某手机上的某个app应用 setTimeout(function(){ window.location=the_href;//如果超时就跳转到app下载页 },1000); } $(\"#openapp\").click(function(){ isInstalled(); } ); '; } } add\\_action ( 'wp\\_footer', 'addOpenAPPlink' ); ?> 其中关键部分为下面的js代码： function isInstalled(){ var the_href=\"http://mobile.baidu.com/#/item?docid=8613180\";//获得下载链接 window.location=\"wbyblog://baiyuan.wang/post?postid='.$postid.'&title='.$posttitle.'\";//打开某手机上的某个app应用 setTimeout(function(){ window.location=the_href;//如果超时就跳转到app下载页 },1000); } $(\"#openapp\").click(function(){ isInstalled(); } ); js实现了让浏览器打开applink从而自动调用你的app(当然前提是你安装了)，并在1000m后跳转到app下载页面，其它并不能判断你的手机上是否安装了你的APP，但是展现的效果是一样的！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"博客客户端","slug":"博客客户端","permalink":"https://baiyuan.wang/tags/%E5%8D%9A%E5%AE%A2%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"AndroidStudio代码混淆和NDK预防apk反编译","slug":"confused-androidstudio-code-with-ndk-prevention-apk-decompiling","date":"2016-01-09T03:53:32.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"confused-androidstudio-code-with-ndk-prevention-apk-decompiling.html","link":"","permalink":"https://baiyuan.wang/confused-androidstudio-code-with-ndk-prevention-apk-decompiling.html","excerpt":"","text":"代码混淆什么是代码混淆Java 是一种跨平台的、解释型语言，Java 源代码编译成中间”字节码”存储于 class 文件中。由于跨平台的需要，Java 字节码中包括了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些符号带有许多语义信息，很容易被反编译成 Java 源代码。为了防止这种现象，我们可以使用 Java 混淆器对 Java 字节码进行混淆。 混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。 混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。由于以上介绍的缩短变量和函数名以及丢失部分信息的原因， 编译后 jar 文件体积大约能减少25% ，这对当前费用较贵的无线网络传输是有一定意义的。 1234567891011121314151617181920212223242526272829303132333435-optimizationpasses 5 # 指定代码的压缩级别-dontusemixedcaseclassnames # 是否使用大小写混合-dontpreverify # 混淆时是否做预校验-verbose # 混淆时是否记录日志-optimizations !code/simplification/arithmetic,!field/*,!class/merging/* # 混淆时所采用的算法-keep public class * extends android.app.Activity # 保持哪些类不被混淆-keep public class * extends android.app.Application # 保持哪些类不被混淆-keep public class * extends android.app.Service # 保持哪些类不被混淆-keep public class * extends android.content.BroadcastReceiver # 保持哪些类不被混淆-keep public class * extends android.content.ContentProvider # 保持哪些类不被混淆-keep public class * extends android.app.backup.BackupAgentHelper # 保持哪些类不被混淆-keep public class * extends android.preference.Preference # 保持哪些类不被混淆-keep public class com.android.vending.licensing.ILicensingService # 保持哪些类不被混淆-keepclasseswithmembernames class * &#123; # 保持 native 方法不被混淆 native &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; # 保持自定义控件类不被混淆 public &lt;init&gt;(android.content.Context, android.util.AttributeSet);&#125;-keepclasseswithmembers class * &#123;# 保持自定义控件类不被混淆 public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keepclassmembers class * extends android.app.Activity &#123; # 保持自定义控件类不被混淆 public void *(android.view.View);&#125;-keepclassmembers enum * &#123; # 保持枚举 enum 类不被混淆 public static **\\[\\] values(); public static ** valueOf(java.lang.String);&#125;-keep class * implements android.os.Parcelable &#123; # 保持 Parcelable 不被混淆 public static final android.os.Parcelable$Creator *;&#125; NDK将应用的核心代码或通讯协议打包成so文件NDK可以实现代码的保护，由于apk的java层代码很容易被反编译，而C&#x2F;C++库反汇难度较大。 因为java是半解释半编译性语言，，先将java的代码解释成CLASS文件，然后编译给计算机中的JVM虚拟机，然后由虚拟机调用相应的计算机部件进行运算，而安卓的SO文件是linux下的文件，用c或者c++写的，c++你可以看做是C的扩充版，C有良好的机器兼容性，就是因为它可以直接编译为机器指令，执行效率相对java高，而java是跨平台移可植性强大。 C&#x2F;C++更接近底层系统实现和依赖于编译器，不同编译器生成的二进制代码会相对不同平台有所区别，甚至同一操作系统不同系列的编译器都会有一点差异，比如在linux下编译C&#x2F;C++得到的二进制代码就很难或无法运行在windows平台上，反之亦然，所以反编译很困难，现在大多数反编译软件都只能反编译成汇编。有一些号称可以反编译成C或者C++的工具，但反编译出来的结果大多看不明白，还不如用汇编。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"汇编","slug":"汇编","permalink":"https://baiyuan.wang/tags/%E6%B1%87%E7%BC%96/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://baiyuan.wang/tags/Android-Studio/"}]},{"title":"第一个android studio+NDK程序","slug":"first-android-ndk-program","date":"2016-01-08T14:26:20.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"first-android-ndk-program.html","link":"","permalink":"https://baiyuan.wang/first-android-ndk-program.html","excerpt":"","text":"NDK(android native develop kits ):android 本地开发工具集 ,可以把c&#x2F;c++ -&gt;编译成一个 linux下可以执行的二进制文件 java代码里面就可以通过jni 调用执行二进制的文件。 什么是JNI ：java本地开发接口,JNI是一个协议这个协议用来沟通java代码和外部的本地代码(c&#x2F;c++).通过这个协议,java代码就可以调用外部的c&#x2F;c++，代码外部的c&#x2F;c++代码也可以调用java代码。 java可以实现上层应用的开发，但是不能写底层驱动，有些android项目必须和底层硬件打交道，比如要精确快速的获取某种传感器的值，那么java是不能办到的，那怎么办，就通过JNI开发，通过c&#x2F;c++完成底层驱动或者值得获取，然后将值传回到java层。同样java层也可以将数据传递给c&#x2F;c++层，这样通过JNI完成数据的交互。 android_studio_NDK 为何要用到NDK?概括来说主要分为以下几种情况： 1. 代码的保护，由于apk的java层代码很容易被反编译，而C&#x2F;C++库反汇难度较大。 2. 在NDK中调用第三方C&#x2F;C++库，因为大部分的开源库都是用C&#x2F;C++代码编写的。 3. 便于移植，用C&#x2F;C++写的库可以方便在其他的嵌入式平台上再次使用。 MainActivity:package cn.wangbaiyuan.ndktest; import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView; public class MainActivity extends AppCompatActivity { public native String getStringFromNative(); @Override protected void onCreate(Bundle savedInstanceState) &#123; System.loadLibrary(&quot;hello&quot;); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView hello&#x3D;(TextView)findViewById(R.id.hello); hello.setText(getStringFromNative()); } } 下面是通过javah命令自动生成的 cn_wangbaiyuan_ndktest_MainActivity.h&#x2F;* DO NOT EDIT THIS FILE - it is machine generated *&#x2F;#include &lt;jni.h&gt;&#x2F;* Header for class cn_wangbaiyuan_ndktest_MainActivity *&#x2F; #ifndef _Included_cn_wangbaiyuan_ndktest_MainActivity#define _Included_cn_wangbaiyuan_ndktest_MainActivity#ifdef __cplusplusextern “C” {#endif#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_ABOVE_CLIENT#define cn_wangbaiyuan_ndktest_MainActivity_BIND_ABOVE_CLIENT 8L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_ADJUST_WITH_ACTIVITY#define cn_wangbaiyuan_ndktest_MainActivity_BIND_ADJUST_WITH_ACTIVITY 128L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_ALLOW_OOM_MANAGEMENT#define cn_wangbaiyuan_ndktest_MainActivity_BIND_ALLOW_OOM_MANAGEMENT 16L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_AUTO_CREATE#define cn_wangbaiyuan_ndktest_MainActivity_BIND_AUTO_CREATE 1L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_DEBUG_UNBIND#define cn_wangbaiyuan_ndktest_MainActivity_BIND_DEBUG_UNBIND 2L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_IMPORTANT#define cn_wangbaiyuan_ndktest_MainActivity_BIND_IMPORTANT 64L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_NOT_FOREGROUND#define cn_wangbaiyuan_ndktest_MainActivity_BIND_NOT_FOREGROUND 4L#undef cn_wangbaiyuan_ndktest_MainActivity_BIND_WAIVE_PRIORITY#define cn_wangbaiyuan_ndktest_MainActivity_BIND_WAIVE_PRIORITY 32L#undef cn_wangbaiyuan_ndktest_MainActivity_CONTEXT_IGNORE_SECURITY#define cn_wangbaiyuan_ndktest_MainActivity_CONTEXT_IGNORE_SECURITY 2L#undef cn_wangbaiyuan_ndktest_MainActivity_CONTEXT_INCLUDE_CODE#define cn_wangbaiyuan_ndktest_MainActivity_CONTEXT_INCLUDE_CODE 1L#undef cn_wangbaiyuan_ndktest_MainActivity_CONTEXT_RESTRICTED#define cn_wangbaiyuan_ndktest_MainActivity_CONTEXT_RESTRICTED 4L#undef cn_wangbaiyuan_ndktest_MainActivity_MODE_APPEND#define cn_wangbaiyuan_ndktest_MainActivity_MODE_APPEND 32768L#undef cn_wangbaiyuan_ndktest_MainActivity_MODE_ENABLE_WRITE_AHEAD_LOGGING#define cn_wangbaiyuan_ndktest_MainActivity_MODE_ENABLE_WRITE_AHEAD_LOGGING 8L#undef cn_wangbaiyuan_ndktest_MainActivity_MODE_MULTI_PROCESS#define cn_wangbaiyuan_ndktest_MainActivity_MODE_MULTI_PROCESS 4L#undef cn_wangbaiyuan_ndktest_MainActivity_MODE_PRIVATE#define cn_wangbaiyuan_ndktest_MainActivity_MODE_PRIVATE 0L#undef cn_wangbaiyuan_ndktest_MainActivity_MODE_WORLD_READABLE#define cn_wangbaiyuan_ndktest_MainActivity_MODE_WORLD_READABLE 1L#undef cn_wangbaiyuan_ndktest_MainActivity_MODE_WORLD_WRITEABLE#define cn_wangbaiyuan_ndktest_MainActivity_MODE_WORLD_WRITEABLE 2L#undef cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_DIALER#define cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_DIALER 1L#undef cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_DISABLE#define cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_DISABLE 0L#undef cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_GLOBAL#define cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_GLOBAL 4L#undef cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_LOCAL#define cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_LOCAL 3L#undef cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_SHORTCUT#define cn_wangbaiyuan_ndktest_MainActivity_DEFAULT_KEYS_SHORTCUT 2L#undef cn_wangbaiyuan_ndktest_MainActivity_RESULT_CANCELED#define cn_wangbaiyuan_ndktest_MainActivity_RESULT_CANCELED 0L#undef cn_wangbaiyuan_ndktest_MainActivity_RESULT_FIRST_USER#define cn_wangbaiyuan_ndktest_MainActivity_RESULT_FIRST_USER 1L#undef cn_wangbaiyuan_ndktest_MainActivity_RESULT_OK#define cn_wangbaiyuan_ndktest_MainActivity_RESULT_OK -1L#undef cn_wangbaiyuan_ndktest_MainActivity_HONEYCOMB#define cn_wangbaiyuan_ndktest_MainActivity_HONEYCOMB 11L#undef cn_wangbaiyuan_ndktest_MainActivity_MSG_REALLY_STOPPED#define cn_wangbaiyuan_ndktest_MainActivity_MSG_REALLY_STOPPED 1L#undef cn_wangbaiyuan_ndktest_MainActivity_MSG_RESUME_PENDING#define cn_wangbaiyuan_ndktest_MainActivity_MSG_RESUME_PENDING 2L&#x2F;* * Class: cn_wangbaiyuan_ndktest_MainActivity * Method: getStringFromNative * Signature: ()Ljava&#x2F;lang&#x2F;String; *&#x2F;JNIEXPORT jstring JNICALL Java_cn_wangbaiyuan_ndktest_MainActivity_getStringFromNative (JNIEnv *, jobject); #ifdef __cplusplus}#endif#endif 在build.gradle（Module:App）加入下列配置可指定生成.so文件的CPU平台类型以及so文件的名称，如果没有指定，android将会生成libapp.so，以及所有平台的so文件；生成so文件路径为：你的项目根目录\\app\\build\\intermediates\\ndk\\debug\\lib build.gradle（Module:App）defaultConfig &#123; ndk &#123; moduleName &quot;hello&quot; ldLibs &quot;log&quot;, &quot;z&quot;, &quot;m&quot; abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot; &#125; ………… &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"}]},{"title":"百度云推送实现博客新文章提醒","slug":"baidu-cloud-push-new-blog-articles-remind","date":"2016-01-07T16:04:32.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"baidu-cloud-push-new-blog-articles-remind.html","link":"","permalink":"https://baiyuan.wang/baidu-cloud-push-new-blog-articles-remind.html","excerpt":"","text":"在开发王柏元的博客客户端时，为了加入新文章发布时实现客户端通知的效果，极客人采用了百度云推送平台，使用百度官方提供的SDK和demo成功实现。服务端发送通知时，客户端会执行onNotificationClicked 回调函数。该函数的形参分别为 Context context：上下文 String title：通知标题 String description：通知内容 String customContentString：自定义字段，通过json可获取服务端的传值。 安卓端 @Override public void onNotificationClicked(Context context, String title, String description, String customContentString) { Intent intent &#x3D; new Intent(); intent.setClass(context.getApplicationContext(), SinglePostActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); String postId&#x3D;””; try { JSONObject jso&#x3D;new JSONObject(customContentString); postId&#x3D;jso.getString(“postId”); } catch (JSONException e) { e.printStackTrace(); } intent.putExtra(SinglePostFragment.ARG_ITEM_ID,postId); intent.putExtra(SinglePostFragment.ARG_POST_TITLE, title);&#x2F;&#x2F; context.startActivity(intent); context.getApplicationContext().startActivity(intent); String notifyString = &quot;通知点击 title=\\\\&quot;&quot; + title + &quot;\\\\&quot; description=\\\\&quot;&quot; + description + &quot;\\\\&quot; customContent=&quot; + customContentString; Log.d(TAG, notifyString); &#125; 服务器端代码需要引入sdk.php，关键是服务器要支持cUrl模块。我的阿里云免费主机就不支持，后来我消息推送的代码放在景安的虚拟主机上，通过阿里云调用URL的方式执行在景安主机上的PHP文件，解决了这一问题。 PHP服务器端 function newBlogPushtoAPP($post_ID){ global $post;require_once ‘..&#x2F;sdk.php’; &#x2F;&#x2F; 创建SDK对象.$sdk &#x3D; new PushSDK(); &#x2F;&#x2F; message content.$message &#x3D; array ( &#x2F;&#x2F; 消息的标题. ‘title’ &#x3D;&gt; $post-&gt;post_title, &#x2F;&#x2F; 消息内容 ‘description’ &#x3D;&gt; $post-&gt;content, &#x2F;&#x2F;自定义字段。数组类型 “custom_content”&#x3D;&gt; array( “postId”&#x3D;&gt; $post-&gt;ID ) ); &#x2F;&#x2F; 设置消息类型为 通知类型.$opts &#x3D; array ( ‘msg_type’ &#x3D;&gt; 1); &#x2F;&#x2F; 向目标设备发送一条消息$rs &#x3D; $sdk -&gt; pushMsgToAll($message, $opts);}add_action ( ‘publish_post’, ‘newBlogPushtoAPP’, 1);","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"androd","slug":"androd","permalink":"https://baiyuan.wang/tags/androd/"}]},{"title":"安卓实现打开指定链接调用其他应用程序","slug":"android-open-specified-link-call-other-app","date":"2016-01-01T03:23:23.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"android-open-specified-link-call-other-app.html","link":"","permalink":"https://baiyuan.wang/android-open-specified-link-call-other-app.html","excerpt":"","text":"有些网站在网页上设置了点击跳转到其官方APP上的链接，比如京东；近期在做王柏元的博客客户端上我加入此功能，用以打开网页上的链接调用我的客户端打开相关文章。下面是实现方法： 安卓实现打开指定链接调用其他应用程序在打开指定链接需要跳转到的Activity的AndroidManifest.xml清单文件中中加入一条intent-filter标签，并如下面的例子设置scheme、HOST等属性。 并做了一个网页亲测成功：打开首页打开文章打开目录","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"博客客户端","slug":"博客客户端","permalink":"https://baiyuan.wang/tags/%E5%8D%9A%E5%AE%A2%E5%AE%A2%E6%88%B7%E7%AB%AF/"}]},{"title":"触类旁通学习swift（1）语言简述","slug":"learning-swift-one-instance-1-language-description","date":"2015-12-30T15:14:20.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"learning-swift-one-instance-1-language-description.html","link":"","permalink":"https://baiyuan.wang/learning-swift-one-instance-1-language-description.html","excerpt":"","text":"由于要参加一个iOS竞赛，所以极客人最近开始学习swift语言。swift语言是苹果2014年发布的一个开发苹果旗下软件的一种新的编程语言，貌似有取缔之前用来开发苹果软件的objective c语言的势头，所以个人觉得学习swift还是比较有前途的。由于开发iOS必须要MAC系统，之前花费了大量的时间给我的戴尔电脑安装了“黑苹果”，但因为驱动问题导致无法联网，十分影响学习。为此，十分感谢杨帆老师借了我一台闲置的MAC电脑。 swift语言 与之前学习过的c++，java，php，javascript语言相比，swift语言在我看来更加高端或者说“高级”，比java等语言比swift更加简洁，对一些诸如数组等数据类型的操作功能极为强大，写相同量大swift的代码可以做很多的事情。简洁、高级的swift可以节省程序员打字的工作量，但是也意味着这个语言可能的封装度更大。封装性让成员易于操作但会让程序员离底层越来越远，上层函数的记忆量就会加大。swift和其它高级语言的不同还是很大的，不像java和php相似度极大，只要学会java，php在短时间内即可无师自通。 学过几门计算机语言之后，我认为再学习一门新的语言时与之前语言的比较十分重要。所以在学习swift时很有必要把它和其他语言进行类比学习，以加强记忆，防止各种语言之间的“串味”。 swift面向什么？swift和php相似，既支持面向过程又支持面向对象，没必要把所有的操作都写成一个类和方法，而java则是严格的面向对象语言。但PHP是一种脚本语言，但是swift不是，脚本语言是解释执行的，执行文件是文本； 编译语言，执行文件是二进制，swift需要经过编译生成一个二进制的可执行文件。 swift不是弱类型swift和javascript一样没有显式地声明变量类型，但是在没有声明变量类型的swift会根据情况自动推断出变量类型。比如var a&#x3D;”hello world”,a会被推断为string类型。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"IOS","slug":"IOS","permalink":"https://baiyuan.wang/tags/IOS/"},{"name":"swift","slug":"swift","permalink":"https://baiyuan.wang/tags/swift/"}]},{"title":"支持自动提示的多引擎的搜索框","slug":"mul-engine-auto-prompt-search-box","date":"2015-12-30T04:01:08.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"mul-engine-auto-prompt-search-box.html","link":"","permalink":"https://baiyuan.wang/mul-engine-auto-prompt-search-box.html","excerpt":"","text":"使用网上开源的导航站源码制作了我的导航网页“百元导航”后，总觉得它丢掉了导航网站的一个很重要的东西—搜索框。于是极客人为自己的导航站加入了搜索框的功能，支持百度搜索、好搜、极客搜、CSDN搜索、蒲公英PT搜索等（可以加代码轻松扩展），除了网站界面使用了网上的代码，逻辑处理部分的js代码全由本人实现。 带搜索提示的搜索框百元导航网 html代码：下面是搜索框的界面的html部分： 百度 极客搜 谷歌 好搜 搜狗 CSS代码*{margin:0;padding:0}input,select{vertical-align:middle;font-size:9pt;font-family:微软雅黑}input,textarea{padding:0;word-wrap:break-word;word-break:break-all}li{list-style-type:none}img{border:0 none}a{color:#333;text-decoration:none}a:hover{color:#1974a1}a:link,a:visited{outline:0;color:#333;text-decoration:none}a:hover{color:#0e4470;text-decoration:none}.search{margin:40px auto 0;width:525px;height:35px;border:1px solid #f58400;background-color:hsla(0,0%,100%,.66);font-family:微软雅黑}.search select{position:relative;float:left;width:95px;height:35px;background:url(images&#x2F;search_ico.png) no-repeat 5pc center;color:#100909;text-indent:9px;font-weight:700;font-size:14px;line-height:35px}option{background:#efefef;font-size:1pc}.search input.btn_srh,.search input.inp_srh{float:left;height:35px;border:none;background:0 0;line-height:35px}.search input.inp_srh{margin-left:5px;width:365px;outline:0;font-size:15px}.search input.btn_srh{width:60px;background:#f58400;color:#fff;font-size:15px;font-family:”微软雅黑”} javascript代码要想搜索框支持多搜索引擎切换，首先需要掌握搜索引擎搜索关键词的URL参数，查看有几个GET参数（搜索引擎一般都是用GET传值的），比如下面是搜索引擎搜索“王柏元的博客”的结果页的URL： https://www.baidu.com/s?ie=UTF-8&amp;wd=%E7%8E%8B%E6%9F%8F%E5%85%83 ？ie后面是编码格式，wd后面是搜索的关键词的URLEncode编码。 所以只要做一个表单，在表单内部加入name&#x3D;”ie”的DOM元素，这个元素没有必要在界面上显示，可以在CSS样式中加入“display:none”，下面的addparams函数实现的就是这一功能；再加入name&#x3D;”wd”的文本框，就是输入关键词的那个搜索框。最后将表单的action设置为百度搜索关键词网址：https://www.baidu.com/s 下面的setEngine函数就是切换搜索引擎的函数。传入searchIndex，就是html中select下option的value； function addParams(name,value){ $(\"#params\").append(''); } function setSearchEngine(searchIndex){ var jk=\"http://so.baiyuan.wang/cse/search\"; var bd=\"https://www.baidu.com/s\"; var gg=\"https://www.google.com/search\"; var hs=\"https://www.haosou.com/s\"; var sg=\"https://www.sogou.com/sogou\"; var actions=\\[bd,jk,gg,hs,sg\\]; $.cookie(\"searchId\",searchIndex, {expires:30} ); var keywordflag=\\[\"wd\",\"q\",\"q\",\"q\",\"query\"\\]; $(\"#params\").empty(); $(\"#searchform\").attr(\"action\",actions\\[searchIndex\\]); $(\"#keyword\").attr(\"name\",keywordflag\\[searchIndex\\]); switch(searchIndex){ case \"0\": addParams(\"ie\",\"UTF-8\"); break; case \"1\": addParams(\"s\",\"12193527087847762795\"); addParams(\"nsid\",\"1\"); addParams(\"entry\",\"1\"); break; case \"2\": addParams(\"ie\",\"UTF-8\"); break; case \"3\": addParams(\"ie\",\"UTF-8\"); break; case \"4\": addParams(\"ie\",\"UTF-8\"); break; default: addParams(\"ie\",\"UTF-8\"); } } 为了在用户切换搜索引擎后，再次打开导航页默认显示切换后的搜索引擎，可采用cookie记录searchIndex。 var serachId=Number($.cookie(\"searchId\")); if(serachId !== null && serachId !== undefined) serachId=serachId; else serachId=0; $(\"#choose option\\[value='\"+serachId+\"'\\]\").attr(\"selected\", \"selected\"); setSearchEngine(serachId.toString()); $(\"#keyword\").focus(); 下面的代码用以在切换搜索引擎时，如果搜索框不为空则自动搜索搜索框内关键词，不用点击“搜索按钮”。 $(document).ready(function(){ $(\"#choose\").change(function(){ var sindex=$(\"#choose\").val(); setSearchEngine(sindex); function isNull( str ){ if ( str == \"\" ) return true; var regu = \"^\\[ \\]+$\"; var re = new RegExp(regu); return re.test(str); } var strings=$(\"#keyword\").val(); if (!isNull( strings )) { $(\"#submit\").click(); } }); $.ajaxSetup({ cache: true, scriptCharset:'GBK' }); }); 搜索框加入百度搜索自动提示其中搜索自动提示的功能采用了百度开放的百度搜索框提示：引入一个百度的opensug.js文件，然后在要绑定搜索提示的文本框input元素中加入baiduSug&#x3D;”1”。这样在绑定的搜索框中输入文字即可获得和百度一样的搜索提示。 比如： 网上说百度搜索提示还有很多高级用法，比如自定义搜索提示的背景颜色、字体等等。不过极客人试过发现并不支持，你可以自行尝试，成功了欢迎来王柏元的博客交流！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法语言","slug":"技术/算法语言","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"CSS","slug":"CSS","permalink":"https://baiyuan.wang/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"一个炫酷、快速的PC网址导航站-百元导航","slug":"cool-fast-pc-site-navigation-station-baiyuan","date":"2015-12-29T05:42:55.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"cool-fast-pc-site-navigation-station-baiyuan.html","link":"","permalink":"https://baiyuan.wang/cool-fast-pc-site-navigation-station-baiyuan.html","excerpt":"","text":"前几天在一个网站上发现了一个炫酷的导航网页，界面美观大气，采用windows8磁贴风格、网站图标采用扁平化设计。后来发现这个导航网页是开放源码的，于是就下载了一份，并做了细微的修改与优化放在我的主机上，取名“百元导航”。之后我就自豪将“百元导航”设置为我所有浏览器的主页。因为我可以自信地告诉你，这个导航网页二次加载速度绝对快于任何导航网站（不服可亲测），包括主流的百度搜索、360导航。话不多说，百元导航的网址：http://baiyuan.wang/daohang，欢迎大家将其设置为你的浏览器主页和提出宝贵意见。 百元导航网 0.3s的极速加载体验百元导航的首次加载速度在我的15M宽带下、360极速浏览器谷歌内核下测试速度为851ms，二次加载速度260ms，并且支持第二次没有联网都可以访问。之所以能在不到0.3s的速度里完成加载，是因为网页内的所有资源包括CSS、js以及网页自身的html都缓存在本地。二次访问相当于你在本地硬盘上打开一个网页文件。 怎样实现浏览器资源缓存一般来说，浏览器会将其访问过的一些资源文件进行保存，比如CSS，JS，这些存储在本地磁盘的网页文件称为缓存，在二次访问时，浏览器一般会优先访问本地缓存里面的内容，如果网页中还有些资源文件在缓存里没有找到或者缓存已经过时，才会通过网络连接向服务器上请求下载。这就是我们在上网时发现一个网站首次访问速度会特别慢、第二次就快很多的缘故。 浏览器缓存css、js是默认行为，缓存时间也是不确定的，为了让浏览器缓存所有的文件，甚至包括网页文件自身，并且让浏览器缓存的CSS、JS缓存的时间足够长，服务器可以做一个缓存文件类型设置和缓存超时设置。 在网站根目录或者当前资源文件目录中的htaccess中加入：&lt;FilesMatch “.(flv|gif|jpg|jpeg|png|ico|swf|js|css|pdf|eot)$”&gt;Header set Cache-Control “max-age&#x3D;2592000” 表示将扩展名为flv、gif、jpg、jpeg、png、ico、swf、js、css、pdf、eot 的文件缓存过期时间为2592000秒，30天。如下同理，将js、css过期时间设置为10天： &lt;FilesMatch “.(js|css)$”&gt;Header set Cache-Control “max-age&#x3D;864000” 将txt、xml、html过期时间设置为10天 &lt;FilesMatch “.(txt|xml|html)$”&gt;Header set Cache-Control “max-age&#x3D;864000” 或者在PHP中使用@header函数发出响应头消息告诉浏览器资源过期时间： &#x2F;&#x2F;缓存过期时间$expires_offset &#x3D; gmdate( “D, d M Y “, time() ).’16:00:00’ . ‘ GMT’;header(‘Content-Type: text&#x2F;css; charset&#x3D;UTF-8’);header(‘Expires: ‘ . $expires_offset);header(“Cache-Control: public”); 上面实现了将放置此代码的PHP文件返回的文件类型是text&#x2F;css）缓存过期时间为每天北京时间0点，GMT时间（格林尼治时间）16：00。 有自动提示、支持多引擎的搜索框搜索框的代码是我在原有的导航网站源代码基础上加入的，支持百度、极客搜、谷歌、360、搜狗搜索，并使用了百度开放的百度搜索框提示代码“opensug.js”实现了自动提示功能。具体的实现方法可以参考我的下一篇博文：**支持自动提示的多引擎的搜索框。**","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"},{"name":"Http","slug":"Http","permalink":"https://baiyuan.wang/tags/Http/"}]},{"title":"PHP获取指定日期的农历和节日","slug":"php-for-specified-date-of-lunar-month-festival","date":"2015-12-25T15:37:53.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"php-for-specified-date-of-lunar-month-festival.html","link":"","permalink":"https://baiyuan.wang/php-for-specified-date-of-lunar-month-festival.html","excerpt":"","text":"今天是圣诞节，用了半天做了一个节日祝福语和节日主题，效果还不错。可以在洋节和中国节日（包括农历节日 春节、中秋节等等）当天更换王柏元的博客的节日主题，并在站点公告里送上节日祝福语。 下面是关键的PHP类：Lunar。其中的getFestival()函数可传入的实参是不定数目的，可以通过传入的公历年月日，不传入默认是当前的服务器时间，函数实现了判断指定日期是否是已经设定的节日：比如中秋节、春节，同时还输出节日祝福语或诗句，返回的形式是一个数组。其余几个函数实现了获取公历和农历之间的转换，农历还支持返回当前日期农历的天干地支纪年以及生肖。 PHP获取农历和节日 lunarInfo\\[$year-$this->MIN_YEAR\\]; if($year==$this->MIN_YEAR&&$monthgetDaysBetweenSolar($year,$month,$date,$yearData\\[1\\],$yearData\\[2\\])); } /\\*\\* \\* 将阴历转换为阳历 \\* @param year 阴历-年 \\* @param month 阴历-月，闰月处理：例如如果当年闰五月，那么第二个五月就传六月，相当于阴历有13个月，只是有的时候第13个月的天数为0 \\* @param date 阴历-日 */ function convertLunarToSolar($year,$month,$date){ $yearData = $this->lunarInfo\\[$year-$this->MIN_YEAR\\]; $between = $this->getDaysBetweenLunar($year,$month,$date); $res = mktime(0,0,0,$yearData\\[1\\],$yearData\\[2\\],$year); $res = date('Y-m-d',$res+$between\\*24\\*60*60); $day = split_date($res); $year = $day\\[0\\]; $month= $day\\[1\\]; $day = $day\\[2\\]; return array($year, $month, $day); } /\\*\\* \\* 判断是否是闰年 \\* @param year */ function isLeapYear($year){ return (($year%4==0 && $year%100 !=0) || ($year%400==0)); } /\\*\\* \\* 获取干支纪年 \\* @param year */ function getLunarYearName($year){ $sky = array('庚','辛','壬','癸','甲','乙','丙','丁','戊','己'); $earth = array('申','酉','戌','亥','子','丑','寅','卯','辰','巳','午','未'); $year = $year.''; return $sky\\[$year{3}\\].$earth\\[$year%12\\]; } /\\*\\* \\* 根据阴历年获取生肖 \\* @param year 阴历年 */ function getYearZodiac($year){ $zodiac = array('猴','鸡','狗','猪','鼠','牛','虎','兔','龙','蛇','马','羊'); return $zodiac\\[$year%12\\]; } /\\*\\* \\* 获取阳历月份的天数 \\* @param year 阳历-年 \\* @param month 阳历-月 */ function getSolarMonthDays($year,$month){ $monthHash = array('1'=>31,'2'=>$this->isLeapYear($year)?29:28,'3'=>31,'4'=>30,'5'=>31,'6'=>30,'7'=>31,'8'=>31,'9'=>30,'10'=>31,'11'=>30,'12'=>31); return $monthHash\\[\"$month\"\\]; } /\\*\\* \\* 获取阴历月份的天数 \\* @param year 阴历-年 \\* @param month 阴历-月，从一月开始 */ function getLunarMonthDays($year,$month){ $monthData = $this->getLunarMonths($year); return $monthData\\[$month-1\\]; } /\\*\\* \\* 获取阴历每月的天数的数组 \\* @param year */ function getLunarMonths($year){ $yearData = $this->lunarInfo\\[$year - $this->MIN_YEAR\\]; $leapMonth = $yearData\\[0\\]; $bit = decbin($yearData\\[3\\]); for ($i = 0; $i < strlen($bit);$i ++) { $bitArray\\[$i\\] = substr($bit, $i, 1); } for($k=0,$klen=16-count($bitArray);$kMIN_YEAR\\]; $monthArray = $this->getLunarYearMonths($year); $len = count($monthArray); return ($monthArray\\[$len-1\\]==0?$monthArray\\[$len-2\\]:$monthArray\\[$len-1\\]); } function getLunarYearMonths($year){ //debugger; $monthData = $this->getLunarMonths($year); $res=array(); $temp=0; $yearData = $this->lunarInfo\\[$year-$this->MIN_YEAR\\]; $len = ($yearData\\[0\\]==0?12:13); for($i=0;$iMIN_YEAR\\]; return $yearData\\[0\\]; } /\\*\\* \\* 计算阴历日期与正月初一相隔的天数 \\* @param year \\* @param month \\* @param date */ function getDaysBetweenLunar($year,$month,$date){ $yearMonth = $this->getLunarMonths($year); $res=0; for($i=1;$i0? $year : ($year-1); $yearMonth = $this->getLunarYearMonths($year); $leapMonth = $this->getLeapMonth($year); $between = $between>0?$between : ($this->getLunarYearDays($year)+$between); for($i=0;$igetCapitalNum(($leapMonth!=0&&$leapMonth+1getCapitalNum($e,false)); } array_push($lunarArray,$this->getLunarYearName($year));//天干地支 array_push($lunarArray,$t,$e); array_push($lunarArray,$this->getYearZodiac($year));//12生肖 array_push($lunarArray,$leapMonth);//闰几月 return $lunarArray; } /\\*\\* \\* 获取数字的阴历叫法 \\* @param num 数字 \\* @param isMonth 是否是月份的数字 */ function getCapitalNum($num,$isMonth){ $isMonth = $isMonth || false; $dateHash=array('0'=>'','1'=>'一','2'=>'二','3'=>'三','4'=>'四','5'=>'五','6'=>'六','7'=>'七','8'=>'八','9'=>'九','10'=>'十 '); $monthHash=array('0'=>'','1'=>'正月','2'=>'二月','3'=>'三月','4'=>'四月','5'=>'五月','6'=>'六月','7'=>'七月','8'=>'八月','9'=>'九月','10'=>'十月','11'=>'冬月','12'=>'腊月'); $res=''; if($isMonth){ $res = $monthHash\\[$num\\]; }else{ if($num10&&$num20&&$num\"正月初一\", \"info\"=>\"春节\", \"wish\"=>\"春回大地风光好，福满人间喜事多。\" ), array( \"date\"=>\"正月初二\", \"info\"=>\"新春\", \"wish\"=>\"春回大地风光好，福满人间喜事多。\" ), array( \"date\"=>\"正月初三\", \"info\"=>\"新春\", \"wish\"=>\"春回大地风光好，福满人间喜事多。\" ), array( \"date\"=>\"正月十五\", \"info\"=>\"元宵节\", \"wish\"=>\"火树银花合，星桥铁锁开。\" ), array( \"date\"=>\"七月初七\", \"info\"=>\"七夕\", \"wish\"=>\"七夕今宵看碧霄，牵牛织女渡河桥。\" ), array( \"date\"=>\"八月十五\", \"info\"=>\"中秋\", \"wish\"=>\"但愿人长久，千里共婵娟！\" ), array( \"date\"=>\"腊月廿九\", \"info\"=>\"除夕\", \"wish\"=>\"爆竹声中一岁除，春风送暖入屠苏。\" ), array( \"date\"=>\"腊月三十\", \"info\"=>\"除夕\", \"wish\"=>\"爆竹声中一岁除，春风送暖入屠苏。\" ) ), array( array( \"date\"=>\"1/1\", \"info\"=>\"元旦\" ), array( \"date\"=>\"2/14\", \"info\"=>\"情人节\" ), array( \"date\"=>\"10/1\", \"info\"=>\"国庆节\" ), array( \"date\"=>\"12/25\", \"info\"=>\"圣诞节\", \"wish\"=>\"Merry Christmas！\" ) ) ); $args = func\\_get\\_args(); $y=isset($args\\[0\\])? $args\\[0\\]:date(\"Y\"); $m=isset($args\\[1\\])? $args\\[1\\]:date(\"m\"); $d=isset($args\\[2\\])? $args\\[2\\]:date(\"d\"); $result=array(); $result\\[\"is\"\\]=false; $ldate=$this->convertSolarToLunar($y,$m,$d); $day=$m.\"/\".$d; $lday=$ldate\\[1\\].\"\".$ldate\\[2\\]; for($i=0;$i","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"新的Http状态码-451","slug":"new-http-status-code-451","date":"2015-12-24T09:26:44.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"new-http-status-code-451.html","link":"","permalink":"https://baiyuan.wang/new-http-status-code-451.html","excerpt":"","text":"12月24日消息，据国外媒体报道，互联网工程指导委员会IESG近日通过了一个全新的互联网HTTP 状态码——451（UnavailableFor Legal Reasons），代表基于法律因素，网站内容已遭封锁。 Ray Bradbury所著Fahrenheit 451 451这个状态码来源于Ray Bradbury写的一篇影响深远的小说《华氏 451》（Fahrenheit 451）。早在3年前，谷歌Tim Bray向互联网工程任务小组（IETF）提议，允许开发者开始实施“451”HTTP状态码，但直到上周才正式获批，可以使用。 他认为，应该把由于技术原因与非技术原因导致网页不可见的代码区分开来。此前，许多网站用“403”这个 HTTP 状态码用于描述由于技术原因禁止访问，未来“451”广泛实施，这个错误代码应能帮助网友解开无法造访网站的困惑。 451状态码的原意是用于标示出哪些内容是被法律禁止访问，可以用在网络设备上或Web服务器上。现在，Github、Twitter、Facebook 和谷歌都已经开始使用这个状态码来应对各个国家地区的审查要求。 不过，一些国家政府将会禁止使用 451 错误代码，以避免公开对于网络内容的审查制度。","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://baiyuan.wang/tags/Http/"}]},{"title":"流量关键词链接页面提升百度权重","slug":"keyword-links-page-baidu-weight-ascension","date":"2015-12-20T06:39:56.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"keyword-links-page-baidu-weight-ascension.html","link":"","permalink":"https://baiyuan.wang/keyword-links-page-baidu-weight-ascension.html","excerpt":"","text":"百度搜索的排名常常根据页面搜索进入的流量大小进行变化，如果对于一个关键词很多人都会进入同一个网页，百度会认为这个网页能很好地解决这个问题，从而使这个网页在该关键词搜索时排在其它网页的前面。在百度站长平台的后台，我们可以知道有哪些关键词被百度搜索以及是否进入了我们的网页。我们可以通过做一个这个页面，里面全是搜索这些关键词的网址，访问以后进入我们的网站，从而提升我们的网站排名。 流量关键词链接页面提升百度权重以下的代码是我写的一个流量关键词链接页面，里面全部是我的百度关键词。我们和偶尔点一下，提升相应关键词排名。使用方法是将百度流量关键词导出后放在一个keyword.txt文件里，关键词每行一个，文件路径与下面的PHP代码文件相同。 百度关键词|王柏元的博客 .link{ float:left; margin-left:12px; padding:2px; } a:visited { color:#00FF00; text-decoration:none; } &lt;?php&#x2F;** * Created by PhpStorm. * project： wordpress-blog * User: BrainWang * Author_URL: http://baiyuan.wang * Date: 2015&#x2F;12&#x2F;20 * Time: 14:03 *&#x2F; $file &#x3D; fopen(“keyword.txt”, “r”) or exit(“Unable to open file!”);$url&#x3D;”https://www.baidu.com/s?ie=UTF-8&amp;wd=“;&#x2F;&#x2F;Output a line of the file until the end is reachedwhile(!feof($file)){ $key&#x3D;fgets($file); $EncodeStr&#x3D;urlencode($key); echo ‘‘.$key.’‘;}fclose($file);?&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"}]},{"title":"一个炫酷的HTML5 “闭站保护中”404页面","slug":"cool-html-5-protection-closed-404-pages","date":"2015-12-18T01:41:23.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"cool-html-5-protection-closed-404-pages.html","link":"","permalink":"https://baiyuan.wang/cool-html-5-protection-closed-404-pages.html","excerpt":"","text":"网站一夜关键词降为0王柏元的博客疑似被百度搜索K掉，自上个月17号以来关键词个数一路走低，直到这个月降为0，昨天甚至通过“王柏元的博客”、“王柏元”这样的关键词我的网站不在前5名、甚至无法搜索到我的网站，初步判断的原因可能是我上个月解析的www.baiyuan.wang到本网站因为疏忽没有实行301重定向到baiyuan.wang，导致百度搜索认为我的网站被镜像。在未找到确切原因之前，我决定通过百度站长平台采取闭站保护，防止不明原因对网站SEO进一步产生影响。 闭站保护申请期间，百度要求被保护的网站要出于不能访问状态：全站HTTP状态码设置为404，或者将服务器关机服务器。通过域名不解析的方法是不能通过闭站保护审核的。所以对于虚拟主机用户不能切断服务器电源情况下，可以采用全站404的方式申请闭站保护。 新建如下内容的index.php实现全站404你可以将原来根目录的原index.php文件改名，新建一个index.php内容如下： &lt;meta charset=&quot;UTF-8&quot;&gt; 闭站保护中…… body { background: black; } .clock { position: absolute; opacity: 1; } .fill .clock { left: 50%; top: 50%; } .centre { position: absolute; top: 50%; left: 50%; width: 0; height: 0; } .expand { position: absolute; top: 0; left: 0; transform: translate(-50%, -50%); } .anchor { position: absolute; top: 0; left: 0; width: 0; height: 0; } .element { position: absolute; top: 0; left: 0; } .round { border-radius: 296px; } .circle-1 { background: white; width: 12px; height: 12px; } .circle-2 { background: #FA9F22; width: 8px; height: 8px; } .circle-3 { background: black; width: 4px; height: 4px; } .second { transform: rotate(180deg); } .minute { transform: rotate(54deg); } .second-hand { width: 2px; height: 164px; background: #FA9F22; transform: translate(-50%,-100%) translateY(24px); } .hour { transform: rotate(304.5deg); } .thin-hand { width: 4px; height: 50px; background: white; transform: translate(-50%,-100%); } .fat-hand { width: 10px; height: 57px; border-radius: 10px; background: white; transform: translate(-50%,-100%) translateY(-18px); } .minute-hand { height: 112px; } .hour-text { position: absolute; font: 40px Hei, Helvetica, Arial, sans-serif; color: white; transform: translate(-50%,-50%); } .hour-10 { padding-left: 0.4ex; } .hour-11 { padding-left: 0.25ex; } .minute-text { position: absolute; font: 12px Avenir Next, Helvetica, Arial, sans-serif; color: white; transform: translate(-50%,-50%); } .minute-line { background: white; width: 1px; height: 9px; transform: translate(-50%,-100%) translateY(-131px); opacity: 0.34; } 王柏元的博客 闭站保护中…… var clock = document.querySelector('#utility-clock') utilityClock(clock) if (clock.parentNode.classList.contains('fill')) autoResize(clock, 295 + 32) function utilityClock(container) { var dynamic = container.querySelector('.dynamic') var hourElement = container.querySelector('.hour') var minuteElement = container.querySelector('.minute') var secondElement = container.querySelector('.second') var minute = function(n) { return n % 5 == 0 ? minuteText(n) : minuteLine(n) } var minuteText = function(n) { var element = document.createElement('div') element.className = 'minute-text' element.innerHTML = (n < 10 ? '0' : '') + n position(element, n / 60, 135) dynamic.appendChild(element) } var minuteLine = function(n) { var anchor = document.createElement('div') anchor.className = 'anchor' var element = document.createElement('div') element.className = 'element minute-line' rotate(anchor, n) anchor.appendChild(element) dynamic.appendChild(anchor) } var hour = function(n) { var element = document.createElement('div') element.className = 'hour-text hour-' + n element.innerHTML = n position(element, n / 12, 105) dynamic.appendChild(element) } var position = function(element, phase, r) { var theta = phase * 2 * Math.PI element.style.top = (-r * Math.cos(theta)).toFixed(1) + 'px' element.style.left = (r * Math.sin(theta)).toFixed(1) + 'px' } var rotate = function(element, second) { element.style.transform = element.style.webkitTransform = 'rotate(' + (second * 6) + 'deg)' } var animate = function() { var now = new Date() var time = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds() * 1 + now.getMilliseconds() / 1000 rotate(secondElement, time) rotate(minuteElement, time / 60) rotate(hourElement, time / 60 / 12) requestAnimationFrame(animate) } for (var i = 1; i","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"}]},{"title":"创想-课上到课下的O2O高校教育模式","slug":"class-class-o2o-education-pattern-in-colleges-universities","date":"2015-12-15T02:43:33.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"class-class-o2o-education-pattern-in-colleges-universities.html","link":"","permalink":"https://baiyuan.wang/class-class-o2o-education-pattern-in-colleges-universities.html","excerpt":"","text":"现在传统的高校课堂，老师和学生之间实际上缺乏较多了解，上课时的讨论交流气氛并不热烈，个人认为一是由于师生间缺乏沟通；二是大学课上的教授的知识进度较快可能留给师生间的互动时间较少，课下学生的回顾探讨也较少。这常常会导致：老师认为现在的孩子不好好学习，学生觉得老师教的太快和缺乏生气。 创想-课上到课下的O2O高校教育模式我们可以提供一个课上到课下(O2O)的教育模式，老师可以在这个平台上留下当前课程的一些问题，让学生进行讨论，老师可以在阅读学生的讨论中对他的学生进行进一步了解，发现一些在课堂上沉默寡言但实质上有一定思想、能力的学生，同时用APP发表评论、指点。（举例：我们最近有个毛概课老师，让一些同学上课发表对课上看到几个视频的看法，常常出现时间不够或者跃跃欲试者缺乏自信不敢上讲台的情况）。 上课玩手机、睡觉是当代学生留给高校老师最大的坏印象，不知道会不会有大量老师会觉得现代学生不学无术，但是你也会发现许多学生会在知乎等社交媒体上，严肃地讨论一些技术、人文、社会问题，而不是明星娱乐类的花边新闻，他们也在学习，只是现在许多人习惯通过互联网的方式来表达自己。我们何不搭建一个平台给师生沟通的空间。让老师发现学生，让学生记住老师（高校的一种悲哀是上完课、学生却不知道老师叫啥名字）。 我们可以提供的服务有：专题问题探讨、师生聊天、老师发布知识点、课程进展（学生可以根据这个在课前做好相关预习准备）、教务通知（比如考试时间发布）、答疑、还有请假服务（学生请假、辅导员批假（辅导员的签名可以利用iPhone手机的指纹识别）、老师准假）。其他待讨论。 我们的创新在于用O2O的模式充实现代高等教育，将其作为高等教育 课上的补充，根据课下学生的表现来给平时分，刺激学生课下的学习氛围。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"奇思妙想","slug":"奇思妙想","permalink":"https://baiyuan.wang/tags/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"},{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"闲言碎语","slug":"闲言碎语","permalink":"https://baiyuan.wang/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}]},{"title":"微信开发获取位置与百度地图经纬度解析","slug":"get-position-with-baidu-map-wechat-development-latitude-longitude-resolution","date":"2015-12-14T14:12:12.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"get-position-with-baidu-map-wechat-development-latitude-longitude-resolution.html","link":"","permalink":"https://baiyuan.wang/get-position-with-baidu-map-wechat-development-latitude-longitude-resolution.html","excerpt":"","text":"微信开发中我们常常需要知道用户的位置，在微信的JS-SDK中提供了访问地理位置的方法，这不需要你的公众号是认证账户，普通未认证的订阅号也有访问地理位置的权限。 微信开发获取位置与百度地图经纬度解析根据微信公众号开发者文档中的 JSSDK使用步骤 1.1.1 步骤一：绑定域名 1.1.2 步骤二：引入JS文件 1.1.3 步骤三：通过config接口注入权限验证配置 1.1.4 步骤四：通过ready接口处理成功验证 1.1.5 步骤五：通过error接口处理失败验证 微信开发获取位置与百度地图经纬度解析,我们可以根据官方文档可以获取很多高级功能，这里就不赘述。可能比较棘手的是后面遇到的消息签名问题。下面是官方给的代码: appId = $appId; $this->appSecret = $appSecret; } public function getSignPackage() { $jsapiTicket = $this->getJsApiTicket(); // 注意 URL 一定要动态获取，不能 hardcode. $protocol = (!empty($\\_SERVER\\['HTTPS'\\]) && $\\_SERVER\\['HTTPS'\\] !== 'off' || $\\_SERVER\\['SERVER\\_PORT'\\] == 443) ? \"https://\" : \"http://\"; $url = \"$protocol$\\_SERVER\\[HTTP\\_HOST\\]$\\_SERVER\\[REQUEST\\_URI\\]\"; $timestamp = time(); $nonceStr = $this->createNonceStr(); // 这里参数的顺序要按照 key 值 ASCII 码升序排序 $string = \"jsapi_ticket=$jsapiTicket&noncestr=$nonceStr&timestamp=$timestamp&url=$url\"; $signature = sha1($string); $signPackage = array( \"appId\" => $this->appId, \"nonceStr\" => $nonceStr, \"timestamp\" => $timestamp, \"url\" => $url, \"signature\" => $signature, \"rawString\" => $string ); return $signPackage; } private function createNonceStr($length = 16) { $chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; $str = \"\"; for ($i = 0; $i < $length; $i++) { $str .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); } return $str; } private function getJsApiTicket() { // jsapi_ticket 应该全局存储与更新，以下代码以写入到文件中做示例 $data = json\\_decode($this->get\\_php\\_file(\"jsapi\\_ticket.php\")); if ($data->expire_time < time()) { $accessToken = $this->getAccessToken(); // 如果是企业号用以下 URL 获取 ticket // $url = \"https://qyapi.weixin.qq.com/cgi-bin/get\\_jsapi\\_ticket?access_token=$accessToken\"; $url = \"https://api.weixin.qq.com/cgi-bin/ticket/getticket?type=jsapi&access_token=$accessToken\"; $res = json_decode($this->httpGet($url)); $ticket = $res->ticket; if ($ticket) { $data->expire_time = time() + 7000; $data->jsapi_ticket = $ticket; $this->set\\_php\\_file(\"jsapi\\_ticket.php\", json\\_encode($data)); } } else { $ticket = $data->jsapi_ticket; } return $ticket; } private function getAccessToken() { // access_token 应该全局存储与更新，以下代码以写入到文件中做示例 $data = json\\_decode($this->get\\_php\\_file(\"access\\_token.php\")); if ($data->expire_time < time()) { // 如果是企业号用以下URL获取access_token // $url = \"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$this->appId&corpsecret=$this->appSecret\"; $url = \"https://api.weixin.qq.com/cgi-bin/token?grant\\_type=client\\_credential&appid=$this->appId&secret=$this->appSecret\"; $res = json_decode($this->httpGet($url)); $access\\_token = $res->access\\_token; if ($access_token) { $data->expire_time = time() + 7000; $data->access\\_token = $access\\_token; $this->set\\_php\\_file(\"access\\_token.php\", json\\_encode($data)); } } else { $access\\_token = $data->access\\_token; } return $access_token; } private function httpGet($url) { $curl = curl_init(); curl\\_setopt($curl, CURLOPT\\_RETURNTRANSFER, true); curl\\_setopt($curl, CURLOPT\\_TIMEOUT, 500); // 为保证第三方服务器与微信服务器之间数据传输的安全性，所有微信接口采用https方式调用，必须使用下面2行代码打开ssl安全校验。 // 如果在部署过程中代码在此处验证失败，请到 http://curl.haxx.se/ca/cacert.pem 下载新的证书判别文件。 curl\\_setopt($curl, CURLOPT\\_SSL_VERIFYPEER, true); curl\\_setopt($curl, CURLOPT\\_SSL_VERIFYHOST, true); curl\\_setopt($curl, CURLOPT\\_URL, $url); $res = curl_exec($curl); curl_close($curl); return $res; } private function get\\_php\\_file($filename) { return trim(substr(file\\_get\\_contents($filename), 15)); } private function set\\_php\\_file($filename, $content) { $fp = fopen($filename, \"w\"); fwrite($fp, \"“ . $content); fclose($fp); }} 在PHP中调用： $jssdk &#x3D; new JSSDK(wx_appid, wx_appkey);$signPackage &#x3D; $jssdk-&gt;GetSignPackage(); 在HTML中加入js代码： wx.config({ debug: false, appId: '', timestamp: , nonceStr: '', signature: '', jsApiList: \\[ // 所有要调用的 API 都要加到这个列表中 'checkJsApi', 'openLocation', 'getLocation', 'hideOptionMenu' \\] }); 调用js代码获取经纬度： wx.getLocation({ type: ‘wgs84’, &#x2F;&#x2F; 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入’gcj02’ success: function (res) { ilatitude &#x3D; res.latitude; &#x2F;&#x2F; 纬度，浮点数，范围为90 ~ -90 ilongitude &#x3D; res.longitude; &#x2F;&#x2F; 经度，浮点数，范围为180 ~ -180。 ispeed &#x3D; res.speed; &#x2F;&#x2F; 速度，以米&#x2F;每秒计 iaccuracy &#x3D; res.accuracy;&#x2F;&#x2F;精度 &#125; &#125;); 百度地图经纬度解析微信JS-SDK提供的只是经纬度，而不是像“陕西省西安市”这样的地理位置，下面是将经纬度转为地理位置的PHP函数，调用的是百度地图的web-api： define(‘ak’, ‘换成你申请的百度地图API ak’);define(‘apiUrl’, ‘http://api.map.baidu.com/geocoder/v2/?ak=&#39;.ak.&#39;&amp;‘); &#x2F;** * @param $longitude 经度 * @param $latitude 纬度 * @return 地理位置 *&#x2F;function AddresByGeocoding($longitude,$latitude){ $url &#x3D; apiUrl.”location&#x3D;”.$latitude.”,”.$longitude.”&amp;output&#x3D;json&amp;pois&#x3D;0”; $result&#x3D; file_get_contents($url); $jsondata &#x3D; json_decode($result,true); $address &#x3D;$jsondata[‘result’][‘formatted_address’]; return $address;}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"[转]来自未来的物联网应用体验报告——健康篇","slug":"future-internet-of-things-application-experience-health","date":"2015-12-13T14:00:01.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"future-internet-of-things-application-experience-health.html","link":"","permalink":"https://baiyuan.wang/future-internet-of-things-application-experience-health.html","excerpt":"","text":"转自《无锡都市报》，2010.4.1 [转]来自未来的物联网应用体验报告——健康篇A一个难得的休息日。 早上和正在出差的妻子通了个视频电话，她说正在欧洲一个海滨城市开会，还让我打开“视频通话实时场景”功能，让我感受一下阳光海滩的气氛。 我点了一下按钮，海鸥的声音倒是很清晰，但传感口吹过来的风却没有一丝海水的咸味。看来模拟器里的添加剂又用光了。这玩意儿，说是“实时场景”，其实只是通过后台的模拟器来“虚拟”，如果对方想让你闻一块蛋糕，它就模拟出丝丝的甜味；如果是一只芒果，甜中它还会聪明地加上几分酸。我一直想知道臭味它是怎么模拟的，但还没机会试一试…… 突然记起来，4月1日好像家庭网络提醒过我要健身了，那就活动活动吧！ 当然不能忘记戴上我的“能量采集戒指”，这是一个蓝色的金属圈，戴上它之后，它就同时被激活，记录我运动时消耗的物质情况，像卡路里啦、碳水化合物啦、脂肪啦，然后反馈到家庭网络的“健康管理服务平台”，由它对我的身体状况进行评估，然后指导我进行科学运动。 还有脚下的这台跑步机也得提一提。它也和整个社区的能量站联网了，我跑步所产生的动能，基本上都能被传输到能量站里保存起来。能量站就是我们的“电站 ”，说实话，我们运动所产生的能量微不足道，它主要采集的是太阳能和风能，每一个社区都有这样的能量站，供给人们生活所需的电能。在这个时代，冒着浓烟的发电站已经无影无踪了。 烧了一壶咖啡，喝了一杯之后，我想，不如测测自己的身体状态吧？于是激活墙上的显示屏，我连上了城市的疾病预防网络，这个网络是统一规划、由各大医院分区域共同组建的。在这个时代，每个家庭都有一台便携式检测仪，可以随时为每一个家庭成员检查身体。通过仪器上的多个传感器，还能使医生远程发现疾病，像心血管疾病、癌症、糖尿病等疾病就可以实现早期发现，早期治愈。 医生在对我进行远程检测之后，提醒我：没有什么大问题，只是肺部功能有些不足，因为我小时候得过肺炎，一得病就容易咳嗽。检测完毕，一条信息就发到了我的手机上，建议我有空的时候到医院去看一下。 B吃过午饭，我悠笃笃来到医院。 现在医院环境真不错，最让人心动的是医生和护士。不管是什么人，看上去都整洁高雅，走近时，都亲切地向人微笑致意，有的还会向你挥手。他们的眼光自信而柔和，充满了一种新时代的精神特征。 不断有人在墙上点着，触发一个又一个显示屏。有的是在预约挂号，有的是在购买药品，也有医生走着走着，接收到了一条信息，也会点击触发墙壁上的屏幕，显示出一串复杂的数据和曲线——现在，他们好像在哪儿都能工作了。 我也挂了一个号，系统提示我应该去内科。我经过一条走廊，亮光也是从墙壁上发出的，虽然很柔和，但还是让我眯起了眼睛。就在我眯眼的同时，我发现了一件 “神奇”的事情：这一段走廊的墙壁也暗了下来，这黯淡的一段一直跟着我的脚步移动。当我的眼睛适应光亮又睁大时，这移动的一段也随之又亮起来，但亮度一直保持在令我舒适的范围内。原来，这里也应用了物联网的技术，走廊的光度调节系统可以监测到我眼睛的瞳孔变化，真是太不可思议了！ 接待我的张医生是一名和蔼的中年人，他很健谈，在给我做了检查后，表示没有什么问题，给我开了几味药。 我问起了刚才在走廊上看到的事，张医生笑道：“这算啥？你还不知道吧，现在物联网技术在医院的应用太广泛了！”他举例说，比如现在救护车内的监测设备可以采集急救病人的生命体征信息，并实时上传至医院急诊中心，节省时间进行急救；还有一种人工智能手术机器人，手术动作精度达到百分之一毫米，远超过人手的准确性，而且永远精力充沛，不受情绪和外界环境的影响；还有一种微型治疗机器人，又叫“纳米炸弹”，通过远程控制它，人们可以“炸死”癌细胞，同时又不损害其他的细胞…… 看我听得津津有味，张医生又神秘地说，其实他一直在研究中医，并有了一些心得。他说，中医里的“经络”和“穴位”，仪器发现不了，解剖也发现不了，现代医学似乎没法完全解释，这到底是为什么？ “就像宇宙一样，我们现在所接触到的一切物质，只占宇宙总物质的百分之四左右，其他的是什么呢？是暗物质和暗能量，那些都是我们目前探测不出的。如果我们把‘经络’、‘穴位’想象成一种流淌在人身体里的暗能量，也就能解释为什么现在仪器探测不出了。” 张医生兴奋地说：“现在我们生活在物联网里，如果有一天，能把人体的这种暗能量连接、也组成一张巨大的网络，那该是怎样的一幅景象啊！” 听起来是有点像科幻小说，但在以前的时代里，我们今天的物联网生活不也如同一部科幻小说吗？ C刚准备回家，妻子又打来一个电话，听说我在医院，她说正好，她有个阿姨生病住院了，让我去看望看望。 医院的门口有好几个花店，我用手机的支付功能买了一束花(他们的生意仿佛一直不错)。走进阿姨的病房，医生们正在查房，一位医生拿出PDA在阿姨的病床边扫了一下，PDA马上识别出了身份。如今每一张病床其实就是一个“传感节点”，它可以把病人的很多生理数据，像心跳、血糖含量、血氧含量数据实时传输到医院的服务平台上。 阿姨告诉我，她的心脏一直不太好，这次经过诊断，医院决定为她进行心脏移植手术。 正在说话的当儿，病床旁边的桌上，一只小瓶子发出了“嘟嘟”的声音。阿姨笑着说：“又在催我吃药了。”看我不解的样子，阿姨解释说，这是医院最新推出的“智能药瓶”，它可以自动提示服药的时间，同时链接到医院的服务平台，医生可以根据病人的实时身体情况，远程控制服药量；最重要的是，它还可以减少误服的机会。 阿姨还悄悄告诉我，她不想让机器人在她身上“动刀子”，她已经和医院说了，要求由一位医生来实施手术。谁知道医院乐坏了——因为现在的人太相信机器，医生都把每一次“动刀”的机会当成恩赐了，这几天，她可没少享受“众星拱月”的待遇！","categories":[{"name":"业界","slug":"业界","permalink":"https://baiyuan.wang/categories/%E4%B8%9A%E7%95%8C/"},{"name":"极客视点","slug":"业界/极客视点","permalink":"https://baiyuan.wang/categories/%E4%B8%9A%E7%95%8C/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"https://baiyuan.wang/tags/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"},{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"[转]来自未来的物联网应用体验——家具篇","slug":"go-from-future-internet-of-things-application-experience-of-furniture","date":"2015-12-13T13:00:18.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"go-from-future-internet-of-things-application-experience-of-furniture.html","link":"","permalink":"https://baiyuan.wang/go-from-future-internet-of-things-application-experience-of-furniture.html","excerpt":"","text":"转自《无锡都市报》，2010.4.1 A我醒了。 不是被闹钟闹醒的，也不是被电话吵醒的，是阳光，打在我脸上的阳光，把我从梦中叫醒了。窗帘在几分钟前感应到了早晨温度、湿度和光线的变化，已经缓缓拉开了。 我翻了个身，摁了一下床头的按钮，对面三分之一的墙壁被激活成了显示屏。等我穿好衣服，它已经自动调整为“电视”模式，开始播放《朝闻天下》了。 今天妻子不在家，要自己做早饭啦。我点了一下显示屏上的“暂停”，走进厨房。站在电冰箱门前，显示屏上根据冰箱里的库存，自动给出了一份“营养菜单”：一份蔬菜沙拉、一份火腿煎蛋，还有一杯纯果汁，我把蔬菜沙拉修改成“蔬菜沙拉(少量沙拉)”，然后点了一下“确定”，冰箱又“善意”地提醒我：存货已经不多，最好今天能去超市采购一下，与此同时，它还连接到了几家超市的网站，找到了几样我喜欢吃的东西，为防止我忘记，它的显示屏上打出了一个笑脸：“请注意下载。” 小看我，我记性那么差吗？不过记一下也好。我掏出手机，在它的显示屏前刷了一下，“滴”的一声，下载成功了。 在我和冰箱“商量”早餐的时候，厨房已经接受到冰箱发出的信息，开始工作了。电磁炉已经预热，厨房的背景音乐也响起了我最喜欢的那首歌。 正在煎蛋的时候，电话响了。我用胳膊肘点了一下厨房的墙壁，一块四四方方的地方被激活，妻子的笑脸出现在了上面。当然，我头顶上方的摄像头也把我做早餐时手忙脚乱的样子传送了过去，结果被妻子好好嘲弄了一番。 B吃完早餐，我走路上班去了。在这个时代，这可是最流行的出行方式。 正走在路上，我突然听到一个柔美的女声：“是刘先生吗？”我一看，声音是从路边草坪上一块大广告牌上发出的，广告牌上的大幅动态图像中，一个身穿制服的漂亮姑娘正在看着我。哦，原来是感知到了我的个人身份电子芯片，肯定是收钱来了…… “我是。”我点点头说。 “您好，我是总体银行系统第20933号服务员。您这个月的水电费和网络使用费都到代扣的日期了，根据协议，我们将为您代扣，具体金额已经发送到您的手机上，请您确认后及时回复。如果没有其他的问题就再见了。”服务员微笑着对我挥手告别。 我掏出手机，查看了消息，点击了一下“确认缴费”，通过一张看不见的网络，银行从我的账户里划走了相应的金额。哦，顺便说一下，在这个时代，广告真正实现了“个人化”，不管走到哪里，广告牌上的东西都是为你显示的。 到了单位，同一个办公室的小王给我看他刚买的一个小玩意，原来是一个立体GPS。它不但可以用立体形式指路，还能播放立体电影、链接到无线网络下载资料、和别人分享视频，小王说，下次出去旅游，一定要带上它，这一路既不会迷路，又不怕寂寞！ 刚忙了一会儿，我的手机突然发出了“嘟嘟嘟嘟”的连续音——是警报！谁闯到我家里来啦？我连忙将手机调到“监控”模式，家里的情况顿时一览无余：院子？没有人。厨房？没有人。房间？也没有！客厅？咦，客厅里有个什么东西？原来是邻居家的小花猫，不知道从哪里跑进来了。 我童心大起，打开手机里的“对讲”功能，将手机和家里的通话设备进行了一次对接，然后大喊了一声：“汪汪！”视频里，小猫被吓得连滚带爬溜出了房子。然后我又检查了一下家里，发现今天走的时候，楼上有一扇窗户没有关紧，于是在手机里重新设置了一下，将所有门窗进行了锁定。 接着我和网络公司联系了一下，他们说警报软件已经有了最新升级版，能够对“闯入者”进行识别，如果是小动物之类的“非危险分子”，房子里的警报器将自动发出警报声吓走它们，必要时还会用灯光、烟雾等“特殊手段”。他们表示，只要我将警报软件设置在“自动更新”状态，他们将尽快对我的“智能房屋”进行升级。 C结束了一天的工作，终于可以回家了。 走在路上，手机又响起来了。拿出一看，是提醒我去买菜的——哦，差点忘记了，冰箱的存货！ 拐进一家超市，到处都是动态的信息窗口，墙壁上、地板上、天花板上，甚至一些小的物品上也有滚动文字，饮料罐的外包装上除了价格，还有滚动播放的视频，明星们正在高高举着饮料，一口一口兴高采烈地喝着——也不知道她们咽下去了没有。整个超市就仿佛是一个大的电脑显示屏，显现出一种纷繁闪耀的华丽。现在买东西可方便了，只要用手机“照一照”要买的东西，物品清单和价钱就存在了手机里，只要在收银机上再“刷”一下，就可以结账走人了。 按照手机的提示，我买了一些有机玉米和番茄，几条鱼，同时还在蔬菜专柜下载了几份菜谱。结账的地方人不多，我掏出手机，在收银机前划了一下，“滴”的一声，超市已经从我的账户里扣走了相应的食物金额。 回家的路上，我拿出手机，在网上订购了几部电影，并要求直接发送到我的电视机网络硬盘里，至于收费，当然也是通过手机远程支付了。 离家不远，我就启动了家里的“欢迎”模式，客厅的灯亮起来了，关闭了一天的窗子打开后，空气的湿度也重新调整了一下，现在，就是我最舒适的时候。 在智能厨房的“帮助下”，我美美地享用了一次简单但美味的晚餐。剩下的工作交给自动洗碗机吧，我走到客厅，触发了电视的显示屏幕，上面已经显示“电影下载完毕，欢迎观赏。” 坐进透明的沙发，感觉像陷到了一块软泥里，沙发的坐垫和靠背能自动适应人体的形状，给坐在上面的人形成一个与其身体表面完全贴合的模子，使得压强最小。这个最新款的沙发出来的时候，妻子嫌贵还不肯买，瞧瞧，现在躺着多舒服！ 沙发靠背慢慢按摩着我的背部，接着电视屏幕下方就接收到了一条信息，说由于感知到我的颈椎似乎有点僵硬，建议我多活动活动，并在适当的时候去看看医生。好累啊，今天就不健身了，先睡个好觉吧！ 浴缸里已经根据我事先的指令放好了水，并已经按照我的习惯设置好了温度，洗完澡，墙上的夜光时钟已经指向十一点。 窗帘在我的背后慢慢地拉上了。它已经感知到了我在梦中均匀、平稳的呼吸。","categories":[{"name":"业界","slug":"业界","permalink":"https://baiyuan.wang/categories/%E4%B8%9A%E7%95%8C/"},{"name":"极客视点","slug":"业界/极客视点","permalink":"https://baiyuan.wang/categories/%E4%B8%9A%E7%95%8C/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"https://baiyuan.wang/tags/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"},{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"回溯法求无向图结点涂色最少颜色数","slug":"backtracking-method-undirected-graph-node-color-color-number-at-least","date":"2015-12-06T11:34:51.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"backtracking-method-undirected-graph-node-color-color-number-at-least.html","link":"","permalink":"https://baiyuan.wang/backtracking-method-undirected-graph-node-color-color-number-at-least.html","excerpt":"","text":"回溯法通过深度优先遍历的策略遍历解空间树，其实现过程是：从根节点出发搜索它的所有孩子树或者孩子结点，对于每个结点判断其是否满足约束条件和判定函数，如果满足则进入此结点同样以此结点搜索它的子结点。拥有子节点的结点称之为活节点，当搜索至到没有活节点时则返回原父节点继续寻找活节点，以此类推，直到回溯算法搜索完解空间树。 回溯法由于是遍历完解决问题的所有可能解，所以称它是解决问题的万能算法，只要正确构建了解空间树，通过回溯遍历解空间树即可。回溯算法可以解出解决问题的所有可能解，而在实际解决一些最优解问题时我们可以通过剪枝函数剪掉比中间结果比已求得最优解还差的子树。 无向图的m着色问题的m的最小值求解&#x2F;&#x2F; mColor.cpp : 定义控制台应用程序的入口点。&#x2F;&#x2F; #include “stdafx.h”#includeusing namespace std;class mColor{ friend mColor mColoring(int n, char **a);private: bool Ok(int k); void Backtrack(int t); int nodeNumber, m; char **a; public: int types, *x,*tempx; };bool mColor::Ok(int k){ for (int j &#x3D; 0; j &lt;nodeNumber; j++) if ((a[k][j] &#x3D;&#x3D; ‘1’) &amp;&amp; (tempx[j] &#x3D;&#x3D; tempx[k])) return false; return true; &#125; void mColor::Backtrack(int t){ if (t &gt;nodeNumber)&#123; types = (m &lt;types) ? m:types; &#125; else&#123; for (int i = 1; i &lt;=types; i++)&#123; tempx\\[t - 1\\] = i; if (Ok(t-1)) &#123; m = i; //cout &lt;&lt; i &lt;&lt; endl; Backtrack(t + 1); x\\[t - 1\\] = (x\\[t - 1\\] == 0 )? i:x\\[t - 1\\]; &#125; else&#123; tempx\\[ t - 1\\] = 0; &#125; &#125; &#125; } mColor mColoring(int n, char **a){ mColor X; X.m &#x3D; n; X.types &#x3D; n; X.nodeNumber &#x3D;n; X.a &#x3D; a; X.tempx &#x3D; new int[n]; X.x &#x3D; new int[n]; for (int i = 0; i &lt; n; i++)&#123; X.tempx\\[i\\] = 0; X.x\\[i\\] = 0; &#125; X.Backtrack(1); return X; &#125; int main(){ int size; cout &lt;&lt; “输入顶点个数：”; cin &gt;&gt; size; char **p &#x3D; new char*[size]; for (int i &#x3D; 0; i&lt;size; ++i)p[i] &#x3D; new char[size]; cout &lt;&lt; “请输入无向图顶点连接情况：\\n(1表示连通，0表示未连通)” &lt;&lt; endl; cout &lt;&lt; “ &gt;”; for (int i &#x3D; 0; i &lt; size; i++) cout &lt;&lt; (char)(65 + i); cout &lt;&lt; endl; for (int i &#x3D; 0; i &lt; size; i++) { cout &lt;&lt; (char)(65 + i) &lt;&lt; “&gt;”; cin &gt;&gt; p[i]; &#125; mColor x = mColoring(size, p); cout &lt;&lt; &quot;涂以上几个点所需要最少的颜色数为：&quot; &lt;&lt; x.types &lt;&lt; endl; cout &lt;&lt; &quot;涂色方案如下：&quot; &lt;&lt; endl; for (int i = 0; i &lt; size;i++)&#123; int s = x.x\\[i\\]; cout &lt;&lt; (char)(65 + i)&lt;&lt;&quot;----颜色&quot; &lt;&lt; s&lt;&lt;&quot; &quot;&lt;&lt; endl; &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"回溯法","slug":"回溯法","permalink":"https://baiyuan.wang/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"}]},{"title":"C++活动主机扫描","slug":"c-activity-host-scans","date":"2015-11-20T02:50:27.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"c-activity-host-scans.html","link":"","permalink":"https://baiyuan.wang/c-activity-host-scans.html","excerpt":"","text":"（1）以命令方式运行：DOS&gt;scanHost start_ip end_ip （2）输出内容：活动主机IP地址。 实现原理： （1）通过某IP发送ICMP_ECHO请求报文，接收到ICMP_response 报文，表明该IP主机活动。 （2）利用原始套接字 （3）为了提高检测时间，利用多线程技术。 #include #include #include &lt;winsock2.h&gt;#include #pragma comment (lib, “ws2_32.lib”) using namespace std; &#x2F;&#x2F;ip包头部结构typedef struct iphdr{ unsigned int headlen : 4; &#x2F;&#x2F;头部长度 unsigned int version : 4; &#x2F;&#x2F;版本号 unsigned char tos; &#x2F;&#x2F;服务类型 unsigned short totallen; &#x2F;&#x2F;总长度 unsigned short id; &#x2F;&#x2F;ip包id号 unsigned short flag; &#x2F;&#x2F;标记 unsigned char ttl; &#x2F;&#x2F;生存时间 unsigned char prot; &#x2F;&#x2F;协议类型 unsigned short checksum; &#x2F;&#x2F;校验和 unsigned int sourceIp; &#x2F;&#x2F;源IP地址 unsigned int destIp; &#x2F;&#x2F;目的ip地址}IpHeader; typedef struct icmphdr{ BYTE type; &#x2F;&#x2F;ICMP类型码 BYTE code; &#x2F;&#x2F;ICMP子类型 USHORT checksum; &#x2F;&#x2F;校验和 USHORT id; &#x2F;&#x2F;ICMP包ID号 USHORT seq; &#x2F;&#x2F;序列号}IcmpHeader; #define ICMP_ECHO 8 &#x2F;&#x2F;ICMP回送请求#define ICMP_ECHO_REPLY 0 &#x2F;&#x2F;ICMP回送应答#define ICMP_MIN 8 &#x2F;&#x2F;ICMP包头长度#define STATUS_FAILED 0xFFFF &#x2F;&#x2F;错误码#define DEF_PACKET_SIZE 32 &#x2F;&#x2F;缺省数据长度#define MAX_PACKET 1024 &#x2F;&#x2F;最大数据长度#define MAX_PING_PACKET_SIZE MAX_PACKET + sizeof(IpHeader) WSADATA wsaData;SOCKET sockRaw; &#x2F;&#x2F;原始套接字struct sockaddr_in dest, from, end1;int fromlen &#x3D; sizeof(from); &#x2F;&#x2F;接受ICMP包长度char* recvbuf &#x3D; new char[MAX_PING_PACKET_SIZE];unsigned int addr &#x3D; 0; &#x2F;&#x2F;IP地址long ThreadNumCounter &#x3D; 0, ThreadNumLimit &#x3D; 20;long* aa &#x3D; &ThreadNumCounter; &#x2F;&#x2F;填充ICMP包的函数void fill_icmp_data(char* icmp_data, int datasize){ IcmpHeader* icmp_hdr; char* datapart; icmp_hdr &#x3D; (IcmpHeader*)icmp_data; icmp_hdr-&gt;type &#x3D; ICMP_ECHO; &#x2F;&#x2F;设置信息类型 icmp_hdr-&gt;id &#x3D; (USHORT)GetCurrentThreadId(); &#x2F;&#x2F;设置当前线程的ID号 datapart &#x3D; icmp_data + sizeof(IcmpHeader); &#x2F;&#x2F;计算ICMP包数据部分 memset(datapart, ‘A’, datasize - sizeof(IcmpHeader));} &#x2F;&#x2F;解析IP地址的函数void decode_resp(char* buf, int bytes, struct sockaddr_in* from){ IpHeader* iphdr; IcmpHeader* icmphdr; unsigned short iphdrlen; iphdr &#x3D; (IpHeader*)buf; //跳过IP包头部 iphdrlen = iphdr-&gt;headlen * 4; icmphdr = (IcmpHeader*)(buf + iphdrlen); //数据包过短，丢弃 if (bytes &lt; iphdrlen + ICMP_MIN) &#123; return; &#125; //不是回送响应，丢弃 if (icmphdr-&gt;type != ICMP\\_ECHO\\_REPLY) &#123; return; &#125; //ID号不相符，丢弃 if (icmphdr-&gt;id != (USHORT)GetCurrentThreadId()) &#123; return; &#125; //输出处于活动状态的主机 cout &lt;&lt; &quot;活动主机: &quot; &lt;&lt; inet\\_ntoa(from-&gt;sin\\_addr) &lt;&lt; endl; } &#x2F;&#x2F;校验和计算函数USHORT checksum(USHORT* buffer, int size){ unsigned long cksum &#x3D; 0; while (size &gt; 1) { cksum +&#x3D; *buffer++; size -&#x3D; sizeof(USHORT); } if (size) { cksum +&#x3D; (UCHAR)buffer; } cksum &#x3D; (cksum &gt;&gt; 16) + (cksum &amp; 0xffff); cksum +&#x3D; (cksum &gt;&gt; 16); return (USHORT)(~cksum);} &#x2F;&#x2F;线程调用函数DWORD WINAPI FindIP(LPVOID pIPAddrTemp){ InterlockedIncrement(aa); char icmp\\_data\\[MAX\\_PACKET\\]; memset(icmp\\_data, 0, MAX\\_PACKET); int datasize = DEF\\_PACKET\\_SIZE; datasize += sizeof(IcmpHeader); //填充ICMP包 fill\\_icmp\\_data(icmp_data, datasize); ((IcmpHeader*)icmp_data)-&gt;checksum = 0; ((IcmpHeader*)icmp_data)-&gt;seq = 0; //计算校验和后填入 ((IcmpHeader*)icmp\\_data)-&gt;checksum = checksum((USHORT*)icmp\\_data, datasize); //发送ICMP包 int bwrote = sendto(sockRaw, icmp_data, datasize, 0, (struct sockaddr*)pIPAddrTemp, sizeof(dest)); int n = 0; if (bwrote == SOCKET_ERROR) &#123; if (WSAGetLastError() == WSAETIMEDOUT) &#123; cout &lt;&lt; &quot;time out&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Sendto failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl; ExitProcess(STATUS_FAILED); n = 1; &#125; if (WSAGetLastError() == WSAETIMEDOUT) &#123; cout &lt;&lt; &quot;Timed out&quot; &lt;&lt; endl; ExitProcess(STATUS_FAILED); n = 1; &#125; if (bwrote &lt; datasize) &#123; cout &lt;&lt; &quot;Wrote &quot; &lt;&lt; bwrote &lt;&lt; &quot; bytes&quot; &lt;&lt; endl; ExitProcess(STATUS_FAILED); n = 1; &#125; //接收ICMP包 int bread = recvfrom(sockRaw, recvbuf, MAX\\_PING\\_PACKET_SIZE, 0, (struct sockaddr*)&amp;from, &amp;fromlen); if (bread == SOCKET_ERROR) &#123; if (WSAGetLastError() == WSAETIMEDOUT) &#123; cout &lt;&lt; &quot;Timed out&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Recvfrom failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl; ExitProcess(STATUS_FAILED); n = 1; &#125; //去掉IP包头部，判断并输出IP地址 if (n == 0) &#123; decode_resp(recvbuf, bread, &amp;from); &#125; InterlockedDecrement(aa); return 0; } int main(int argc, char* argv[]){ &#x2F;&#x2F;检查输入命令格式 if (argc !&#x3D; 3) { cout &lt;&lt; “Please input command: ScanHost start_address end_address” &lt;&lt; endl; return 0; } //开始使用Ws2_32.dll if (WSAStartup(MAKEWORD(2, 1), &amp;wsaData) != 0) &#123; cout &lt;&lt; &quot;WSAStartup failed: &quot; &lt;&lt; GetLastError() &lt;&lt; endl; ExitProcess(STATUS_FAILED); &#125; //创建原始套接字 sockRaw = WSASocket(AF\\_INET, SOCK\\_RAW, IPPROTO\\_ICMP, NULL, 0, WSA\\_FLAG_OVERLAPPED); if (sockRaw == INVALID_SOCKET) &#123; cout &lt;&lt; &quot;WSASocket() failed: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl; ExitProcess(STATUS_FAILED); &#125; //设置接收延时 int timeout = 1000; int bread = setsockopt(sockRaw, SOL\\_SOCKET, SO\\_RCVTIMEO, (char*)&amp;timeout, sizeof(timeout)); if (bread == SOCKET_ERROR) &#123; cout &lt;&lt; &quot;Failed to set recv timeout: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl; ExitProcess(STATUS_FAILED); &#125; //设置发送延时 timeout = 1000; bread = setsockopt(sockRaw, SOL\\_SOCKET, SO\\_RCVTIMEO, (char*)&amp;timeout, sizeof(timeout)); if (bread == SOCKET_ERROR) &#123; cout &lt;&lt; &quot;Failed to set recv timeout: &quot; &lt;&lt; WSAGetLastError() &lt;&lt; endl; ExitProcess(STATUS_FAILED); &#125; //初始化地址结构 memset(&amp;dest, 0, sizeof(dest)); unsigned long startIP, endIP; dest.sin\\_family = AF\\_INET; dest.sin\\_addr.s\\_addr = inet_addr(argv\\[1\\]); startIP = inet_addr(argv\\[1\\]); end1.sin\\_family = AF\\_INET; end1.sin\\_addr.s\\_addr = inet_addr(argv\\[2\\]); endIP = inet_addr(argv\\[2\\]); HANDLE hThread; while (htonl(startIP) &lt;= htonl(endIP)) &#123; //判断线程数目 if (ThreadNumCounter &gt; ThreadNumLimit) &#123; Sleep(5000); continue; &#125; DWORD ThreadID; sockaddr\\_in * pIPAddrTemp = new(sockaddr\\_in); if (!pIPAddrTemp) &#123; cout &lt;&lt; &quot;Memory alloc failed&quot; &lt;&lt; endl; return 0; &#125; *pIPAddrTemp = dest; //创建新线程 clock_t start; start = clock(); hThread = CreateThread(NULL, NULL, FindIP, (LPVOID)pIPAddrTemp, NULL, &amp;ThreadID); long i = 60000000L; while (i--) ; TerminateThread(hThread, 0); InterlockedDecrement(aa); memset(&amp;from, 0, sizeof(from)); startIP = htonl(htonl(startIP) + 1); dest.sin\\_addr.s\\_addr = startIP; &#125; //是否有结束的线程 while (ThreadNumCounter != 0) &#123; Sleep(2000); return 0; &#125; system(&quot;pause&quot;); return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"网络安全","slug":"网络安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"C++扫描指定主机开放的端口","slug":"c-scan-specified-host-open-port","date":"2015-11-19T12:55:41.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"c-scan-specified-host-open-port.html","link":"","permalink":"https://baiyuan.wang/c-scan-specified-host-open-port.html","excerpt":"","text":"C++扫描指定主机开放的端口，OS提供了connect()系统调用，用于与远程主机某端口建立连接，如果远程主机该端口处于帧听状态，则connect()连接成功；否则说明该端口关闭。 &#x2F;&#x2F; ScanPorts.cpp : 定义控制台应用程序的入口点。&#x2F;&#x2F; #include “stdafx.h”#includeusing namespace std;#include&lt;WinSock2.h&gt;#pragma comment (lib,”ws2_32.lib”)#define STATUS_FALIED 0xFFFFunsigned long serverIP;long MaxThread &#x3D; 200;long ThreadCount &#x3D; 0;long *aa &#x3D; &ThreadCount; &#x2F;&#x2F;扫描端口的线程DWORD WINAPI ScanPort(LPVOID lpParam){ short Port &#x3D; (short)lpParam; InterlockedIncrement(aa); &#x2F;&#x2F;创建流式套接字 SOCKET sock &#x3D; socket(AF_INET, SOCK_STREAM,0); if (sock &#x3D;&#x3D; INVALID_SOCKET){ cout &lt;&lt; “创建套接字失败！” &lt;&lt; endl; return 0; &#125; else&#123; //填充服务器地址 sockaddr_in severAddr; severAddr.sin\\_family = AF\\_INET; severAddr.sin_port = htons(Port); severAddr.sin\\_addr.S\\_un.S_addr = serverIP; //判断此机器是否打开 connect(sock, (sockaddr*)&amp;severAddr, sizeof(severAddr)); struct fd_set write; FD_ZERO(&amp;write); FD_SET(sock, &amp;write); //初始化超时时间 struct timeval timeout; timeout.tv_sec = 100 / 1000; timeout.tv_usec = 0; if (select(0,NULL,&amp;write,NULL,&amp;timeout)&gt;0) &#123; cout &lt;&lt; Port &lt;&lt;&quot;,&quot;; &#125;; closesocket(sock); &#125; InterlockedDecrement(aa); return 0; } void main(int argc, char *argv[]){ if (argc !&#x3D; 2){ cout &lt;&lt; “请输入目的主机IP地址” &lt;&lt; endl; &#125; //建立与socket库的绑定 WSADATA WSAData; if (WSAStartup(MAKEWORD(2, 2), &amp;WSAData) != 0) &#123; cout &lt;&lt; &quot;WSAStartup falied!&quot; &lt;&lt; GetLastError() &lt;&lt; endl; ExitProcess(STATUS_FALIED); &#125; serverIP = inet_addr(argv\\[1\\]); cout &lt;&lt; &quot;下列端口已开放：&quot; &lt;&lt; endl; for (int i = 1; i &lt; 1024; i++)&#123; //超过最大允许线程数等待 while (ThreadCount &gt;= MaxThread) Sleep(10); //创建线程，扫描端口 DWORD ThreadID; CreateThread(NULL, 0, ScanPort, (LPVOID)new short(i), 0, &amp;ThreadID); &#125; //还有没有结束的线程，等待 while (ThreadCount&gt;0) Sleep(50); WSACleanup(); }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"网络安全","slug":"网络安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"C++解析ARP数据包（可选网卡）","slug":"c-resolution-arp-packets","date":"2015-11-17T07:47:29.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"c-resolution-arp-packets.html","link":"","permalink":"https://baiyuan.wang/c-resolution-arp-packets.html","excerpt":"","text":"在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。 每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。 本项目是基于win cap的，要想成功运行本代码，你需要下载安装win cap以及WpdPack并在visual studio中配置wincap的库。 &#x2F;&#x2F; ParseArp.cpp : 定义控制台应用程序的入口点。&#x2F;&#x2F; #include “stdafx.h”#include#include&lt;conio.h&gt;#include#include#include#include “pcap.h”#include&lt;winsock2.h&gt;using namespace std;#pragma comment(lib,”ws2_32.lib”)#pragma comment(lib,”wpcap.lib”)&#x2F;&#x2F;定义ARP包数据struct arppkt{ unsigned short hdtyp; &#x2F;&#x2F;硬件类型 unsigned short protyp; &#x2F;&#x2F;协议类型 unsigned char hdsize; &#x2F;&#x2F;硬件地址长度 unsigned char prosize; &#x2F;&#x2F;协议地址长度 unsigned short op; &#x2F;&#x2F;（操作类型）操作值: ARP&#x2F;RARP u_char smac[6]; &#x2F;&#x2F;源MAC地址 u_char sip[4]; &#x2F;&#x2F;源IP地址 u_char dmac[6]; &#x2F;&#x2F;目的MAC地址 u_char dip[4]; &#x2F;&#x2F;目的IP地址};void packet_handler(const pcap_pkthdr *header, const u_char *pkt_data, ostream&amp; out){ &#x2F;&#x2F;从ARP包中找到头部位置 arppkt* arph &#x3D; (arppkt *)(pkt_data + 14); &#x2F;&#x2F;输出源IP地址 for (int i &#x3D; 0; i&lt;3; i++) out &lt;&lt; int(arph-&gt;sip[i]) &lt;&lt; ‘.’; out.setf(ios::left); out &lt;&lt; setw(3) &lt;&lt; int(arph-&gt;sip[3]) &lt;&lt; “ “; out.unsetf(ios::left); &#x2F;&#x2F;输出源MAC地址 char oldfillchar &#x3D; out.fill(‘0’); out.setf(ios::uppercase); for (int i &#x3D; 0; i&lt;5; i++) out &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; int(arph-&gt;smac[i]) &lt;&lt; ‘-‘; out &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; int(arph-&gt;smac[5]) &lt;&lt; “ “; out.fill(oldfillchar); out.unsetf(ios::hex | ios::uppercase); &#x2F;&#x2F;输出目的IP地址 for (int i &#x3D; 0; i&lt;3; i++) out &lt;&lt; int(arph-&gt;dip[i]) &lt;&lt; ‘.’; out.unsetf(ios::left); out &lt;&lt; setw(3) &lt;&lt; int(arph-&gt;dip[3]) &lt;&lt; ‘ ‘; out.unsetf(ios::left); &#x2F;&#x2F;输出目的MAC地址 out.fill(‘0’); out.setf(ios::uppercase); for (int i &#x3D; 0; i&lt;5; i++) out &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; int(arph-&gt;dmac[i]) &lt;&lt; ‘-‘; out &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; int(arph-&gt;dmac[5]) &lt;&lt; “ “; out.fill(oldfillchar); out.unsetf(ios::hex | ios::uppercase); &#x2F;&#x2F;输出操作类型 out &lt;&lt; ntohs(arph-&gt;op) &lt;&lt; “ “; &#x2F;&#x2F;输出操作时间 time_t t; time(&amp;t); out &lt;&lt; ctime(&amp;t); out.fill(oldfillchar); out &lt;&lt; endl; }void main(int argc, char *argv[])&#x2F;&#x2F;命令行参数{ &#x2F;&#x2F;检查输入命令格式 if (argc !&#x3D; 2) { cout &lt;&lt; “Please input command: ParseArp output_file” &lt;&lt; endl; return; &#125; //初始化网络设备相关参数 pcap\\_if\\_t *alldevs; pcap\\_if\\_t *d; pcap_t *adhandle; char errbuf\\[PCAP\\_ERRBUF\\_SIZE\\]; u_int netmask; char packet_filter\\[\\] = &quot;ether proto \\\\\\arp&quot;; struct bpf_program fcode; struct pcap_pkthdr *header; const u\\_char *pkt\\_data; vector&lt;pcap\\_if\\_t* &gt; devices; vector&lt;pcap_t *&gt; adhandles; //获取网络设备列表 if (pcap_findalldevs(&amp;alldevs, errbuf) == -1) &#123; cout &lt;&lt; &quot;Error in pcap_find all devs:&quot; &lt;&lt; errbuf; return; &#125; //选取一个Ethernet网卡 for (d = alldevs; d!=NULL; d = d-&gt;next) &#123; // 网卡设为混杂模式，接收所有帧 if ((adhandle = pcap\\_open\\_live(d-&gt;name, 1000, 1, 300, errbuf)) == NULL) &#123; cout &lt;&lt; &quot;\\\\nUnable to open the adapter.&quot;; pcap_freealldevs(alldevs); return; &#125; //检查数据链路是否为Ethernet if (pcap\\_datalink(adhandle) == DLT\\_EN10MB&amp;&amp;d-&gt;addresses != NULL)&#123; devices.push_back(d); adhandles.push_back(adhandle); &#125; &#125; vector&lt;pcap\\_if\\_t *&gt;::iterator it; for (int i = 0; i &lt; devices.size(); i++) cout &lt;&lt; &quot;网卡：&quot; &lt;&lt; i + 1 &lt;&lt; &quot;:&quot; &lt;&lt; devices\\[i\\]-&gt;description &lt;&lt; endl; int i = 0; cout &lt;&lt; &quot;请输入网卡&quot;; cin &gt;&gt; i; //获得子网掩码 d = devices\\[i - 1\\]; netmask = ((sockaddr\\_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin\\_addr.S\\_un.S\\_addr; //编译过滤器，只捕获ARP包 if (pcap\\_compile(adhandles\\[i - 1\\], &amp;fcode, packet\\_filter, 1, netmask)&lt;0) &#123; cout &lt;&lt; &quot;\\\\nUnable to compile the packet filter.Check the syntax.\\\\n&quot;; pcap_freealldevs(alldevs); return; &#125; //设置过滤器 if (pcap_setfilter(adhandles\\[i - 1\\], &amp;fcode)&lt;0) &#123; cout &lt;&lt; &quot;\\\\nError setting the filter.\\\\n&quot;; pcap_freealldevs(alldevs); return; &#125; //显示提示信息及每项含义 cout &lt;&lt; &quot;listening on &quot; &lt;&lt; d-&gt;description &lt;&lt; &quot;...&quot; &lt;&lt; endl &lt;&lt; endl; ofstream fout(argv\\[1\\], ios::app); //日志记录文件 //为了查看日志时的方便，其中加入了日期记录 time_t t; time(&amp;t); fout.seekp(0, ios::end); if (fout.tellp()) fout &lt;&lt; endl; fout &lt;&lt; &quot;\\\\t\\\\tARP request(1)/reply(2) on&quot; &lt;&lt; ctime(&amp;t); cout &lt;&lt; &quot;Sour Ip Addr&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Sour MAC Address&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Des Ip Addr&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Des MAC Address&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;OP&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Time&quot; &lt;&lt; endl; fout &lt;&lt; &quot;Sour Ip Addr&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Sour MAC Address&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Des Ip Addr&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Des MAC Address&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;OP&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;Time&quot; &lt;&lt; endl; //释放设备列表 pcap_freealldevs(alldevs); //开始截获ARP包 int result; while ((result = pcap\\_next\\_ex(adhandles\\[i-1\\], &amp;header, &amp;pkt_data)) &gt;= 0) &#123; //循环解析ARP数据包 if (result == 0) continue; //解析ARP包，结果输出到屏幕与文件 packet\\_handler(header, pkt\\_data, cout); packet\\_handler(header, pkt\\_data, fout); &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"网络安全","slug":"网络安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"无向图个数最少且元素间不相连的子集","slug":"number-at-least-undirected-graph-elements-not-connected-subset-of","date":"2015-11-15T05:11:20.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"number-at-least-undirected-graph-elements-not-connected-subset-of.html","link":"","permalink":"https://baiyuan.wang/number-at-least-undirected-graph-elements-not-connected-subset-of.html","excerpt":"","text":"问题设给定一个任意的无向图，将图划分若干的子集，子集集合中任意俩个节点不相连，使用贪心算法使子集个数最少。 算法步骤或流程： 构造一个向量A按结点度大小加入。 构建向量B为空，B存储最后的结果，其元素为子集 取向量A的第一个元素m（即度最大）加入向量B，遍历B中的元素，如果m与B中元素（子集）中的元素都不相连，则加入到当前子集，如果相连则创建新子集。 将向量A中m除去，重新对向量A按度大小排序，重复3 C++代码#include#include using namespace std;#includevector &lt; vector &lt; int &gt;&gt;vec;const int size &#x3D; 5 ;char undirectedGraph[size][size];vector&lt;vector &gt; sortvector;vector &lt; vector &lt; int &gt;&gt;*getGreedySet(vector &lt; vector &lt; int &gt;*&gt;_vec, int n){ cout&lt;&lt;(char)(65 + n)&lt;&lt;endl; vector &lt; vector &lt; int &gt;&gt;::iterator it1; vector &lt; int &gt;::iterator it2; bool linkext &#x3D; false; for (it1 &#x3D; _vec-&gt;begin(); it1 !&#x3D; _vec-&gt;end(); it1++) &#x2F;&#x2F;外集合 { vector &lt; int &gt;*temp1 &#x3D; *it1; int link &#x3D; 0; for (it2 &#x3D; temp1-&gt;begin(); it2 !&#x3D; temp1-&gt;end(); it2++) { if (undirectedGraph[n][it2] &#x3D;&#x3D; ‘1’) { link++; break; }&#x2F;&#x2F; cout&lt;&lt;”(“&lt;&lt;*it2&lt;&lt;”,”&lt;&lt;n&lt;&lt;”)”; } if (link &#x3D;&#x3D; 0) { temp1-&gt;push_back(n); linkext &#x3D; true; break; &#125; &#125; if (!linkext) &#123; vector &lt; int &gt;*nodeset = new vector &lt; int &gt;(); nodeset-&gt;push_back(n); \\_vec-&gt;push\\_back(nodeset); &#125; return _vec; };int charToInt(char cr){ if(cr&#x3D;&#x3D;’1’) return 1; else return 0;} int getDegreeOfNode(int i){ int result&#x3D;0; for(int j&#x3D;i+1; j&lt;sortvector.size(); j++) { int x&#x3D;sortvector[i][1]; int y&#x3D;sortvector[j][1]; result+&#x3D;charToInt(undirectedGraph[x][y]); } for(int m=0; m&lt;i; m++) &#123; int x=sortvector\\[m\\]\\[1\\]; int y=sortvector\\[i\\]\\[1\\]; result+=charToInt(undirectedGraph\\[x\\]\\[y\\]); &#125; return result; } int getinitDegreeOfNode(int i){ int result&#x3D;0; for(int j&#x3D;i+1; j&lt;size; j++) result+&#x3D;charToInt(undirectedGraph[i][j]); for(int m&#x3D;0; m&lt;i; m++) result+&#x3D;charToInt(undirectedGraph[m][i]); return result;}bool greaterMark(vector a,vector b){ return a[0]&gt; b[0];} int main(){ vec &#x3D; new vector &lt; vector &lt; int &gt;*&gt;(); vector &lt; int &gt;nodeset &#x3D; new vector &lt; int &gt;(); vector &lt; vector &lt; int &gt;&gt;::iterator it1; vector &lt; int &gt;::iterator it2; cout &lt;&lt; “请输入无向图顶点连接情况：\\n(1表示连通，0表示未连通)” &lt;&lt; endl; cout &lt;&lt; “ &gt;”; for (int i &#x3D; 0; i &lt; size; i++) cout &lt;&lt; (char)(65 + i); cout &lt;&lt; endl; for (int i &#x3D; 0; i &lt; size; i++) { cout &lt;&lt; (char)(65 + i) &lt;&lt; “&gt;”; cin &gt;&gt; undirectedGraph[i]; &#125; for (int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; temp; temp.push_back(getinitDegreeOfNode(i)); temp.push_back(i); sortvector.push_back(temp); &#125; while(sortvector.size()&gt;0) &#123; std::sort(sortvector.begin(),sortvector.end(),greaterMark);//对无向图进行按照度大小排序 vec = getGreedySet(vec, sortvector\\[0\\]\\[1\\]); sortvector.erase(sortvector.begin()); int i=sortvector.size(); for(int j=0; j&lt;i; j++) sortvector\\[j\\]\\[0\\]=getDegreeOfNode(j); &#125; cout &lt;&lt; &quot;\\\\n个数最少且元素间不相连的子集有:&quot; &lt;&lt; endl; for (it1 = vec-&gt;begin(); it1 != vec-&gt;end(); it1++) &#123; vector &lt; int &gt;\\*temp1 = \\*it1; for (it2 = temp1-&gt;begin(); it2 != temp1-&gt;end(); it2++) cout &lt;&lt; (char)(65 + *it2); cout &lt;&lt; &quot; &quot;; &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"}]},{"title":"一瓶啤酒烫烫烫","slug":"bottle-of-beer-very-hot-hot-hot","date":"2015-11-01T14:36:58.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"bottle-of-beer-very-hot-hot-hot.html","link":"","permalink":"https://baiyuan.wang/bottle-of-beer-very-hot-hot-hot.html","excerpt":"","text":"现在网上很多人黑程序员，“只有程序员才能听懂的笑话”常常出现在朋友圈，各种娱乐化程序员，极客人有时候也表示很无辜。听人讲起下面这个程序员的笑话，逼格算是比较高了，哈哈！ 两个字符串走进酒吧。 第一个字符串对服务员说：“给我来一瓶啤酒烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫”。 “请原谅我的朋友，”第二个字符串说：“他忘了加\\0”。 初听这个所谓笑话的时候感觉莫名奇妙，直到昨天调代码遇到字符数组中出现的情况才明白了一二: 至于出现烫烫烫的原因，下面是从百度抠下来的解释： 在用VC写代码时，经常会遇到在栈中申请空间的并且没有被初始化的字符数组就会显示”烫烫烫烫。。。”，虽然是知道编译器对栈中没有初始化的数据会进行默认的初始化工作。如下面的代码： int main(void){ char x[4]; return 0;} 代码很简单，就是在栈中申请了一个大小为4个字节的字符数组。 用断点查看X的值，可以发现，“烫烫”出现了： x 0x0012ff60 “烫烫烫烫?\u0012” char [4] 查看反汇编： 1: int main(void) 2: {004113A0 55 push ebp004113A1 8B EC mov ebp,esp004113A3 81 EC CC 00 00 00 sub esp,0CCh004113A9 53 push ebx004113AA 56 push esi004113AB 57 push edi004113AC 8D BD 34 FF FF FF lea edi,[ebp-0CCh]004113B2 B9 33 00 00 00 mov ecx,33h004113B7 B8 CC CC CC CC mov eax,0CCCCCCCCh004113BC F3 AB rep stos dword ptr es:[edi] 3: char x[4]; 4: return 0;004113BE 33 C0 xor eax,eax 5: } 简单解释一下关键句的含义： 004113AC 8D BD 34 FF FF FF lea edi,[ebp-0CCh] 将获得的0CCh大小的栈空间首地址赋给edi 004113B2 B9 33 00 00 00 mov ecx,33h rep的循环次数为33h 004113B7 B8 CC CC CC CC mov eax,0CCCCCCCCh eax &#x3D; 0CCCCCCCCh 004113BC F3 AB rep stos dword ptr es:[edi] 将栈空间的33H个双字节赋值为0CCCCCCCCh 而0xcccc用汉语表示刚好就是“烫” oxcc正好是中断int 3的指令 起到保护作用 （参考：）在Debug 模式下，VC 会把未初始化的栈内存全部填成0xcc。会把未初始化的堆内存全部填成0xcd。但是Release 模式下不会有这种附加动作，原来那块内存里是什么就是什么。 未初始化的变量会被系统赋初值为0xCC,超过了ASCII码0-127这个范围，因此这个“字符串”被系统当成了宽字符组成的字符串，即两个字节数据组成一个字符，而0xCCCC表示的宽字符正好是乱码中的那个“烫”字。同理，0Xcdcd就是“屯”字。 ‘\\0’的含义‘\\0’在很多编程语言中代表着一段字符的结尾，编译器判断我们字符串到哪个地方结束都是根据’\\0’判断的，如果遇到’\\0’,就停止读取字符串，如果一直没有碰到’\\0’，会继续往下找。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"}]},{"title":"根据前中序遍历构建二叉树","slug":"according-former-in-sequence-traversal-in-building-binary-tree","date":"2015-11-01T08:16:01.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"according-former-in-sequence-traversal-in-building-binary-tree.html","link":"","permalink":"https://baiyuan.wang/according-former-in-sequence-traversal-in-building-binary-tree.html","excerpt":"","text":"根据前序遍历和中序遍历构建二叉树的基本思想是使用递归算法；首先构建根节点的左子树和右子树，而在构建根节点的左右子树的时候又要构建左右子树根节点的左右子树， 所以很容易想到递归算法；本项目构建二叉树的主要函数是CreateBinaryTree，其参数有char *preorder, char *inorder, int n，分别是当前构建二叉树的前序排列和中序排列和结点个数；直到构建的子二叉树中节点个数为零，即完成了递归。 根据前中序遍历构建二叉树&#x2F;&#x2F; BinaryTree.cpp : 定义控制台应用程序的入口点。&#x2F;&#x2F; #include “stdafx.h”#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#includeusing namespace std; template&#x2F;构建结构体二叉树结点，采用模板类T&#x2F;struct BinaryNode{ T data; BinaryNode *Lchild &#x3D; NULL, *Rchild &#x3D; NULL;}; int get_root_index(char *preorder, char *inorder, int n)&#x2F;&#x2F;返回根节点的序号{ int i; char ch; for (i &#x3D; 0, ch &#x3D; preorder[0]; i&lt;n; i++) if (inorder[i] &#x3D;&#x3D; ch) return i; return -1;}&#x2F;*递归产生前序序列和中序序列的二叉树*&#x2F;BinaryNode *CreateBinaryTree(char *preorder, char *inorder, int n){ if (n &#x3D;&#x3D; 0) return NULL; int root_val &#x3D; preorder[0]; int i &#x3D; get_root_index(preorder, inorder, n);&#x2F;&#x2F;获取根节点在中序遍历中的位置 BinaryNode*root &#x3D; (BinaryNode*)malloc(sizeof(BinaryNode)); root-&gt;data &#x3D; root_val; &#x2F;&#x2F;递归得到当前子树的左子树Lchild，Lchild的前序遍历起始位置为父树的preorder + 1 root-&gt;Lchild &#x3D; CreateBinaryTree(preorder + 1, inorder, i); root-&gt;Rchild &#x3D; CreateBinaryTree(preorder + i + 1, inorder + i + 1, n - i - 1);&#x2F;&#x2F;递归得到当前子输的右子树 return root;} &#x2F;使用递归前序遍历&#x2F;void postorder(BinaryNode *root){ if (root) { cout &lt;&lt; root-&gt;data ; postorder(root-&gt;Lchild); postorder(root-&gt;Rchild); &#125; }int main(){ char *preorder &#x3D; “ABCDEF”; char *inorder &#x3D; “BCAEDF”; int n &#x3D; strlen(preorder); BinaryNode *root &#x3D; CreateBinaryTree(preorder, inorder, n); postorder(root); printf(“\\n”); return 0;}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"递归","slug":"递归","permalink":"https://baiyuan.wang/tags/%E9%80%92%E5%BD%92/"}]},{"title":"汇编指令对应的英文单词","slug":"assembly-instruction-corresponding-english-words","date":"2015-10-16T13:21:18.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"assembly-instruction-corresponding-english-words.html","link":"","permalink":"https://baiyuan.wang/assembly-instruction-corresponding-english-words.html","excerpt":"","text":"学习汇编中碰到的很多命令书上都是强行给出，丝毫不讲命令用词的原由，命令究竟是哪个英文单词的缩写，这样记起来很是麻烦，现总结一下，以方便记忆。 一、寄存器类（register）： 通用寄存器:AX,BX,CX,DX——这几个没什么好写的，就是这样了。 段寄存器：代码段寄存器CS–code segment , 数据段寄存器DS–data segment , 堆栈段寄存器SS–stack segment ，附加段寄存器ES–extra segment 。 特殊功能寄存器：指令指针寄存器IP–instruction pointer ，堆栈指针SP–stack pointer ，基址指针BP–base pointer ，源变址寄存器SI–source index ，目标变址寄存器DI–destination index ，标志寄存器FR–flag register（或者叫程序状态字PSW–program status word）。 PSW常用的标志有： 标志 值为1时的标记 值为0时的标记 OF(overflow flag) OV(overflow) NV(not overflow) ZF(zero flag) ZR(zero) NZ(not zero) PF(parity flag) PE(parity even) PO(parity odd) CF(carry flag) CY(carried) NC(not carried) DF(direction flag) DN(down) UP(up) SF(sign flag) NG(negtive) PL(plus) TF(trap flag) IF(interrupt flag) AF(auxiliary flag) 命令类1.通用数据传送指令. MOV—-&gt; move MOVSX—-&gt;extended move with sign data MOVZX—-&gt;extended move with zero data PUSH—-&gt;push POP—-&gt;pop PUSHA—-&gt;push all POPA—-&gt;pop all PUSHAD—-&gt;push all data POPAD—-&gt;pop all data BSWAP—-&gt;byte swap XCHG—-&gt;exchange CMPXCHG—-&gt;compare and change XADD—-&gt;exchange and add XLAT—-&gt;translate 2.输入输出端口传送指令. IN—-&gt;input OUT—-&gt;output 3.目的地址传送指令. LEA—-&gt;load effective address LDS—-&gt;load DS LES—-&gt;load ES LFS—-&gt;load FS LGS—-&gt;load GS LSS—-&gt;load SS 4.标志传送指令. LAHF—-&gt;load AH from flag SAHF—-&gt;save AH to flag PUSHF—-&gt;push flag POPF—-&gt;pop flag PUSHD—-&gt;push dflag POPD—-&gt;pop dflag 二、算术运算指令 ADD—-&gt;add ADC—-&gt;add with carry INC—-&gt;increase 1 AAA—-&gt;ascii add with adjust DAA—-&gt;decimal add with adjust SUB—-&gt;substract SBB—-&gt;substract with borrow DEC—-&gt;decrease 1 NEC—-&gt;negative CMP—-&gt;compare AAS—-&gt;ascii adjust on substract DAS—-&gt;decimal adjust on substract MUL—-&gt;multiplication IMUL—-&gt;integer multiplication AAM—-&gt;ascii adjust on multiplication DIV—-&gt;divide IDIV—-&gt;integer divide AAD—-&gt;ascii adjust on divide CBW—-&gt;change byte to word CWD—-&gt;change word to double word CWDE—-&gt;change word to double word with sign to EAX CDQ—-&gt;change double word to quadrate word 三、逻辑运算指令 AND—-&gt;and OR—-&gt;or XOR—-&gt;xor NOT—-&gt;not TEST—-&gt;test SHL—-&gt;shift left SAL—-&gt;arithmatic shift left SHR—-&gt;shift right SAR—-&gt;arithmatic shift right ROL—-&gt;rotate left ROR—-&gt;rotate right RCL—-&gt;rotate left with carry RCR—-&gt;rotate right with carry 四、串指令 MOVS—-&gt;move string CMPS—-&gt;compare string SCAS—-&gt;scan string LODS—-&gt;load string STOS—-&gt;store string REP—-&gt;repeat REPE—-&gt;repeat when equal REPZ—-&gt;repeat when zero flag REPNE—-&gt;repeat when not equal REPNZ—-&gt;repeat when zero flag REPC—-&gt;repeat when carry flag REPNC—-&gt;repeat when not carry flag 五、程序转移指令——————————————————————————————————————— 1&gt;无条件转移指令(长转移) JMP—-&gt;jump CALL—-&gt;call RET—-&gt;return RETF—-&gt;return far 2&gt;条件转移指令(短转移,-128到+127的距离内) JAE—-&gt;jump when above or equal JNB—-&gt;jump when not below JB—-&gt;jump when below JNAE—-&gt;jump when not above or equal JBE—-&gt;jump when below or equal JNA—-&gt;jump when not above JG—-&gt;jump when greater JNLE—-&gt;jump when not less or equal JGE—-&gt;jump when greater or equal JNL—-&gt;jump when not less JL—-&gt;jump when less JNGE—-&gt;jump when not greater or equal JLE—-&gt;jump when less or equal JNG—-&gt;jump when not greater JE—-&gt;jump when equal JZ—-&gt;jump when has zero flag JNE—-&gt;jump when not equal JNZ—-&gt;jump when not has zero flag JC—-&gt;jump when has carry flag JNC—-&gt;jump when not has carry flag JNO—-&gt;jump when not has overflow flag JNP—-&gt;jump when not has parity flag JPO—-&gt;jump when parity flag is odd JNS—-&gt;jump when not has sign flag JO—-&gt;jump when has overflow flag JP—-&gt;jump when has parity flag JPE—-&gt;jump when parity flag is even JS—-&gt;jump when has sign flag 3&gt;循环控制指令(短转移) LOOP—-&gt;loop LOOPE—-&gt;loop equal LOOPZ—-&gt;loop zero LOOPNE—-&gt;loop not equal LOOPNZ—-&gt;loop not zero JCXZ—-&gt;jump when CX is zero JECXZ—-&gt;jump when ECX is zero 4&gt;中断指令 INT—-&gt;interrupt INTO—-&gt;overflow interrupt IRET—-&gt;interrupt return 5&gt;处理器控制指令 HLT—-&gt;halt WAIT—-&gt;wait ESC—-&gt;escape LOCK—-&gt;lock NOP—-&gt;no operation STC—-&gt;set carry CLC—-&gt;clear carry CMC—-&gt;carry make change STD—-&gt;set direction CLD—-&gt;clear direction STI—-&gt;set interrupt CLI—-&gt;clear interrupt 六、伪指令 ————————————————————————————————————— DW—-&gt;definw word PROC—-&gt;procedure ENDP—-&gt;end of procedure SEGMENT—-&gt;segment ASSUME—-&gt;assume ENDS—-&gt;end segment END—-&gt;end","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"百元百科","slug":"技术/百元百科","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"汇编","slug":"汇编","permalink":"https://baiyuan.wang/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"让博客插入的视频宽度自适应","slug":"let-blog-into-adaptive-video-width","date":"2015-10-14T13:53:24.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"let-blog-into-adaptive-video-width.html","link":"","permalink":"https://baiyuan.wang/let-blog-into-adaptive-video-width.html","excerpt":"","text":"好久没写技术类博文，这次暂且水一水上次在博客里发了一段个人制作的视频，使用的优酷提供的分享代码：就是一个embed视频标签，无奈优酷提供的代码视频长宽都是死的，600*400的样子，在电脑上还行，在手机上宽度太大直接撑爆了手机屏幕，用户体验很不好，下面的代码就是实现在不同设备自动适应宽度的。实现原理很简单，就是用js(jquery)动态设定视频的长宽度。 请将下面的代码加进主题的functions.php文件中，并且将代码中所有的#main-wrap-left换成显示文章的div的class名或者ID。 &#x2F;** * 视频比例 *&#x2F;function videoWidth(){ if (!wp_is_mobile()){ echo ‘' .'$(document).ready(function(){$(\\'embed\\').height($(\\'#main-wrap-left\\').width() * 0.6);' .'$(\\'embed\\').width($(\\'#main-wrap-left\\').width() * 0.8);});‘; }else{ echo ‘' .'$(document).ready(function(){$(\\'embed\\').height($(\\'#main-wrap-left\\').width() * 0.70);' .'$(\\'embed\\').width($(\\'#main-wrap-left\\').width() * 0.99);});‘; } }add_action ( ‘wp_footer’, ‘videoWidth’ );","categories":[{"name":"前端","slug":"前端","permalink":"https://baiyuan.wang/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"《让梦想去杭行》——视频作品","slug":"let-dream-hanghang-video-works","date":"2015-10-13T06:15:36.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"let-dream-hanghang-video-works.html","link":"","permalink":"https://baiyuan.wang/let-dream-hanghang-video-works.html","excerpt":"","text":"导语常常会想，我该如何面对大学生活？大学毕业，我是读研？工作？创业？ 面对就业，我想遇见怎样的自己？将来的公司，你想遇见怎样的我？ 你或许在知识的海洋之中废寝忘食，亦或在游戏的城堡之中昼夜厮杀； 我知道，大学中的你，虽然身在象牙塔，依旧对社会充满向往与彷徨。 九名成员，五个学院，带着你我心中共同的困惑 怀揣彼此不同的梦想，相聚在一起 从西安启航，前往杭州 让梦想去杭行 视频优酷链接：http://v.youku.com/v\\_show/id\\_XMTM0MzU0NzMzMg==.html 背景音乐：《Fly》、《Summer》 制作工具：使用PPT制作、edius剪辑 截图","categories":[{"name":"作品","slug":"作品","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旅行","slug":"旅行","permalink":"https://baiyuan.wang/tags/%E6%97%85%E8%A1%8C/"},{"name":"PPT","slug":"PPT","permalink":"https://baiyuan.wang/tags/PPT/"}]},{"title":"java中MD5 16和32位加密","slug":"in-java-md5-16-32-bit-encryption","date":"2015-10-04T14:57:26.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"in-java-md5-16-32-bit-encryption.html","link":"","permalink":"https://baiyuan.wang/in-java-md5-16-32-bit-encryption.html","excerpt":"","text":"java中MD5 16和32位加密，下面的Md5类中，通过构造函数Md5(String sourceStr)传入加密字符串，而get16和get32顾名思义是分别获取字符串的16位和32位MD5哈希值。Md5加密方式不能反向解密，任何一个字符串乃至一个超大文件都可以获得MD5值，并且是独一无二的。一个4G大的文件加密为一段32位字符串后，即使对文件改了哪怕一个字节，算出来的Md5和原文件的Md5都会有天壤之别，所以Md5算法常作为大文件完整性的校验。 在线Md5加密、“解密”网站网址：http://www.cmd5.com/ 需要指出的是，虽然Md5是难以解密的，但是由于同一字符串只能得到唯一的字符串，如果我们维护一个数据库记录下一些常用字符串的原值和Md5值，当输入的Md5能在数据库中找到记录的话，就能很快找到Md5值对应的原值。即所谓“解密”。 java中MD5 16和32位加密代码package cn.wangbaiyuan.toolsl;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException; &#x2F;** * Created by WBY on 2015&#x2F;10&#x2F;4. *&#x2F;public class Md5 { private String md5_32; private String md5_16;public Md5(String sourceStr){ String result &#x3D; “”; try { MessageDigest md &#x3D; MessageDigest.getInstance(“MD5”); md.update(sourceStr.getBytes()); byte b[] &#x3D; md.digest(); int i; StringBuffer buf &#x3D; new StringBuffer(“”); for (int offset &#x3D; 0; offset &lt; b.length; offset++) { i &#x3D; b[offset]; if (i &lt; 0) i +&#x3D; 256; if (i &lt; 16) buf.append(“0”); buf.append(Integer.toHexString(i)); } result &#x3D; buf.toString(); md5_32&#x3D;result; md5_16&#x3D; buf.toString().substring(8, 24); } catch (NoSuchAlgorithmException e) { System.out.println(e); }} public String get16(){ return md5_16; } public String get32(){ return md5_32; } }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"}]},{"title":"Android模拟点击按钮","slug":"click-on-button-android-simulation","date":"2015-10-02T06:57:23.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"click-on-button-android-simulation.html","link":"","permalink":"https://baiyuan.wang/click-on-button-android-simulation.html","excerpt":"","text":"在安卓开发过程中，常常会出现在不同的环境的情况下执行相同的操作，当然我们很容易想到的方法就是将相同的操作抽出来放在一个函数中，在执行相同或者类似的操作中只需要届时运行函数即可。如果执行的函数在不同的类或者activity(当然activity也是类)，我们只需要将函数的访问等级定义为public static即可。 上面的相信即使是最基础的开发者都知道，似乎极客人在此没有什么说的必要。在一个类A中调用另一个类B的公用静态方法b时，如果方法b中使用了类B的其他变量c、d、f等等，在修改方法b为公用静态时还要将类B的变量c、d、f一并修改为静态变量，因为静态方法不允许调用非静态变量，这一改往往牵一发而动全身。 有时候我们常常会恰巧遇到这种情况：类B中执行的操作就是点击Activity某一个按钮所进行的操作。比如我们在开发一个安卓app时常常有一个应用更新的功能，进入MainActivity时，app往往在后台神不知鬼不觉地执行一下检查更新的操作，同时在APP的“关于”页面我们还能让用户手动点击button然后“检查更新”。其实这两个检查更新的执行动作是一模一样的，如果重复写在两个Activity中将十分麻烦。，这个时候我们不妨尝试一下安卓按钮的模拟点击，实现代码模拟人手点击按钮。 代码：MainActivity.cancelButton.performClick(); 调用performClick()可引发 Click 事件","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"android控件","slug":"android控件","permalink":"https://baiyuan.wang/tags/android%E6%8E%A7%E4%BB%B6/"}]},{"title":"遭受恶意扫描下载zip攻击的惊险之旅","slug":"malware-scan-download-zip-attack-journey","date":"2015-09-20T06:15:58.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"malware-scan-download-zip-attack-journey.html","link":"","permalink":"https://baiyuan.wang/malware-scan-download-zip-attack-journey.html","excerpt":"","text":"最近王柏元的博客颇不宁静，昨天已经是阿里云第三次发送主机资源超标耗用导致网站强行停机了： 我们抱歉地通知您，由于超标消耗系统资源，您在万网购买的虚拟主机免费版类型主机产品qxu10******3已关停。 极客人无奈一次又一次手动重新启动主机，而阿里云免费主机一个月只能三次手动重启站点，这令我 是十分困惑。由于极客人使用的是阿里云免费虚拟主机，其配置都受到严格的限制，更自然不及一些独立的服务器，但是对小规模的博客网站还是绰绰有余的，而由于资源耗用过度这两个月才 出现的问题。而且这两个月我的网站访问量并没有比前几个月多出多少，而且还关闭了一些如百度云观测、神马搜索等机器人的访问，应该不存在访问量过多导致主机停机。所以资源超标耗用的问题着实 让我不解。 一、分析网站日志网站日志是访问者访问网站时，网站自动记录访问时间、访问者IP、UA、HTTP请求类型、请求网址、来源网址以及返回的状态码。 通过阿里云给我发送的通知邮件中的日期时间， 我找到了三次主机停机最后时刻的相关网站日志。除了第一次停机时的网站日志没有异常外，第二次和第三次停机时的情况竟然“神奇”般地雷同。 2015年9月19日14:10左右的网站日志118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:48 +0800] “HEAD &#x2F;wwwroot.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 533931118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:49 +0800] “HEAD &#x2F;wwwroot.zip HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu109*****53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 617184118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:49 +0800] “HEAD &#x2F;\\xd0\\xc2\\xbd\\xa8\\xce\\xc4\\xbc\\xfe\\xbc\\xd0.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 756708118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:50 +0800] “HEAD &#x2F;\\xd0\\xc2\\xbd\\xa8\\xce\\xc4\\xbc\\xfe\\xbc\\xd0.zip HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 672073118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:51 +0800] “HEAD &#x2F;www.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 572326118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:51 +0800] “HEAD &#x2F;wwwroot.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 723013118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:51 +0800] “HEAD &#x2F;wwwroot.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 784105118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:51 +0800] “HEAD &#x2F;wwwroot.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 769630118.247.126.9 - - [19&#x2F;Sep&#x2F;2015:14:10:51 +0800] “HEAD &#x2F;www.zip HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 995755 2015年9月17日18:10左右的网站日志118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:14 +0800] “HEAD &#x2F;baiyuan.wang.zip HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 1230526118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:14 +0800] “HEAD &#x2F;web.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 1296668118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:14 +0800] “HEAD &#x2F;wangbaiyuan_cn.rar HTTP&#x2F;1.1” 404 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 1433144118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:14 +0800] “HEAD &#x2F;baiyuan.wang.rar HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 1437490118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:13 +0800] “HEAD &#x2F;web.rar HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 2025751118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:14 +0800] “HEAD &#x2F;baiyuan.wang.zip HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 1475292118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:15 +0800] “HEAD &#x2F;web.zip HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 95449118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:15 +0800] “HEAD &#x2F;web.zip HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 147265118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:15 +0800] “HEAD &#x2F;web.rar HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 609414118.247.58.74 - - [17&#x2F;Sep&#x2F;2015:18:10:15 +0800] “HEAD &#x2F;baiyuan.wang.zip HTTP&#x2F;1.1” 500 - “-“ “Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident&#x2F;4.0)” qxu10******53.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu10******53&#x2F;htdocs&#x2F;index.php” 379669 通过网站日志可以找到一下规律： 请求方式为HTTP head; 请求极其密集（9月17号在一分半内请求523次；9月19号在一分钟内请求424次） 主机崩溃最后一刻返回状态码:500(服务器内部错误) 请求文件类型为zip压缩文件，为www,web,wwwrroot等看似没有规律的文件名 二、我的分析结论HEAD为http中像GET、POST一样的请求方式，与GET不同的是：客户端向服务器发送HEAD请求。服务器只会返回页面的head头部部分，这就比请求页面主体部分快得多。 上面网站日志记录的IP显然是通过HEAD扫描我的网站根目录中可能的zip文件，通过HTTP状态码，攻击者就可以知道它随机扫描的zip文件是否存在，如果存在的话就进行下载。当然，日志中清一色的404（请求的资源不存在）说明攻击者并没有得逞：获取我网站上“他想要”的zip压缩文件。这让我虚惊一场，然后，密集的请求却导致了我主机耗用资源超标。 可能你认为即使下载几个zip文件并无大碍，但是可以发现攻击者想要下载的zip文件名看似随机其实大有文章。 web、wwwroot、www是网站根目录常见用名，包括极客人在内的广大站长可能经常会将自己网站上的文件进行定期备份：全选然后压缩。就像在 计算机上压缩几个文件夹或文件一样，创建的压缩文件名往往和根目录相同。所以攻击者恶意遍历可能的 根目录名.zip，然后试图下载你的网站备份文件。而以wordpress建站系统为例，你的备份文件中的某些文件（wp-config.php）就记录了你的FTP和数据库密码，可以说，知道了FTP和数据库密码，你的网站意味着全线沦陷。 三、采取防治措施1、禁止请求zip等压缩文件由于虚拟主机的权限有限，我们控制用户访问行为最高效的就是在htaccess添加相关规则了，禁止请求zip等压缩文件的规则如下，请在： &lt;FilesMatch (.*)\\.(zip|rar|gz)$&gt;order allow,denydeny from all 上述规则会禁止请求zip\\rar\\gz格式的压缩文件。 2、处理head请求head请求在http请求中并不常用，我们完全可以禁止这种请求方式： RewriteEngine On RewriteCond %{REQUEST_METHOD} HEAD RewriteRule (.*) http://baidu.com \\[R=301,L\\] 上述规则会导致不管head方式请请求什么，都会重写到百度首页，要下载就去下载百度首页吧！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"}]},{"title":"phinx数据库查询-Phinx教程(3)","slug":"3-phinx-database-query-phinx-tutorial","date":"2015-08-28T08:20:41.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"3-phinx-database-query-phinx-tutorial.html","link":"","permalink":"https://baiyuan.wang/3-phinx-database-query-phinx-tutorial.html","excerpt":"","text":"执行查询Phinx进行数据库查询可以执行 execute()和 query()方法。 execute()方法返回的是执行数据库查询时数据库受影响的行数，而 query()方法返回的结果是一个数组。 execute('DELETE FROM users'); // returns the number of affected rows // query() $rows = $this->query('SELECT * FROM users'); // returns the result as an array } /\\*\\* \\* Migrate Down. */ public function down() { } } 注意:这些命令运行基于使用PHP数据对象(PDO) 扩展，它定义了一个轻量级的、一致的接口在PHP中访问数据库。总是确保你的查询与之前使用pdo同在 execute()命令。这是特别重要的在使用分隔符在插入的存储过程或触发器不支持分隔符。 ### 获取行 phinx有两种方法可以获取行：fetchRow()方法将获取单个行,而 fetchAll()方法将返回多行。这两种方法都接受原生的SQL语句作为他们唯一的参数。 fetchRow('SELECT * FROM users'); // fetch an array of messages $rows = $this->fetchAll('SELECT * FROM messages'); } /\\*\\* \\* Migrate Down. */ public function down() { } } 处理数据表 ----- ### 表对象 表对象是一个Phinx提供最有用的的api。它允许您使用PHP代码轻松操纵数据库表。您可以通过table()方法对表对象进行实例化，从而实现数据库迁移。 table('tableName'); } /\\*\\* \\* Migrate Down. */ public function down() { } } 然后您可以使用表对象提供方法来操纵这个表: ### 创建表 使用表对象创建一个表十分简单，以下举例创建一个表来存储用户: table('users'); $users->addColumn('username', 'string', array('limit' => 20)) ->addColumn('password', 'string', array('limit' => 40)) ->addColumn('password_salt', 'string', array('limit' => 40)) ->addColumn('email', 'string', array('limit' => 100)) ->addColumn('first_name', 'string', array('limit' => 30)) ->addColumn('last_name', 'string', array('limit' => 30)) ->addColumn('created', 'datetime') ->addColumn('updated', 'datetime', array('null' => true)) ->addIndex(array('username', 'email'), array('unique' => true)) ->save(); } /\\*\\* \\* Migrate Down. */ public function down() { } } * 添加列:addColumn()方法； * 添加索引:addIndex()方法：上面使用用户名和电子邮件来创建一个惟一索引列，最后调用save()将更改提交到数据库。 * 注意：Phinx自动为每个表创建一个名为“id”的自增列作为主键。 我们也可以使用表对象自行指定一个主键。一下代码会禁用Phinx自动生成 “id”的自增列作为主键，并使用其中 的两列创建一个主键: table('followers', array('id' => false, 'primary\\_key' => array('user\\_id', 'follower_id'))); $table->addColumn('user_id', 'integer') ->addColumn('follower_id', 'integer') ->addColumn('created', 'datetime') ->save(); } /\\*\\* \\* Migrate Down. */ public function down() { } } 若设置一个 primary\\_key但不使用自增属性 AUTO\\_INCREMENT，需要指定一个id来覆盖默认的 id字段名: table('followers', array('id' => 'user_id')); $table->addColumn('user_id', 'integer') ->addColumn('follower_id', 'integer') ->addColumn('created', 'datetime', array('default' => 'CURRENT_TIMESTAMP')) ->save(); } /\\*\\* \\* Migrate Down. */ public function down() { } } ### 有效的列数据类型 列属性的数据类型指定为字符串，可以下列类型之一: * biginteger * binary * boolean * date * datetime * decimal * float * integer * string * text * time * timestamp * uuid 此外，MySQL还支持 enum和 set列类型，Postgres支持 json和 jsonb列类型(PostgreSQL 9.3及以上)。 ### 判断是否存在一个表： hasTable() hasTable('users'); if ($exists) { // do something } } /\\*\\* \\* Migrate Down. */ public function down() { } } ### 删除表 使用 dropTable()方法，同时你最好在 down()方法写上如何再重新创建此表（极客人注：便于后续向下迁移恢复）。 dropTable('users'); } /\\*\\* \\* Migrate Down. */ public function down() { $users = $this->table('users'); $users->addColumn('username', 'string', array('limit' => 20)) ->addColumn('password', 'string', array('limit' => 40)) ->addColumn('password_salt', 'string', array('limit' => 40)) ->addColumn('email', 'string', array('limit' => 100)) ->addColumn('first_name', 'string', array('limit' => 30)) ->addColumn('last_name', 'string', array('limit' => 30)) ->addColumn('created', 'datetime') ->addColumn('updated', 'datetime', array('null' => true)) ->addIndex(array('username', 'email'), array('unique' => true)) ->save(); } } ### 重命名表 重命名表通过访问表对象的一个实例,然后调用 rename()方法实现。 table('users'); $table->rename('legacy_users'); } /\\*\\* \\* Migrate Down. */ public function down() { $table = $this->table('legacy_users'); $table->rename('users'); } } 使用列 --- ### 得到一个列列表：getColumns()方法 要检索所有表列，可以简单地创建一个表对象然后调用getColumns()方法，该方法将返回一个数组。例子如下: table('users')->getColumns(); ... } /\\*\\* \\* Migrate Down. */ public function down() { ... } } ### 检查是否存在一个列：hasColumn()方法 你可以使用 hasColumn()方法检查是否存在某一列。 table('user'); $column = $table->hasColumn('username'); if ($column) { // do something } } } ### 重命名一个列: renameColumn() 访问表对象的一个实例，然后调用 renameColumn()方法。 table('users'); $table->renameColumn('bio', 'biography'); } /\\*\\* \\* Migrate Down. */ public function down() { $table = $this->table('users'); $table->renameColumn('biography', 'bio'); } } ### 有顺序添加列 要想在一个列后跟着添加一个新列，使用 after选项来实现。 table('users'); $table->addColumn('city', 'string', array('after' => 'email')) ->update(); } } ### 删除一个列: removeColumn()方法 table('users'); $table->removeColumn('short_name') ->update(); } } ### 设定列属性限制 可以使用 limit选项限制列的最大长度: table('tags'); $table->addColumn('short_name', 'string', array('limit' => 30)) ->update(); } } 使用索引 ---- 添加一个索引表您可以简单地调用表对象的 addIndex()方法。 table('users'); $table->addColumn('city', 'string') ->addIndex(array('city')) ->save(); } /\\*\\* \\* Migrate Down. */ public function down() { } } 默认情况下Phinx会让_数据库_适配器创建一个正常的索引。我们也可以通过一个额外的参数 addIndex()方法来指定一个唯一的索引。 table('users'); $table->addColumn('email', 'string') ->addIndex(array('email'), array('unique' => true)) ->save(); } /\\*\\* \\* Migrate Down. */ public function down() { } } 删除多个索引调用 removeIndex()方法，你必须为每个索引调用这个方法。 table('users'); $table->removeIndex(array('email')); } /\\*\\* \\* Migrate Down. */ public function down() { } } 请注意： 当使用方法 removeIndex()，不需要再调用 save()，索引会在方法执行后立即删除。 操作外键 ---- Phinx支持创建外键来约束你的数据库表。以下为添加外键的一个例子 table('tags'); $table->addColumn('tag_name', 'string') ->save(); $refTable = $this->table('tag_relationships'); $refTable->addColumn('tag_id', 'integer') ->addForeignKey('tag\\_id', 'tags', 'id', array('delete'=> 'SET\\_NULL', 'update'=> 'NO_ACTION')) ->save(); } /\\*\\* \\* Migrate Down. */ public function down() { } } “删除”和“更新”操作定义的“删除”和“更新”选项数组。可能性值“SET\\_NULL”,“NO\\_ACTION”、“级联”和“限制”。 我们也可以轻松地检查是否存在外键: table('tag_relationships'); $exists = $table->hasForeignKey('tag_id'); if ($exists) { // do something } } /\\*\\* \\* Migrate Down. */ public function down() { } } 最后删除外键使用 dropForeignKey方法。 table('tag_relationships'); $table->dropForeignKey('tag_id'); } /\\*\\* \\* Migrate Down. */ public function down() { } }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Phinx","slug":"Phinx","permalink":"https://baiyuan.wang/tags/Phinx/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"翻译文章","slug":"翻译文章","permalink":"https://baiyuan.wang/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"}]},{"title":"androidStudio获取应用签名并复制","slug":"signature-copy-androidstudio-access-applications","date":"2015-08-25T12:47:56.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"signature-copy-androidstudio-access-applications.html","link":"","permalink":"https://baiyuan.wang/signature-copy-androidstudio-access-applications.html","excerpt":"","text":"在eclipse写安卓软件中，构建应用并签名时，控制台会生成应用签名MD5、SHA1、SHA256；但是在android Studio对安卓应用签名完毕后并没有出现应用的签名MD5、SHA1、SHA256。我们可以在命令指示符中输入以下命令： keytool -list -v -keystore “F:\\文档\\我的软件\\xintranslate.jks” keytool是JDK里面的程序，因为如果你已经配置好Java的环境变量，所以命令指示符窗口可以直接运行keytool命令；其中”F:\\文档\\我的软件\\xintranslate.jks”是应用的key store文件。 但是，在命令指示符中的应用签名并不能复制出来，在一些开发者平台提交应用时有的还需要填写应用签名。冗长的签名如果是照着命令行窗口逐字打上去将相当鸡肋。 其实Android Studio集成了命令行窗口，我们完全不用在系统的命令行窗口输入上述命令， 并且，在android studio中输入的命令结果支持复制粘贴，就不用我们自己照着命令行敲出来了。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://baiyuan.wang/tags/Android-Studio/"}]},{"title":"【译】Phinx的介绍与安装-Phinx教程(1)","slug":"translation-phinx-introduction-installation-phinx-tutorial-1","date":"2015-08-24T02:38:17.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"translation-phinx-introduction-installation-phinx-tutorial-1.html","link":"","permalink":"https://baiyuan.wang/translation-phinx-introduction-installation-phinx-tutorial-1.html","excerpt":"","text":"本文由极客人原创翻译自：http://phinx.readthedocs.org，不周之处，敬请指正；系列文章请访问王柏元的博客Phinx标签页或者用极客搜搜索：Phinx 获取所有文章目录 介绍一个训练有素的开发者，善于使用SCM系统（Software configuration management ：软件配置管理）对其程序代码进行版本控制；那么，为什么他们不使用相同的方式对数据库进行版本控制呢? Phinx允许开发者一种清晰、简洁的方式来修改和操作数据库，依托Phinx提供了一个强大的API，你无需手工编写SQL，而是使用PHP代码来创建代码迁移。然后开发者可以使用他们喜欢的SCM来进行代码迁移。这使得Phinx代码迁移可以移植于不同数据库系统之间。Phinx会对已经进行过的代码迁移进行跟踪，这样你就可以少担心数据库的状态,而是专注于开发更好的软件。 目标开发Phinx的目的如下： 在常用数据库厂商之间轻松移植。 与PHP开发框架独立。 安装过程简单。 有一套易于使用的命令行操作。 与其他PHP工具(Phing、PHPUnit))和web框架集成使用。 安装Phinx需要使用Composer进行安装，Composer 是 PHP 用来管理依赖(dependency)关系的工具。你可以在自己的项目中声明所依赖的外部工具库(libraries),Composer 会帮你安装这些依赖的库文件。详情可参考Composer官网 注意： Phinx最低支持PHP5.3.2版本。 安装Phinx，仅仅需要使用composer工具即可:执行下面命令进行安装（运行PHP命令需要自行配置好PHP环境变量，在环境变量path中加入PHP安装根目录）： php composer.phar require robmorgan&#x2F;phinx 然后运行composer: php composer.phar install –no-dev 在您的项目中创建一个有可写权限的文件夹 migrations来存放迁移文件，然后在您的项目文件夹下执行命令： php vendor&#x2F;bin&#x2F;phinx ini","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Phinx","slug":"Phinx","permalink":"https://baiyuan.wang/tags/Phinx/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"翻译文章","slug":"翻译文章","permalink":"https://baiyuan.wang/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"Android(Java)解析有道翻译API-Json数据","slug":"android-java-parsing-api-youdao-translation-json-data","date":"2015-08-24T00:14:18.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-java-parsing-api-youdao-translation-json-data.html","link":"","permalink":"https://baiyuan.wang/android-java-parsing-api-youdao-translation-json-data.html","excerpt":"","text":"由于百度翻译、有道翻译等翻译服务都开放了自己的API，开发者可以使用它们提供的API很简单就能开发出自己的翻译软件。自己开发的软件可能在功能上不及它们强大，但是翻译的结果是一样的，同时不会内置其它偷跑流量的进程，同时界面也相对简洁，随心所欲地进行修改。 首先在有道API进行申请API ID和KEY后，将下列程序中clientID和clientSecret替换为ID和KEY，通过GET请求获得字符串进行解析。下面是我使用java解析JSON数据的代码： Android(Java)解析有道翻译API-Json数据private String clientID&#x3D;”你在有道API申请的ID”;private String clientSecret&#x3D;”你在有道API申请的密钥”;Handler errHander &#x3D; new Handler() { @Override public void handleMessage(Message msg) { String notice &#x3D; “”; switch (msg.what) { case 20: notice &#x3D; “要翻译的文本过长”; break; case 30: notice &#x3D; “无法进行有效的翻译”; break; case 40: notice &#x3D; “不支持的语言类型”; break; case 50: notice &#x3D; “无效的key”; break; case 60: notice &#x3D; “无词典结果”; break; } Toast.makeText(MainActivity.this, notice, Toast.LENGTH_SHORT); } }; Handler hander &#x3D; new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 0x123) &#123; toString.setText(reply); &#125; else if (msg.what == 0x124) &#123; Toast.makeText(MainActivity.this, &quot;查询失败，请检查联网&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;; private Runnable askForYouDao = new Runnable() &#123; @Override public void run() &#123; try &#123; String url_path = &quot;http://fanyi.youdao.com/openapi.do?keyfrom=&quot; + clientID \\+ &quot;&amp;key=&quot; + clientSecret + &quot;&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=&quot; \\+ URLEncoder.encode(keywords, &quot;utf8&quot;); URL getUrl = new URL(url_path); HttpURLConnection connection = (HttpURLConnection) getUrl.openConnection(); connection.setConnectTimeout(3000); connection.connect(); BufferedReader replyReader = new BufferedReader( new InputStreamReader(connection.getInputStream(), &quot;utf-8&quot;));//约定输入流的编码 reply = replyReader.readLine(); JSONObject replyJson = new JSONObject(reply); String errorCode = replyJson.getString(&quot;errorCode&quot;); if (errorCode.equals(&quot;0&quot;)) &#123; String query = replyJson.getString(&quot;query&quot;); JSONArray translation = replyJson.has(&quot;translation&quot;) ? replyJson.getJSONArray(&quot;translation&quot;) : null; JSONObject basic = replyJson.has(&quot;basic&quot;) ? replyJson.getJSONObject(&quot;basic&quot;) : null; JSONArray web = replyJson.has(&quot;web&quot;) ? replyJson.getJSONArray(&quot;web&quot;) : null; String phonetic=null; String uk_phonetic=null; String us_phonetic=null; JSONArray explains=null; if(basic!=null)&#123; phonetic=basic.has(&quot;phonetic&quot;)? basic.getString(&quot;phonetic&quot;):null; uk_phonetic=basic.has(&quot;uk-phonetic&quot;)? basic.getString(&quot;uk-phonetic&quot;):null; us_phonetic=basic.has(&quot;us-phonetic&quot;)? basic.getString(&quot;us-phonetic&quot;):null; explains=basic.has(&quot;explains&quot;)? basic.getJSONArray(&quot;explains&quot;):null; &#125; &#x2F;&#x2F; if(web!&#x3D;null){&#x2F;&#x2F; JSONArray webs&#x3D;web.getJSONObject()&#x2F;&#x2F; } String translationStr&#x3D;””; if(translation!&#x3D;null){ translationStr&#x3D;”\\n翻译：\\n”; for(int i&#x3D;0;i&lt;translation.length();i++){ translationStr+&#x3D;”\\t【”+(i+1)+”】”+translation.getString(i)+”\\n”; } } String phoneticStr&#x3D;(phonetic!&#x3D;null? “\\n发音：”+phonetic:””) +(uk_phonetic!&#x3D;null? “\\n英式发音：”+uk_phonetic:””) +(us_phonetic!&#x3D;null? “\\n美式发音：”+us_phonetic:””); String explainStr&#x3D;””; if(explains!&#x3D;null){ explainStr&#x3D;”\\n\\n释义：\\n”; for(int i&#x3D;0;i&lt;explains.length();i++){ explainStr+&#x3D;”\\t【”+(i+1)+”】”+explains.getString(i)+”\\n”; } } reply=&quot;原文：&quot;+query+&quot;\\\\n&quot;+translationStr+phoneticStr+explainStr; hander.sendEmptyMessage(0x123); &#125; else &#123; &#x2F;&#x2F; Message errorMsg&#x3D;new Message(); int what &#x3D; Integer.parseInt(errorCode);&#x2F;&#x2F; errorMsg.what&#x3D;what; errHander.sendEmptyMessage(what); } &#125; catch (Exception e) &#123; Log.e(&quot;errss&quot;, e.getMessage()); hander.sendEmptyMessage(0x124); &#125; &#125; &#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"json","slug":"json","permalink":"https://baiyuan.wang/tags/json/"},{"name":"在线应用","slug":"在线应用","permalink":"https://baiyuan.wang/tags/%E5%9C%A8%E7%BA%BF%E5%BA%94%E7%94%A8/"}]},{"title":"Android开发权限大全","slug":"android-development-authority-books","date":"2015-08-23T12:27:18.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-development-authority-books.html","link":"","permalink":"https://baiyuan.wang/android-development-authority-books.html","excerpt":"","text":"在安卓开发中，应用在访问手机硬件资源如SD读写、网络访问、定位、调用摄像头，或者联系人、打电话等系统服务时都要向android系统申请权限。权限机制有利于保护使用者的手机安全。曾经碰到许多木马软件在后台给你发短信，神不知鬼不觉就扣了话费。这种木马软件能发送短信的前提就是向android系统申请了发送短信的权限。现在许多的安全软件都有禁止应用权限的功能，即使 手机应用在申请了访问一些手机资源的权限也可以强行禁止访问。 对于开发者，为应用申请权限的方法就是在项目清单文件中添加如： 下面是安卓开发应用权限大全： Android开发权限大全访问登记属性 android.permission.ACCESS_CHECKIN_PROPERTIES ，读取或写入登记check-in数据库属性表的权限 获取错略位置 android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米 获取精确位置 android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内 访问定位额外命令 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS，允许程序访问额外的定位提供者指令 获取模拟定位信息 android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用 获取网络状态 android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效 访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 获取WiFi状态 android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息 账户管理 android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 验证账户 android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 电量统计 android.permission.BATTERY_STATS，获取电池电量统计信息 绑定小插件 android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 绑定设备管理 android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用 绑定输入法 android.permission.BIND_INPUT_METHOD ，请求InputMethodService服务，只有系统才能使用 绑定RemoteView android.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用 绑定壁纸 android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用 使用蓝牙 android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备 蓝牙管理 android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备 变成砖头 android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头 应用删除时广播 android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播 收到短信时广播 android.permission.BROADCAST_SMS，当收到短信时触发一个广播 连续广播 android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播 WAP PUSH广播 android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播 拨打电话 android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码 通话权限 android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面 拍照权限 android.permission.CAMERA，允许访问摄像头进行拍照 改变组件状态 android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态 改变配置 android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位 改变网络状态 android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网 改变WiFi多播状态 android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态 改变WiFi状态 android.permission.CHANGE_WIFI_STATE，改变WiFi状态 清除应用缓存 android.permission.CLEAR_APP_CACHE，清除应用缓存 清除用户数据 android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据 底层访问权限 android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息 手机优化大师扩展权限 android.permission.CELL_PHONE_MASTER_EX，手机优化大师扩展权限 控制定位更新 android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变 删除缓存文件 android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件 删除应用 android.permission.DELETE_PACKAGES，允许程序删除应用 电源管理 android.permission.DEVICE_POWER，允许访问底层电源管理 应用诊断 android.permission.DIAGNOSTIC，允许程序到RW到诊断资源 禁用键盘锁 android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁 转存系统信息 android.permission.DUMP，允许程序获取系统dump信息从系统服务 状态栏控制 android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏 工厂测试模式 android.permission.FACTORY_TEST，允许程序运行工厂测试模式 使用闪光灯 android.permission.FLASHLIGHT，允许访问闪光灯 强制后退 android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层 访问账户Gmail列表 android.permission.GET_ACCOUNTS，访问GMail账户列表 获取应用大小 android.permission.GET_PACKAGE_SIZE，获取应用的文件大小 获取任务信息 android.permission.GET_TASKS，允许程序获取当前或最近运行的应用 允许全局搜索 android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能 硬件测试 android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试 注射事件 android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流 安装定位提供 android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供 安装应用程序 android.permission.INSTALL_PACKAGES，允许程序安装应用 内部系统窗口 android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限 访问网络 android.permission.INTERNET，访问网络连接，可能产生GPRS流量 结束后台进程 android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程 管理账户 android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表 管理程序引用 android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统 高级权限 android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限 社区权限 android.permission.MTWEAK_FORUM，允许使用mTweak社区权限 软格式化 android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息 修改声音设置 android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息 修改电话状态 android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面 格式化文件系统 android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡 挂载文件系统 android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统 允许NFC通讯 android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持 永久Activity android.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除 处理拨出电话 android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话 读取日程提醒 android.permission.READ_CALENDAR，允许程序读取用户的日程信息 读取联系人 android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息 屏幕截图 android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图 读取收藏夹和历史记录 com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录 读取输入状态 android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统 读取系统日志 android.permission.READ_LOGS，读取系统底层日志 读取电话状态 android.permission.READ_PHONE_STATE，访问电话状态 读取短信内容 android.permission.READ_SMS，读取短信内容 读取同步设置 android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置 读取同步状态 android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态 重启设备 android.permission.REBOOT，允许程序重新启动设备 开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行 接收彩信 android.permission.RECEIVE_MMS，接收彩信 接收短信 android.permission.RECEIVE_SMS，接收短信 接收Wap Push android.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息 录音 android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克 排序系统任务 android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务 结束系统任务 android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃 发送短信 android.permission.SEND_SMS，发送短信 设置Activity观察其 android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试 设置闹铃提醒 com.android.alarm.permission.SET_ALARM，设置闹铃提醒 设置总是退出 android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出 设置动画缩放 android.permission.SET_ANIMATION_SCALE，设置全局动画缩放 设置调试程序 android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发 设置屏幕方向 android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用 设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍 设置进程限制 android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制 设置系统时间 android.permission.SET_TIME，设置系统时间 设置系统时区 android.permission.SET_TIME_ZONE，设置系统时区 设置桌面壁纸 android.permission.SET_WALLPAPER，设置桌面壁纸 设置壁纸建议 android.permission.SET_WALLPAPER_HINTS，设置壁纸建议 发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号 状态栏控制 android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏 访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库 写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库 显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口 更新设备状态 android.permission.UPDATE_DEVICE_STATS，更新设备状态 使用证书 android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager 使用SIP视频 android.permission.USE_SIP，允许程序使用SIP视频服务 使用振动 android.permission.VIBRATE，允许振动 唤醒锁定 android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行 写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置 写入日程提醒 android.permission.WRITE_CALENDAR，写入日程，但不可读取 写入联系人 android.permission.WRITE_CONTACTS，写入联系人，但不可读取 写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件 写入Google地图数据 android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据 写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取 读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项 读写系统设置 android.permission.WRITE_SETTINGS，允许读写系统设置项 编写短信 android.permission.WRITE_SMS，允许编写短信 写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"androidStudio开发安卓应用设置版本号","slug":"set-version-number-androidstudio-developing-android-applications","date":"2015-08-22T08:38:34.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"set-version-number-androidstudio-developing-android-applications.html","link":"","permalink":"https://baiyuan.wang/set-version-number-androidstudio-developing-android-applications.html","excerpt":"","text":"Android:versionCode和android:versionName在eclipse中，修改我们开发的应用的版本号只需要在清单文件AndroidManifest.xml中manifest 标签节点中加入android:versionCode和android:versionName的值即可设置应用的版本号。如以下代码： 上述代码表示应用的包名为cn.wangbaiyuan.translate，版本号code：2，版本名Name：1.1；前者一般是给开发者比较版本是否有升级用的，后者是展示给用户看的。 在Eclipse中使用修改AndroidManifest.xml修改版本号是完全没有问题的，但是极客人在Android Studio上试过仅仅修改AndroidManifest.xml内容是没有效果的，虽然我把android:versionName赋值为1.1，但是在手机上显示的版本号始终是之前的1.0.。 androidStudio开发安卓应用设置版本号后来才发现是Android Studio中build.gradle(Module:app)配置文件同样设置了它的版本号，在和AndroidManifest.xml填写的版本号冲突的情况下，编译后的APK使用了build.gradle(Module:app)里面的配置： build.gradle(Module:app) compileSdkVersion 22buildToolsVersion “21.1.2” defaultConfig { applicationId “cn.wangbaiyuan.translate” minSdkVersion 15 targetSdkVersion 22 versionCode 1 versionName “1.0”} 解决方法在项目文件夹下找到build.gradle(Module:app)文件，删除defaultConfig里面VersionCode 和VersionName这两行；或者直接在这里修改版本号。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://baiyuan.wang/tags/Android-Studio/"}]},{"title":"BY说说-wordpress说说插件发布与反馈","slug":"by-shuoshuo-wp-plugin-release-feedback","date":"2015-08-20T03:40:15.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"by-shuoshuo-wp-plugin-release-feedback.html","link":"","permalink":"https://baiyuan.wang/by-shuoshuo-wp-plugin-release-feedback.html","excerpt":"","text":"一、插件简介wordpress是最受欢迎的博客程序之一，但是却没有其它有些博客CMS程序的“微语”这样的功能。有时候我们只想用一两句话抒发一下自己的情绪，就想用wordpress发个微博，发个说说；没有必要写成长篇大论，如果凑字数就完全失去了“抒发”的真谛。上次写了一篇用wordpress写说说的文章，访友们很是踊跃，希望做成插件。 [button class&#x3D;”demo” size&#x3D;”lg” href&#x3D;”https://github.com/geekeren/WordPressShuoShuo“ title&#x3D;”在Github上StarWordPress说说插件”]在Github上Star[&#x2F;button] 本插件处于许多网友的要求为wordpress提供说说功能，wordpress不仅仅可以长篇大论，而可以微言大义。 二、使用注意由于本人不是专业的wordpress开发者，没有大量时间优化这项功能。本插件提供发表说说等功能，至于说说页面的样式界面文件只分享本人正在使用的，_我的界面样式可能并不适合你_，这可能需要你自己根据自己的主题适配说说展示页界面布局和样式。 三、插件截图预览地址：http://baiyuan.wang/shuoshuo电脑端界面： 手机端界面：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"wordpress作品","slug":"技术/wordpress作品","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/wordpress%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"wordpress插件制作","slug":"wordpress插件制作","permalink":"https://baiyuan.wang/tags/wordpress%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/"}]},{"title":"安卓实现倒计时按钮效果","slug":"android-implementation-effect-of-countdown-button","date":"2015-08-20T03:10:57.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-implementation-effect-of-countdown-button.html","link":"","permalink":"https://baiyuan.wang/android-implementation-effect-of-countdown-button.html","excerpt":"","text":"安卓手机管家类软件，在对手机的应用权限进行管理时常常会跳出这样的弹出框。 这样的按钮出现在很多场合，系统会给一定时间比如30s提示用户选择操作“禁止”还是“允许”，并设置倒计时，并在倒计时为零后系统会为用户选择默认行为执行。这个设计十分智能化，在无人使用手机时实现了自动化处理。下面介绍使用handler和Runnable实现这样的按钮是效果： 安卓实现倒计时按钮效果在极客人的一篇转载文章《Android使用线程更新UI的几种方法》中，提到了用在Android里使用 Runnable和 Handler.PostDelayed(Runnable,Time) 定时更新界面。下面我讲解的便是使用Runnable和 Handler.PostDelayed(Runnable,Time) 实现倒计时效果的按钮。 假设点击倒计时按钮的动作为运行函数 function(),按钮变量名为forbiddenBtn下面是实现的代码： Handler timerHandler &#x3D; new Handler();int autoRun&#x3D;30;&#x2F;&#x2F;设置倒计时时间30ssecond&#x3D;autoRun; Runnable timerRunnable &#x3D; new Runnable() { @Override public void run() { if (second &#x3D;&#x3D; 0) { forbiddenBtn.setText(“禁止”); timerHandler.removeCallbacks(timerRunnable);&#x2F;&#x2F;清除定时 second &#x3D;autoRun; function();&#x2F;&#x2F;执行默认操作 } else { forbiddenBtn.setText(“禁止 (“ + second– + “秒…)”); timerHandler.postDelayed(this, 1000); } } }; 原理上面代码实现的原理是使用timeHander.postDelayed(context,int)函数定时调用一个Runnable呢，这里是延时1000ms执行一下timerRunnable。调用上述倒计时的代码为： timerHandler.postDelayed(timerRunnable, 0); 即立即执行timerRunnable；当执行timerRunnable时，由于second初始化为30s,if语句执行else部分，second在button上显示出来后执行减1，然后通过timerHandler.postDelayed(this, 1000); 在1秒后再次执行timerRunnable，此时second&#x3D;29……依此类推，当second&#x3D;0时，就会执行function()，执行倒计时归零后的默认操作，","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"Android使用线程更新UI的几种方法","slug":"several-methods-of-using-threads-update-android-ui","date":"2015-08-18T08:42:40.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"several-methods-of-using-threads-update-android-ui.html","link":"","permalink":"https://baiyuan.wang/several-methods-of-using-threads-update-android-ui.html","excerpt":"","text":"方法一：(java习惯，在android不推荐使用）刚刚开始接触android线程编程的时候，习惯好像java一样，试图用下面的代码解决问题 new Thread( new Runnable() { public void run() { myView.invalidate(); }}).start(); 可以实现功能，刷新UI界面。但是这样是不行的，因为它违背了单线程模型：Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。 方法二：（Thread+Handler)查阅了文档和apidemo后，发觉常用的方法是利用Handler来实现UI线程的更新的。 Handler来根据接收的消息，处理UI更新。Thread线程发出Handler消息，通知更新UI。 Handler myHandler &#x3D; new Handler() {public void handleMessage(Message msg) {switch (msg.what) {case TestHandler.GUIUPDATEIDENTIFIER:myBounceView.invalidate();break;}super.handleMessage(msg);}}; class myThread implements Runnable {public void run() {while (!Thread.currentThread().isInterrupted()) { Message message &#x3D; new Message();message.what &#x3D; TestHandler.GUIUPDATEIDENTIFIER; TestHandler.this.myHandler.sendMessage(message);try {Thread.sleep(100);} catch (InterruptedException e) {Thread.currentThread().interrupt();}}}} 方法三：（java习惯，不推荐）在Android平台中需要反复按周期执行方法可以使用Java上自带的TimerTask类，TimerTask相对于Thread来说对于资源消耗的更低，除了使用Android自带的AlarmManager使用Timer定时器是一种更好的解决方法。 我们需要引入import java.util.Timer; 和 import java.util.TimerTask; public class JavaTimer extends Activity { Timer timer &#x3D; new Timer();TimerTask task &#x3D; new TimerTask(){public void run() {setTitle(“hear me?”);}}; public void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.main); timer.schedule(task, 10000); }} 方法四：(TimerTask + Handler)实际上这样做是不行的，这跟Android的线程安全有关！应该通过配合Handler来实现timer功能的！ public class TestTimer extends Activity { Timer timer &#x3D; new Timer();Handler handler &#x3D; new Handler(){public void handleMessage(Message msg) {switch (msg.what) {case 1:setTitle(“hear me?”);break;}super.handleMessage(msg);} }; TimerTask task &#x3D; new TimerTask(){public void run() {Message message &#x3D; new Message();message.what &#x3D; 1;handler.sendMessage(message);}}; public void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.main); timer.schedule(task, 10000);}} 方法五：( Runnable + Handler.postDelayed(runnable,time) )在Android里定时更新 UI，通常使用的是 java.util.Timer, java.util.TimerTask, android_.os._Handler组合。实际上Handler 自身已经提供了定时的功能。 private Handler handler &#x3D; new Handler(); private Runnable myRunnable&#x3D; new Runnable() {public void run() { if (run) {handler.postDelayed(this, 1000);count++;}tvCounter.setText(“Count: “ + count); }}; 然后在其他地方调用 handler.post(myRunnable); handler.post(myRunnable,time); &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 知识点总结补充：很多初入Android或Java开发的新手对Thread、Looper、Handler和Message仍然比较迷惑，衍生的有HandlerThread、java.util.concurrent、Task、AsyncTask由于目前市面上的书籍等资料都没有谈到这些问题，今天就这一问题做更系统性的总结。我们创建的Service、Activity以及Broadcast均是一个主线程处理，这里我们可以理解为UI线程。但是在操作一些耗时操作时，比如I&#x2F;O读写的大文件读写，数据库操作以及网络下载需要很长时间，为了不阻塞用户界面，出现ANR的响应提示窗口，这个时候我们可以考虑使用Thread线程来解决。 对于从事过J2ME开发的程序员来说Thread比较简单，直接匿名创建重写run方法，调用start方法执行即可。或者从Runnable接口继承，但对于Android平台来说UI控件都没有设计成为线程安全类型，所以需要引入一些同步的机制来使其刷新，这点Google在设计Android时倒是参考了下Win32的消息处理机制。 1. 对于线程中的刷新一个View为基类的界面，可以使用postInvalidate()方法在线程中来处理，其中还提供了一些重写方法比如postInvalidate(int left,int top,int right,int bottom) 来刷新一个矩形区域，以及延时执行，比如postInvalidateDelayed(long delayMilliseconds)或postInvalidateDelayed(long delayMilliseconds,int left,int top,int right,int bottom) 方法，其中第一个参数为毫秒 2. 当然推荐的方法是通过一个Handler来处理这些，可以在一个线程的run方法中调用handler对象的 postMessage或sendMessage方法来实现，Android程序内部维护着一个消息队列，会轮训处理这些，如果你是Win32程序员可以很好理解这些消息处理，不过相对于Android来说没有提供 PreTranslateMessage这些干涉内部的方法。 3. Looper又是什么呢? ，其实Android中每一个Thread都跟着一个Looper，Looper可以帮助Thread维护一个消息队列，但是Looper和Handler没有什么关系，我们从开源的代码可以看到Android还提供了一个Thread继承类HanderThread可以帮助我们处理，在HandlerThread对象中可以通过getLooper方法获取一个Looper对象控制句柄，我们可以将其这个Looper对象映射到一个Handler中去来实现一个线程同步机制，Looper对象的执行需要初始化Looper.prepare方法就是昨天我们看到的问题，同时推出时还要释放资源，使用Looper.release方法。 4.Message 在Android是什么呢? 对于Android中Handler可以传递一些内容，通过Bundle对象可以封装String、Integer以及Blob二进制对象，我们通过在线程中使用Handler对象的sendEmptyMessage或sendMessage方法来传递一个Bundle对象到Handler处理器。对于Handler类提供了重写方法handleMessage(Message msg) 来判断，通过msg.what来区分每条信息。将Bundle解包来实现Handler类更新UI线程中的内容实现控件的刷新操作。相关的Handler对象有关消息发送sendXXXX相关方法如下，同时还有postXXXX相关方法，这些和Win32中的道理基本一致，一个为发送后直接返回，一个为处理后才返回 . 5. java.util.concurrent对象分析，对于过去从事Java开发的程序员不会对Concurrent对象感到陌生吧，他是JDK 1.5以后新增的重要特性作为掌上设备，我们不提倡使用该类，考虑到Android为我们已经设计好的Task机制，这里不做过多的赘述，相关原因参考下面的介绍: 6. 在Android中还提供了一种有别于线程的处理方式，就是Task以及AsyncTask，从开源代码中可以看到是针对Concurrent的封装，开发人员可以方便的处理这些异步任务。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"android控件","slug":"android控件","permalink":"https://baiyuan.wang/tags/android%E6%8E%A7%E4%BB%B6/"}]},{"title":"使用内存做虚拟磁盘","slug":"use-memory-as-virtual-disk","date":"2015-08-14T03:51:35.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"use-memory-as-virtual-disk.html","link":"","permalink":"https://baiyuan.wang/use-memory-as-virtual-disk.html","excerpt":"","text":"电脑内存盘有多大使用电脑内存当硬盘来使用将极大地提高程序运行、文件读写的速度，为了有一个直观的了解，极客人使用磁盘速度测试软件测试自己的内存盘（大小为1G）和机械硬盘分区（大小为30G），测试效果如下： 对比之下，内存和机械硬盘的速度判若云泥，我就发图不解释。 内存的特点电脑程序一般存储在磁盘中，运行的时候数据会从磁盘读取、存写在内存中，然后CPU处理内存中的数据。由于CPU处理速度较快，磁盘无法满足这样的速度，所以需要将数据中转到高速度的内存中去。通过CPU反复处理数据必然也要频繁读写内存，内存同时对CPU的数据读写请求给予雷霆万钧的响应。 因此，内存的特点除了高速，还有读写频繁、响应速度快。至于虚拟磁盘怎样制作，可以百度关键词“大内存怎样制作虚拟硬盘”。 怎样充分利用虚拟磁盘（内存盘）正因为内存具有上述特点，使用内存做虚拟磁盘我们也要把它用在刀刃上。我们不会用虚拟内存存储电影音乐，因为磁盘的速度完全可以满足播放电影音乐的要求（你一般不会发现你把电影保存在本地播放时出现卡顿），同时内存容量小、价格昂贵，用它存电影音乐不太现实。 举电影音乐的例子是说我们不要把读写速度要求不大、大容量的数据放在虚拟硬盘上。那哪些数据对读写速度要求较高且文件体量并不大呢？ 1.系统、浏览器及其他应用程序缓存不管你懂不懂什么是缓存，但如果你经常使用电脑管家类软件清理电脑垃圾，对“系统、浏览器及其他应用程序缓存”这些名词必定不会感到陌生。 缓存一般是系统和应用程序访问最活跃的文件，同时会产生大量的磁盘碎片（不懂自行百度），而且是读写速度要求也很高。所以把缓存放在内存盘除了提高响应速度，还可以减少对磁盘的伤害。 怎样把缓存放在虚拟磁盘，你可以百度“怎样修改浏览器缓存目录”、“怎样修改XX软件的缓存文件存放位置” 2.临时文件临时文件会带来较多的磁盘碎片，较多的磁盘碎片对磁盘有一定伤害，修改临时文件目录的方法是修改系统环境变量。将环境变量中temp和TMP对应的值改为虚拟磁盘的地址。 右键计算机-属性-高级系统设置-环境变量。 3.软件开发中的项目文件程序员在调试编译程序时会调用大量的项目文件，磁盘的速度往往是拖累编译速度的罪魁祸首，在没有使用固态硬盘的时候使用虚拟磁盘存放这些文件将会大幅提高编译速度，但是平时存放不要放在虚拟磁盘里，下面是原因： 4.风险内存具有数据易失性，如果电脑意外断电虚拟磁盘里的文件可能将会全部丢失，项目文件只可放在里面编译，如果平时存放其内，可能几天的心血因为突如其来的断电归于虚无。 所以你可以看到，除了项目文件，上面的缓存、临时文件往往是你可有可无的文件，意外丢失也无关紧要，就权当帮你清除了一下电脑垃圾。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"百度人脸识别服务首次对外开放","slug":"baidu-face-recognition-open-for-first-time","date":"2015-08-08T02:02:10.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"baidu-face-recognition-open-for-first-time.html","link":"","permalink":"https://baiyuan.wang/baidu-face-recognition-open-for-first-time.html","excerpt":"","text":"本文由极客人转自：中文科技资讯 Citnews科技资讯网 7月24日，百度研究院深度学习实验室(IDL)宣布，通过APIStore将其自主研发的百度人脸识别技术免费对外开放。 近年来随着移动互联网的飞速发展，互联网+正在渗透到各行各业。对于需要面对面确认身份的业务而言，能否用机器自动做身份认证将成为互联网+落地的关键。深度学习带给人脸识别技术的不断进步，使得机器识别人的身份成为可能。特别是基于深度学习的人脸识别技术，其效果大大超越了传统模式识别的技术方法。在诸如在线开户、移动支付、刷脸登陆等应用场景中，如何利用可靠高效的人脸识别技术来代替传统的人工审核，是当下互联网行业中十分热门的应用方向。 百度深度学习实验室成立于2012年，从成立之初至今在人脸技术上已经积累了大量的数据和技术经验。在此之前，深度学习实验室的人脸识别技术仅仅提供给百度公司内部产品使用，其在百度的众多产品中都得到了应用，比如曾经火爆一时、最高日PV近一亿的PK大咖。该技术帮助百度魔图在App Store所有免费应用综合排名中夺冠，并获得2013中国广告节艾菲奖大中华区金奖。为了进一步推动人脸识别技术在实际场景中的应用，让更多的用户受益，深度学习实验室决定将自己所研发的业内最为领先的人脸识别技术通过APIStore开放出来，对所有开发者免费提供直接针对人脸注册、登陆、身份认证、多人脸比对等细分场景的一站式人脸识别服务。 一个月前，深度学习实验室研发的文字识别技术(OCR)通过APIStore首次对外开放，已经引起了业界的强烈关注。后续，深度学习实验室会根据上述技术的应用情况，逐步开放其它图像识别技术，推动图像识别技术在移动互联网、O2O及其它领域的应用。我们相信，先进的技术，只有得到了更多的应用，才真正实现了价值，同时，技术也只有在实际中得到检验，不断改进，才能够真正促进技术的发展。 APIStore由百度出品，是一个连接服务商与开发者的第三方API分发平台。致力于为开发者提供最全面最便捷的API服务，以及帮助全国的中小企业开放他们的服务，为服务商提升API调用量。截至目前，平台已汇集了国内外应用开发所需的Android&#x2F;IOS API和SDK等700余个服务，包含设计开发、运维管理、云服务、APP推广、数据服务等多个范畴。 平台首推即用API的创新模式，开发者登录百度账号即可直接在平台上调用服务，且提供统一格式的请求参数、请求示例，尽可能的简化了开发者的工作。目前体验专区中的即用服务全部免费，包括百度首次对外开放的OCR文字识别、人脸识别等百度独家服务。 APIStore官方网站：apistore.baidu.com， 百度人脸识别API地址：http://apistore.baidu.com/apiworks/servicedetail/464.html 关于APIStoreAPIStore由百度出品，是一个连接服务商与开发者的第三方API分发平台。平台致力于为开发者提供最全面最便捷的API服务，以及帮助服务商开放服务，提升API调用量。目前平台已汇集了国内外应用开发所需的Android&#x2F;IOS API和SDK等700余个服务，特有百度独家的检索抓取、语音图像、地图翻译等服务。首创即用API模式，使用百度账号即可调用平台内所有即用API，让开发工作如此简单。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"人工智能","slug":"人工智能","permalink":"https://baiyuan.wang/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"C/C++串口通信原理及读写与操作","slug":"c-serial-communication-write-reading","date":"2015-08-06T14:11:51.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"c-serial-communication-write-reading.html","link":"","permalink":"https://baiyuan.wang/c-serial-communication-write-reading.html","excerpt":"","text":"在工业控制中，工控机（一般都基于Windows平台）经常需要与智能仪表通过串口进行通信。串口通信方便易行，应用广泛。 一般情况下，工控机和各智能仪表通过RS485总线进行通信。RS485的通信方式是半双工的，只能由作为主节点的工控PC机依次轮询网络上的各智能控制单元子节点。每次通信都是由PC机通过串口向智能控制单元发布命令，智能控制单元在接收到正确的命令后作出应答。 在Win32下，可以使用两种编程方式实现串口通信，其一是使用ActiveX控件，这种方法程序简单，但欠灵活。其二是调用Windows的API函数，这种方法可以清楚地掌握串口通信的机制，并且自由灵活。本文我们只介绍API串口通信部分。 串口的操作可以有两种操作方式：同步操作方式和重叠操作方式（又称为异步操作方式）。 同步操作时，API函数会阻塞直到操作完成以后才能返回（在多线程方式中，虽然不会阻塞主线程，但是仍然会阻塞监听线程）；而重叠操作方式，API函数会立即返回，操作在后台进行，避免线程的阻塞。 无论那种操作方式，一般都通过四个步骤来完成： （1） 打开串口 （2） 配置串口 （3） 读写串口 （4） 关闭串口 1、打开串口Win32系统把文件的概念进行了扩展。无论是文件、通信设备、命名管道、邮件槽、磁盘、还是控制台，都是用API函数CreateFile来打开或创建的。该函数的原型为： C++代码HANDLE CreateFile( LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); **lpFileName：**将要打开的串口逻辑名，如”COM1”； **dwDesiredAccess：**指定串口访问的类型，可以是读取、写入或二者并列； _dwShareMode：_指定共享属性，由于串口不能共享，该参数必须置为0； **lpSecurityAttributes：**引用安全性属性结构，缺省值为NULL； _dwCreationDistribution：_创建标志，对串口操作该参数必须置为OPEN_EXISTING； _dwFlagsAndAttributes：_属性描述，用于指定该串口是否进行异步操作，该值为FILE_FLAG_OVERLAPPED，表示使用异步的I&#x2F;O；该值为0，表示同步I&#x2F;O操作； _hTemplateFile：_对串口而言该参数必须置为NULL。 同步I&#x2F;O方式打开串口的示例代码：C++代码HANDLE hCom; &#x2F;&#x2F;全局变量，串口句柄hCom&#x3D;CreateFile(“COM1”,&#x2F;&#x2F;COM1口GENERIC_READ|GENERIC_WRITE, &#x2F;&#x2F;允许读和写0, &#x2F;&#x2F;独占方式NULL,OPEN_EXISTING, &#x2F;&#x2F;打开而不是创建0, &#x2F;&#x2F;同步方式NULL);if(hCom&#x3D;&#x3D;(HANDLE)-1){AfxMessageBox(“打开COM失败!”);return FALSE;}return TRUE; 重叠I&#x2F;O打开串口的示例代码：C++代码 HANDLE hCom; &#x2F;&#x2F;全局变量，串口句柄hCom &#x3D;CreateFile(“COM1”, &#x2F;&#x2F;COM1口GENERIC_READ|GENERIC_WRITE, &#x2F;&#x2F;允许读和写0, &#x2F;&#x2F;独占方式NULL,OPEN_EXISTING, &#x2F;&#x2F;打开而不是创建FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED, &#x2F;&#x2F;重叠方式NULL);if(hCom &#x3D;&#x3D;INVALID_HANDLE_VALUE){AfxMessageBox(“打开COM失败!”);return FALSE;}return TRUE; 2、配置串口在打开通讯设备句柄后，常常需要对串口进行一些初始化配置工作。这需要通过一个DCB结构来进行。DCB结构包含了诸如波特率、数据位数、奇偶校验和停止位数等信息。在查询或配置串口的属性时，都要用DCB结构来作为缓冲区。 一般用CreateFile打开串口后，可以调用GetCommState函数来获取串口的初始配置。要修改串口的配置，应该先修改DCB结构，然后再调用SetCommState函数设置串口。 DCB结构包含了串口的各项参数设置，下面仅介绍几个该结构常用的变量： typedef struct _DCB{ ……… DWORD BaudRate;&#x2F;&#x2F;波特率，指定通信设备的传输速率。这个成员可以是实际波特率值或者下面的常量值之一： CBR_110，CBR_300，CBR_600，CBR_1200，CBR_2400，CBR_4800，CBR_9600，CBR_19200， CBR_38400， CBR_56000， CBR_57600， CBR_115200， CBR_128000， CBR_256000， CBR_14400 DWORD fParity; &#x2F;&#x2F; 指定奇偶校验使能。若此成员为1，允许奇偶校验检查 … BYTE ByteSize; &#x2F;&#x2F; 通信字节位数，4—8 BYTE Parity; &#x2F;&#x2F;指定奇偶校验方法。此成员可以有下列值： EVENPARITY 偶校验 NOPARITY 无校验 MARKPARITY 标记校验 ODDPARITY 奇校验 BYTE StopBits; &#x2F;&#x2F;指定停止位的位数。此成员可以有下列值： ONESTOPBIT 1位停止位 TWOSTOPBITS 2位停止位 ON 5STOPBITS 1.5位停止位 GetCommState函数可以获得COM口的设备控制块，从而获得相关参数： BOOL GetCommState(HANDLE hFile, &#x2F;&#x2F;标识通讯端口的句柄LPDCB lpDCB &#x2F;&#x2F;指向一个设备控制块（DCB结构）的指针 );SetCommState函数设置COM口的设备控制块：BOOL SetCommState( HANDLE hFile, LPDCB lpDCB ); 除了在BCD中的设置外，程序一般还需要设置I&#x2F;O缓冲区的大小和超时。Windows用I&#x2F;O缓冲区来暂存串口输入和输出的数据。如果通信的速率较高，则应该设置较大的缓冲区。调用SetupComm函数可以设置串行口的输入和输出缓冲区的大小。 BOOL SetupComm( HANDLE hFile, &#x2F;&#x2F; 通信设备的句柄 DWORD dwInQueue, &#x2F;&#x2F; 输入缓冲区的大小（字节数） DWORD dwOutQueue &#x2F;&#x2F; 输出缓冲区的大小（字节数） ); 在用ReadFile和WriteFile读写串行口时，需要考虑超时问题。超时的作用是在指定的时间内没有读入或发送指定数量的字符，ReadFile或WriteFile的操作仍然会结束。 要查询当前的超时设置应调用GetCommTimeouts函数，该函数会填充一个COMMTIMEOUTS结构。调用SetCommTimeouts可以用某一个COMMTIMEOUTS结构的内容来设置超时。 读写串口的超时有两种：间隔超时和总超时。间隔超时是指在接收时两个字符之间的最大时延。总超时是指读写操作总共花费的最大时间。写操作只支持总超时，而读操作两种超时均支持。用COMMTIMEOUTS结构可以规定读写操作的超时。 COMMTIMEOUTS结构的定义为： typedef struct _COMMTIMEOUTS {DWORD ReadIntervalTimeout; &#x2F;&#x2F;读间隔超时DWORD ReadTotalTimeoutMultiplier; &#x2F;&#x2F;读时间系数DWORD ReadTotalTimeoutConstant; &#x2F;&#x2F;读时间常量DWORD WriteTotalTimeoutMultiplier; &#x2F;&#x2F; 写时间系数DWORD WriteTotalTimeoutConstant; &#x2F;&#x2F;写时间常量} COMMTIMEOUTS,*LPCOMMTIMEOUTS; COMMTIMEOUTS结构的成员都以毫秒为单位。 总超时的计算公式是：总超时＝时间系数×要求读&#x2F;写的字符数＋时间常量 例如，要读入10个字符，那么读操作的总超时的计算公式为： 读总超时＝ReadTotalTimeoutMultiplier×10＋ReadTotalTimeoutConstant 可以看出：间隔超时和总超时的设置是不相关的，这可以方便通信程序灵活地设置各种超时。 如果所有写超时参数均为0，那么就不使用写超时。如果ReadIntervalTimeout为0，那么就不使用读间隔超时。如果ReadTotalTimeoutMultiplier 和 ReadTotalTimeoutConstant 都为0，则不使用读总超时。如果读间隔超时被设置成MAXDWORD并且读时间系数和读时间常量都为0，那么在读一次输入缓冲区的内容后读操作就立即返回，而不管是否读入了要求的字符。 在用重叠方式读写串口时，虽然ReadFile和WriteFile在完成操作以前就可能返回，但超时仍然是起作用的。在这种情况下，超时规定的是操作的完成时间，而不是ReadFile和WriteFile的返回时间。 配置串口的示例代码：SetupComm(hCom,1024,1024); &#x2F;&#x2F;输入缓冲区和输出缓冲区的大小都是1024COMMTIMEOUTS TimeOuts; &#x2F;&#x2F;设定读超时TimeOuts.ReadIntervalTimeout&#x3D;1000;TimeOuts.ReadTotalTimeoutMultiplier&#x3D;500;TimeOuts.ReadTotalTimeoutConstant&#x3D;5000; &#x2F;&#x2F;设定写超时TimeOuts.WriteTotalTimeoutMultiplier&#x3D;500;TimeOuts.WriteTotalTimeoutConstant&#x3D;2000;SetCommTimeouts(hCom,&amp;TimeOuts); &#x2F;&#x2F;设置超时DCB dcb;GetCommState(hCom,&amp;dcb);dcb.BaudRate&#x3D;9600; &#x2F;&#x2F;波特率为9600dcb.ByteSize&#x3D;8; &#x2F;&#x2F;每个字节有8位dcb.Parity&#x3D;NOPARITY; &#x2F;&#x2F;无奇偶校验位dcb.StopBits&#x3D;TWOSTOPBITS; &#x2F;&#x2F;两个停止位SetCommState(hCom,&amp;dcb);PurgeComm(hCom,PURGE_TXCLEAR|PURGE_RXCLEAR); 在读写串口之前，还要用PurgeComm()函数清空缓冲区，该函数原型： BOOL PurgeComm( HANDLE hFile, &#x2F;&#x2F;串口句柄 DWORD dwFlags &#x2F;&#x2F; 需要完成的操作 ); 参数dwFlags指定要完成的操作，可以是下列值的组合： PURGE_TXABORT 中断所有写操作并立即返回，即使写操作还没有完成。 PURGE_RXABORT 中断所有读操作并立即返回，即使读操作还没有完成。 PURGE_TXCLEAR 清除输出缓冲区 PURGE_RXCLEAR 清除输入缓冲区 3、读写串口我们使用ReadFile和WriteFile读写串口，下面是两个函数的声明： BOOL ReadFile( HANDLE hFile, &#x2F;&#x2F;串口的句柄&#x2F;&#x2F; 读入的数据存储的地址，&#x2F;&#x2F; 即读入的数据将存储在以该指针的值为首地址的一片内存区LPVOID lpBuffer,&#x2F;&#x2F; 要读入的数据的字节数DWORD nNumberOfBytesToRead,&#x2F;&#x2F; 指向一个DWORD数值，该数值返回读操作实际读入的字节数LPDWORD lpNumberOfBytesRead,&#x2F;&#x2F; 重叠操作时，该参数指向一个OVERLAPPED结构，同步操作时，该参数为NULL。LPOVERLAPPED lpOverlapped );BOOL WriteFile( HANDLE hFile, &#x2F;&#x2F;串口的句柄&#x2F;&#x2F; 写入的数据存储的地址，&#x2F;&#x2F; 即以该指针的值为首地址的LPCVOID lpBuffer,&#x2F;&#x2F;要写入的数据的字节数DWORD nNumberOfBytesToWrite,&#x2F;&#x2F; 指向指向一个DWORD数值，该数值返回实际写入的字节数LPDWORD lpNumberOfBytesWritten,&#x2F;&#x2F; 重叠操作时，该参数指向一个OVERLAPPED结构，&#x2F;&#x2F; 同步操作时，该参数为NULL。LPOVERLAPPED lpOverlapped ); 在用ReadFile和WriteFile读写串口时，既可以同步执行，也可以重叠执行。在同步执行时，函数直到操作完成后才返回。这意味着同步执行时线程会被阻塞，从而导致效率下降。在重叠执行时，即使操作还未完成，这两个函数也会立即返回，费时的I&#x2F;O操作在后台进行。 ReadFile和WriteFile函数是同步还是异步由CreateFile函数决定，如果在调用CreateFile创建句柄时指定了FILE_FLAG_OVERLAPPED标志，那么调用ReadFile和WriteFile对该句柄进行的操作就应该是重叠的；如果未指定重叠标志，则读写操作应该是同步的。ReadFile和WriteFile函数的同步或者异步应该和CreateFile函数相一致。 ReadFile函数只要在串口输入缓冲区中读入指定数量的字符，就算完成操作。而WriteFile函数不但要把指定数量的字符拷入到输出缓冲区，而且要等这些字符从串行口送出去后才算完成操作。 如果操作成功，这两个函数都返回TRUE。需要注意的是，当ReadFile和WriteFile返回FALSE时，不一定就是操作失败，线程应该调用GetLastError函数分析返回的结果。例如，在重叠操作时如果操作还未完成函数就返回，那么函数就返回FALSE，而且GetLastError函数返回ERROR_IO_PENDING。这说明重叠操作还未完成。 同步方式读写串口比较简单，下面先例举同步方式读写串口的代码： &#x2F;&#x2F;同步读串口 char str[100]; DWORD wCount;&#x2F;&#x2F;读取的字节数 BOOL bReadStat; bReadStat&#x3D;ReadFile(hCom,str,100,&amp;wCount,NULL); if(!bReadStat) { AfxMessageBox(“读串口失败!”); return FALSE; } return TRUE; &#x2F;&#x2F;同步写串口 char lpOutBuffer[100]; DWORD dwBytesWrite&#x3D;100; COMSTAT ComStat; DWORD dwErrorFlags; BOOL bWriteStat; ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat); bWriteStat&#x3D;WriteFile(hCom,lpOutBuffer,dwBytesWrite,&amp; dwBytesWrite,NULL); if(!bWriteStat) { AfxMessageBox(“写串口失败!”); } PurgeComm(hCom, PURGE_TXABORT| PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR); 在重叠操作时,操作还未完成函数就返回。 重叠I&#x2F;O非常灵活，它也可以实现阻塞（例如我们可以设置一定要读取到一个数据才能进行到下一步操作）。有两种方法可以等待操作完成：一种方法是用象WaitForSingleObject这样的等待函数来等待OVERLAPPED结构的hEvent成员；另一种方法是调用GetOverlappedResult函数等待，后面将演示说明。 下面我们先简单说一下OVERLAPPED结构和GetOverlappedResult函数： OVERLAPPED结构 OVERLAPPED结构包含了重叠I&#x2F;O的一些信息，定义如下： typedef struct _OVERLAPPED { &#x2F;&#x2F; o DWORD Internal; DWORD InternalHigh; DWORD Offset; DWORD OffsetHigh; HANDLE hEvent; } OVERLAPPED; 在使用ReadFile和WriteFile重叠操作时，线程需要创建OVERLAPPED结构以供这两个函数使用。线程通过OVERLAPPED结构获得当前的操作状态，该结构最重要的成员是hEvent。hEvent是读写事件。当串口使用异步通讯时，函数返回时操作可能还没有完成，程序可以通过检查该事件得知是否读写完毕。 当调用ReadFile, WriteFile 函数的时候，该成员会自动被置为无信号状态；当重叠操作完成后，该成员变量会自动被置为有信号状态。 GetOverlappedResult函数 BOOL GetOverlappedResult( HANDLE hFile, &#x2F;&#x2F; 串口的句柄 &#x2F;&#x2F; 指向重叠操作开始时指定的OVERLAPPED结构 LPOVERLAPPED lpOverlapped, &#x2F;&#x2F; 指向一个32位变量，该变量的值返回实际读写操作传输的字节数。 LPDWORD lpNumberOfBytesTransferred, &#x2F;&#x2F; 该参数用于指定函数是否一直等到重叠操作结束。 &#x2F;&#x2F; 如果该参数为TRUE，函数直到操作结束才返回。 &#x2F;&#x2F; 如果该参数为FALSE，函数直接返回，这时如果操作没有完成， &#x2F;&#x2F; 通过调用GetLastError()函数会返回ERROR_IO_INCOMPLETE。 BOOL bWait ); 该函数返回重叠操作的结果，用来判断异步操作是否完成，它是通过判断OVERLAPPED结构中的hEvent是否被置位来实现的。 异步读串口的示例代码：char lpInBuffer[1024]; DWORD dwBytesRead&#x3D;1024; COMSTAT ComStat; DWORD dwErrorFlags; OVERLAPPED m_osRead; memset(&amp;m_osRead,0,sizeof(OVERLAPPED)); m_osRead.hEvent&#x3D;CreateEvent(NULL,TRUE,FALSE,NULL); ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat); dwBytesRead&#x3D;min(dwBytesRead,(DWORD)ComStat.cbInQue); if(!dwBytesRead) return FALSE; BOOL bReadStatus; bReadStatus&#x3D;ReadFile(hCom,lpInBuffer, dwBytesRead,&amp;dwBytesRead,&amp;m_osRead); if(!bReadStatus) &#x2F;&#x2F;如果ReadFile函数返回FALSE { if(GetLastError()&#x3D;&#x3D;ERROR_IO_PENDING) &#x2F;&#x2F;GetLastError()函数返回ERROR_IO_PENDING,表明串口正在进行读操作 { WaitForSingleObject(m_osRead.hEvent,2000); &#x2F;&#x2F;使用WaitForSingleObject函数等待，直到读操作完成或延时已达到2秒钟 &#x2F;&#x2F;当串口读操作进行完毕后，m_osRead的hEvent事件会变为有信号 PurgeComm(hCom, PURGE_TXABORT| PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR); return dwBytesRead; } return 0; } PurgeComm(hCom, PURGE_TXABORT| PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR); return dwBytesRead; 对以上代码再作简要说明：在使用ReadFile 函数进行读操作前，应先使用ClearCommError函数清除错误。 ClearCommError函数的原型如下： BOOL ClearCommError( HANDLE hFile, &#x2F;&#x2F; 串口句柄LPDWORD lpErrors, &#x2F;&#x2F; 指向接收错误码的变量 LPCOMSTAT lpStat &#x2F;&#x2F; 指向通讯状态缓冲区 ); 该函数获得通信错误并报告串口的当前状态，同时，该函数清除串口的错误标志以便继续输入、输出操作。 参数lpStat指向一个COMSTAT结构，该结构返回串口状态信息。 COMSTAT结构 COMSTAT结构包含串口的信息， 结构定义如下： typedef struct _COMSTAT { &#x2F;&#x2F; cst DWORD fCtsHold : 1; &#x2F;&#x2F; Tx waiting for CTS signal DWORD fDsrHold : 1; &#x2F;&#x2F; Tx waiting for DSR signal DWORD fRlsdHold : 1; &#x2F;&#x2F; Tx waiting for RLSD signal DWORD fXoffHold : 1; &#x2F;&#x2F; Tx waiting, XOFF char rec’’d DWORD fXoffSent : 1; &#x2F;&#x2F; Tx waiting, XOFF char sent DWORD fEof : 1; &#x2F;&#x2F; EOF character sent DWORD fTxim : 1; &#x2F;&#x2F; character waiting for Tx DWORD fReserved : 25; &#x2F;&#x2F; reserved DWORD cbInQue; &#x2F;&#x2F; bytes in input buffer DWORD cbOutQue; &#x2F;&#x2F; bytes in output buffer } COMSTAT, *LPCOMSTAT; 本文只用到了cbInQue成员变量，该成员变量的值代表输入缓冲区的字节数。 最后用PurgeComm函数清空串口的输入输出缓冲区。 这段代码用WaitForSingleObject函数来等待OVERLAPPED结构的hEvent成员，下面我们再演示一段调用GetOverlappedResult函数等待的 异步读串口示例代码：char lpInBuffer[1024];DWORD dwBytesRead&#x3D;1024;BOOL bReadStatus;DWORD dwErrorFlags;COMSTAT ComStat;OVERLAPPED m_osRead;ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);if(!ComStat.cbInQue) return 0;dwBytesRead&#x3D;min(dwBytesRead,(DWORD)ComStat.cbInQue);bReadStatus&#x3D;ReadFile(hCom, lpInBuffer,dwBytesRead, &amp;dwBytesRead,&amp;m_osRead);if(!bReadStatus) &#x2F;&#x2F;如果ReadFile函数返回FALSE{ if(GetLastError()&#x3D;&#x3D;ERROR_IO_PENDING){ GetOverlappedResult(hCom, &amp;m_osRead,&amp;dwBytesRead,TRUE);&#x2F;&#x2F; GetOverlappedResult函数的最后一个参数设为TRUE，&#x2F;&#x2F;函数会一直等待，直到读操作完成或由于错误而返回。return dwBytesRead; }return 0; }return dwBytesRead; 异步写串口的示例代码：char buffer[1024];DWORD dwBytesWritten&#x3D;1024;DWORD dwErrorFlags;COMSTAT ComStat;OVERLAPPED m_osWrite;BOOL bWriteStat;bWriteStat&#x3D;WriteFile(hCom,buffer,dwBytesWritten, &amp;dwBytesWritten,&amp;m_OsWrite);if(!bWriteStat){ if(GetLastError()&#x3D;&#x3D;ERROR_IO_PENDING){ WaitForSingleObject(m_osWrite.hEvent,1000);return dwBytesWritten; }return 0; }return dwBytesWritten; 4、关闭串口利用API函数关闭串口非常简单，只需使用CreateFile函数返回的句柄作为参数调用CloseHandle即可： BOOL CloseHandle(HANDLE hObject; &#x2F;&#x2F;handle to object to close);","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"使用内存做虚拟磁盘与磁盘做虚拟内存","slug":"use-of-memory-do-virtual-memory-virtual-disk-disk","date":"2015-08-06T13:49:12.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"use-of-memory-do-virtual-memory-virtual-disk-disk.html","link":"","permalink":"https://baiyuan.wang/use-of-memory-do-virtual-memory-virtual-disk-disk.html","excerpt":"","text":"磁盘和内存极客人在使用android Studio开发安卓时被内存不足深深困扰，为此买了一块4G的内存条，电脑的速度因此的确有所提升内存的占用率一般在30%，开了android studio和虚拟机也有大量内存。为了剩余的大量内存物尽所需，尽可能充裕的内存使电脑的性能得到提升。极客人决定调整自己的虚拟内存大小，同时开辟一部分内存当硬盘使用。当然这些方法仅仅适用于电脑内存大任性的机友们。 学过或者稍微懂得计算机的人都知道内存和硬盘是电脑的关键部分，当然现在智能手机普及，就算小学文化的大叔大姐都知道了内存，不过总是内存卡（存储卡）和内存（运行内存）傻傻分不清楚。电脑上的硬盘对应于手机的存储卡。稍微知道计算机的人问懂计算机的人的手机内存多大时，当听到回答”16G”时总是苦笑不得，其实计算机领域所说的内存就是指运行内存，并不是人们习惯所说的内存卡。现在主流的电脑内存是4G或者8G，手机内存有512M、1G、2G、3G等等，而电脑上的磁盘一般为500G、1T(1T&#x3D;1024M)，手机内存卡现在一般达到了16G、32G。所以你可以看到内存卡（或硬盘）与内存之间巨大的区别。相对于硬盘内存卡，内存昂贵得不止一点点。比如，我刚买的4G电脑内存价格为166元，而500G机械硬盘大约才售250元，以此为例相同的容量，内存与机械硬盘的价格比大约为80：1，而同时内存的读写速度达到了机械硬盘的100倍！ 小内存电脑怎样配置虚拟内存正因为内存的相对昂贵，低端配置的电脑常常内存不足导致不能运行很多软件，而硬盘容量相对充裕，为了使电脑尽可能运行更多的软件，发挥硬盘的“剩余价值”，windows操作系统有开辟一块硬盘空间作为内存来使用的功能，这个功能默认是开启的。而硬盘毕竟不是内存，所以称为“虚拟内存”；同时，内存的速度远远远非硬盘所能企及，所以把硬盘当内存使能运行多程序但会降低运行速度。 对于windows下的虚拟内存配置，读者可以自行百度。 大内存电脑怎样配置虚拟磁盘与上面相对应的，现在许多电脑配置或升级了8G&#x2F;16G内存，这么大的内存常常大部分都是冗余，为了充分发挥内存的“才能”——神速的读写，我们可以借助第三方软件实现将内存作为磁盘使用，同理此时的内存称为“虚拟磁盘”。 对于windows下的虚拟磁盘配置，读者可以自行百度，究竟虚拟磁盘速度有多大，你可以参考《使用内存做虚拟磁盘》","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"C语言读取串口数据并16进制打印","slug":"c-language-read-serial-data-hexadecimal-printing","date":"2015-08-05T15:21:49.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"c-language-read-serial-data-hexadecimal-printing.html","link":"","permalink":"https://baiyuan.wang/c-language-read-serial-data-hexadecimal-printing.html","excerpt":"","text":"区域控制器串口协议1、通信格式&#x3D;[帧头]+ [数据长度]+ [指令代码]+ [通信内容]+ [校验和]+ [帧尾]。 2、数据长度为从帧头至帧尾的所有字节(包含帧头、帧尾)总数； 3、校验和为校验位前面所有字节的异或； 4、RS232 串口通信，波特率 9600，无奇偶校验，8 位数据位，1 位停止位。 5、多字节传送数据时，高位在前，低位在后 关键代码port.cpp&#x2F;&#x2F; port.cpp : 定义控制台应用程序的入口点。&#x2F;&#x2F;#include “stdafx.h”#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;HANDLE hCom;int main(void){ hCom &#x3D; CreateFile(TEXT(“COM1”),&#x2F;&#x2F;COM1口 GENERIC_READ | GENERIC_WRITE, &#x2F;&#x2F;允许读和写 0, &#x2F;&#x2F;独占方式 NULL, OPEN_EXISTING, &#x2F;&#x2F;打开而不是创建 0, &#x2F;&#x2F;同步方式 NULL); if (hCom &#x3D;&#x3D; (HANDLE)-1) { printf(“打开COM失败!\\n”); return FALSE; } else { printf(“COM打开成功！\\n”); } SetupComm(hCom, 1024, 1024); &#x2F;&#x2F;输入缓冲区和输出缓冲区的大小都是1024 COMMTIMEOUTS TimeOuts; &#x2F;&#x2F;设定读超时 TimeOuts.ReadIntervalTimeout &#x3D; 1000; TimeOuts.ReadTotalTimeoutMultiplier &#x3D; 5000; TimeOuts.ReadTotalTimeoutConstant &#x3D; 5000; &#x2F;&#x2F;设定写超时 TimeOuts.WriteTotalTimeoutMultiplier &#x3D; 5000; TimeOuts.WriteTotalTimeoutConstant &#x3D; 2000; SetCommTimeouts(hCom, &amp;TimeOuts); &#x2F;&#x2F;设置超时 DCB dcb; GetCommState(hCom, &amp;dcb); dcb.BaudRate &#x3D; 9600; &#x2F;&#x2F;波特率为9600 dcb.ByteSize &#x3D; 8; &#x2F;&#x2F;每个字节有8位 dcb.Parity &#x3D; NOPARITY; &#x2F;&#x2F;无奇偶校验位 dcb.StopBits &#x3D; ONE5STOPBITS; &#x2F;&#x2F;1个停止位 SetCommState(hCom, &amp;dcb); DWORD wCount=12;//读取的字节数 BOOL bReadStat; while (1) &#123; PurgeComm(hCom, PURGE\\_TXCLEAR | PURGE\\_RXCLEAR); //清空缓冲区 unsigned char str\\[13\\] = &#123; 0 &#125;; printf(&quot;%s\\\\n&quot;, str); bReadStat = ReadFile(hCom, str,13, &amp;wCount, NULL); if (!bReadStat) &#123; printf(&quot;读串口失败!&quot;); return FALSE; &#125; else &#123; str\\[12\\] = &#39;*&#39;; for (int i = 0; str\\[i\\] != &#39;*&#39;; i++)&#123; printf(&quot;%02X &quot;, str\\[i\\]); //printf(&quot;%u&quot;,str\\[i\\]); &#125; &#125; //unsigned char a=&#39;0&#39;; //unsigned char b = &#39;0x01&#39;; if (str\\[6\\]==0)&#123; printf(&quot; 无车&quot;); &#125; else if(str\\[6\\]==1)&#123; printf(&quot; 有车&quot;); &#125; else printf(&quot; 有错&quot;); printf(&quot;\\\\n&quot;); Sleep(100); &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"PHP实现酒店查询:WEB+SQL数据库+JSON-API","slug":"php-hotel-query-web-sql-json-api","date":"2015-07-27T13:56:20.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"php-hotel-query-web-sql-json-api.html","link":"","permalink":"https://baiyuan.wang/php-hotel-query-web-sql-json-api.html","excerpt":"","text":"项目复述：PROBLEM : HOTEL RESERVATION A hotel chain operating in Miami wishes to offer room reservation services over the internet. They have three hotels in Miami: Lakewood, Bridgewood and Ridgewood. Each hotel has separate weekday and weekend (Saturday and Sunday) rates. There are special rates for rewards customer as a part of loyalty program. Each hotel has a rating assigned to it. Lakewood with a rating of 3 has weekday rates as 110$ for regular customer and 80$ for rewards customer. The weekend rates are 90$ for regular customer and 80$ for a rewards customer. Bridgewood with a rating of 4 has weekday rates as 160$ for regular customer and 110$ for rewards customer. The weekend rates are 60$ for regular customer and 50$ for a rewards customer. Ridgewood with a rating of 5 has weekday rates as 220$ for regular customer and 100$ for rewards customer. The weekend rates are 150$ for regular customer and 40$ for a rewards customer. Write a program to help an online customer find the cheapest hotel. The input to the program will be a range of dates for a regular or rewards customer. The output should be the cheapest available hotel. In case of a tie, the hotel with highest rating should be returned. 项目思路和特点数据利于维护对于一个实际生活中的项目，一个酒店的星级、价格不可能是一成不变的，为了更好地维护酒店和价格信息，利于系统后期的修改，极客人决定采用数据库管理数据。鉴于本题的要求，本项目在实现时只写了客户查询酒店信息的WEB界面，对于管理人员可能后续修改酒店的星级、名称、价格可以在数据库进行操作，本项目未予实现利于管理员操作的管理界面。 平台易拓展本项目虽然采用PHP实现功能，客户的查询操作在WEB平台上实现，但是极客人特地在服务器上部署了生成JSON数据包的代码，利于将相关功能拓展到JAVA&#x2F;C&#x2F;C++等平台上。注：由于不涉及隐私信息，HTTP传值方式暂定为GET，当然post方式原理大致相同。 使用Bootstrap前端库构建界面为了尽快实现界面和界面的美观，本项目采用开源WEB前端库：Bootstrap 项目文件结构 公用代码类hotelOrder：酒店订购安排类，构造函数传入开始时间，结束时间，顾客类型代号 startDate = $istartDate;//开始时间 $this -> endDate = $iendDate;//结束时间 $this -> customertype = $icustomertype;//顾客类型代号，0：普通顾客；1：rewards顾客 } function getChoices() { // $CheapestHotelName = \"null\"; require ('../db_connect.php'); $string = \"select * from HOTEL_RESERVATION \"; $str = @mysqli\\_query($software\\_db, $string); while ($row = mysqli\\_fetch\\_array($str, MYSQLI_ASSOC)) { $countsOfDay=$this->CountOfWeekend_WeekDay(); if($this->customertype==0){//普通顾客 $totalPrice\\['name'\\]=$row\\['name'\\]; $totalPrice\\['price'\\]=$countsOfDay\\['Weekend'\\]*$row\\['rates\\_for\\_regular\\_In\\_weekend'\\] +$countsOfDay\\['WeekDay'\\]*$row\\['rates\\_for\\_regular\\_In\\_weekday'\\]; $totalPrice\\['rating'\\]=$row\\['rating'\\]; $choice\\[\\]=$totalPrice; }elseif($this->customertype==1){//rewards顾客 $totalPrice\\['name'\\]=$row\\['name'\\]; $totalPrice\\['price'\\]=$countsOfDay\\['Weekend'\\]*$row\\['rates\\_for\\_rewards\\_In\\_weekend'\\] +$countsOfDay\\['WeekDay'\\]*$row\\['rates\\_for\\_rewards\\_In\\_weekday'\\]; $totalPrice\\['rating'\\]=$row\\['rating'\\]; $choice\\[\\]=$totalPrice; } } //echo $countsOfDay\\['Weekend'\\].\" \".$countsOfDay\\['WeekDay'\\]; // $json = json_encode($choice); // return $json; return $choice; } function getCheapest() { $choices=$this->getChoices(); $prices = array(); $ratings = array(); foreach ($choices as $choice){ $prices\\[\\]=$choice\\['price'\\]; $ratings\\[\\]=$choice\\['rating'\\]; } array\\_multisort($prices, SORT\\_ASC, $ratings, SORT_ASC, $choices); return $choices; } /\\*\\* \\* 判断日期是不是周末 */ private function isWeekend($date) { date\\_default\\_timezone_set('PRC'); $w = intval(date('w', strtotime($date))); if ($w === 0 || $w === 6) { return true; } else return false; } /\\*\\* \\* 获取指定时间段内周末和工作日天数 */ private function CountOfWeekend_WeekDay() { $count\\['Weekend'\\]=0; $count\\['WeekDay'\\]=0; date\\_default\\_timezone_set('PRC'); for ($start = strtotime($this ->startDate); $start endDate)+86400; $start += 86400) //这里遍历日期，所以每次增加86400秒 { //echo $start.' '; $w = intval(date('w', $start)); if ($w === 0 || $w === 6) { $count\\['Weekend'\\]++; } else $count\\['WeekDay'\\]++; } return $count; } } ?> web界面代码：查询首页index.php: 酒店预订-powered by 王柏元 酒店预订查询系统 输入你下榻的起始-结束日期 开始日期： 结束日期： &lt;span class=&quot;input-group-addon&quot;&gt; &lt;input type=&quot;radio&quot; value=&quot;0&quot; checked=&quot;true&quot; name=&quot;type&quot; aria-label=&quot;...&quot;/&gt;regular customer &lt;/span&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;input type=&quot;radio&quot; value=&quot;1&quot; name=&quot;type&quot; aria-label=&quot;...&quot;/&gt;rewards customer &lt;/span&gt; &lt;/span&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot;&gt;查询&lt;/button&gt; 查询结果页：result.php: getChoices()); //echo json_encode($hotelorder->getCheapest()); $choices = $hotelorder -> getCheapest(); ?> 酒店预订查询结果-powered by 王柏元 酒店预订查询结果 返回 优先级从高到低 酒店名称 总价格 酒店等级 演示网址：http://baiyuan.wang/others/hotel_reservation&#x2F;index.php 演示截图： 可扩展到其他平台的JSON输出代码JsonCheapestHotel.php: getCheapest()); ?> 输出实例：[{“name”:”Lakewood”,”price”:720,”rating”:”3”},{“name”:”Ridgewood”,”price”:780,”rating”:”5”},{“name”:”Bridgewood”,”price”:870,”rating”:”4”}]","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"json","slug":"json","permalink":"https://baiyuan.wang/tags/json/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"梦“杭”行-参访阿里巴巴","slug":"dream-hangzhou-line-visit-alibaba","date":"2015-07-25T14:51:52.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"dream-hangzhou-line-visit-alibaba.html","link":"","permalink":"https://baiyuan.wang/dream-hangzhou-line-visit-alibaba.html","excerpt":"","text":"一些废话作为先导当今中国的互联网格局，已成“BAT”三足鼎立之势。BAT，百度、阿里巴巴、腾讯。三者各有千秋，百度的搜索，阿里巴巴的电商服务，腾讯的社交，都在各自领域代表着中国的最高水准。作为与IT相关的人，对这几家公司都会有一定的向往之情。 百度总部在北京，腾讯的总部在深圳，而阿里巴巴的总部及其部分园区则恰位于我们这次社会实践活动进行的杭州市。马云，阿里巴巴教父级总裁，出生于浙江杭州，毕业于杭州师范学院，把总部和几个园区设立在杭州自然不足为奇。以前我对一个地方出的人物对这个地方能有多大的影响并不感冒，但是这次却亲身感受到。人杰然后凸显地灵。支付宝风靡全国，在杭州影响尤甚。当你走过杭州大大小小的餐饮店，你会发现柜台前“支付宝扫一扫付款”是多么的醒目，这恐怕是其它任何一个城市无法企及的。说到这，发现这几个大boss设立总部的城市还是蛮有意思的，李彦宏在北大，现在百度总部在北京；马化腾深圳大学毕业，现在腾讯总部在深圳！ 16楼参观，马总你真有情怀在社会实践活动出发前，我们约好了在阿里巴巴工作的师兄师姐。上午我们访问了蚂蚁金服，中午逛了一下西溪公园，下午访问西溪园区。在蚂蚁金服，接待我们的一个学姐，在西溪园区接待我们的是一个学姐和两位学长。 来到阿里巴巴大楼，我们根据阿里事前给我们发送的邀请短信在类似银行柜员机的机器前输入访问ID，然后机器里就吐出了几张票作为访问通行证。 参观的目的是在参观办公陈设、人员面貌的同时窥探一个企业的企业文化。 在这次参访中，我们的活动范围只有“支付宝”大厦16楼，根据阿里巴巴的公司制度，每年只有一天职工可以带着自己的亲友参观他们的办公环境（无法让我们看到传说中程序猿的办公环境是我们本次参观的一个遗憾），这一天是5月20日—阿里日又称“亲友日”，2005年阿里巴巴公司为了纪念2003年5月的“非典”时期阿里人的激情和信念。学姐告诉我们，2003年的非典，在杭州的阿里员工及其家人朋友近千人从5月7日起开始了为期一个星期的隔离生活，阿里人可以在家里完成自己的工作。到隔离结束，没有人察觉到阿里巴巴的任何变化，相反，阿里的业绩却未因为非典受挫，并突破当月历史新高。同时，每年的这一天，阿里巴巴公司都会有庆祝活动，举行集体婚礼。 支付宝大厦16楼基本是一个展示厅，在一面墙上是显示蚂蚁金服业务在全国的实时监控的巨幕显示屏（来自百度百科：蚂蚁金服旗下的业务包括支付宝、支付宝钱包、余额宝、招财宝、蚂蚁小贷和网商银行（筹）等），这个场景十分炫酷、科幻感超强（因为禁止拍照，所以没图）。在这块荧幕中标注了蚂蚁金服业务在全国实时进行的热度图，已经此时全国用户的转账等记录，极客人想验证一下就掏出手机拿出支付宝转了一笔账，不过并没有发现自己的账户在列。 阿里巴巴是个集团，旗下业务很多，不过跟我们生活息息相关的几个业务好像都在蚂蚁金服，除此以外可能最为大众熟知的就是淘宝、天猫，还有被IT人士、站长了解的阿里云了。尽管阿里的规模很大，但依旧在扩大业务面，几个园区和分布在各地的分公司也各司其职。 在了解这些的期间，学姐也给我爆料一个我似乎在百度找不到的段子。由于业务的需要，本来阿里的一些业务需要搬迁到一座新楼，这座新楼已经完工，但是马总叫人看了一下风水，由于风水不好，搬迁的工作暂告搁浅；现在正在重建一座新楼，而已经建好的大楼如今一直是座空楼。唉，杭州城，寸土寸金，建好的大楼不用就是浪费。我只能说：“马总，你真有“‘情怀’”。 在展厅一侧的圆柱勾起的兴趣，柱子外有玻璃围绕，这根柱子名叫“手印墙”。“手印墙”周身书写了几句诗句，大意是阿里拼搏进取之志；上嵌颜色各异的手掌大小盾牌，盾牌里则填满了手掌印。阿里员工会在“手印墙”上留下自己的手印，大致意思是按手印立信，而“信”，是支付宝等公司的立身之本。 总的来说，阿里巴巴蚂蚁金服里面的环境大气又不失优雅。玻璃幕墙，街景一览无余，室内有盆景藤蔓，淡雅整洁。不过16楼应该只是单纯的展示厅，再好也只是参观，工作人员真正的办公环境我们不得而知。在此如果我说的再多，就可能沦为为阿里写软文了。 工作还是读研在阿里巴巴接待我们的师兄师姐是清一色的研究生毕业，入职都不久。根据他们的表述，研究生被招进阿里的几率更大，不过他们都基本认为在本科时期就能进入阿里是最好的，因为在企业中我们接触的往往是与实际生活相关的东西，在学校里读研固然能学到更多的理论，但是其实进入企业、企业还是要花相当长的时间来培训你。也有学长提到：研究生的潜力比较大，但刚入职的时候会有落差感。 就目前在阿里巴巴等等公司的招聘公告和我对互联网公司的了解，它们并没有多少公司对应聘者的学历院校甚至专业有门槛。和阿里的招聘的公告一样，学姐也谈到进阿里专业不是问题，只要你对互联网计算机有一颗热爱的心。其实这个也并不奇怪，因为互联网专业相对航天航空这些专业需要强大的硬件设施来支撑，没有公司给你试验器材你根本玩不转，而IT业则不同，只要给你网，给你电脑，你就可以自学很多东西、实现很多东西，这些你可以通过许多网络黑客仅仅是初中毕业这些事实得到佐证。 没有外物给你的高门槛，羁绊与成就你的，就恰恰是你自己的实力，同时也决定这个行业竞争相当残酷。 阿里等级制度带来的启示阿里的技术岗等级代号为“P”，管理岗为“M”。本科生进入阿里巴巴的初始等级为P4，研究生为P5，这些等级大致决定了你的薪酬和阿里对你的能力认定。每年阿里会有一个答辩会让员工展示自己的绩效然后评分决定你是否可以升级。 根据学姐学长的表述，我从互联网上找到下面的阿里巴巴的等级表与技术-管理映射关系： 了解一个你还没进入的互联网公司的管理制度，我想似乎和我们并没有半毛钱关系。然而在与师兄师姐们的交流中，我们学习到的是重新审视了自己的求职观： ①找一个你有实力胜任、很愉快地去奉献拼搏、薪酬丰厚但重要程度其次的工作在学校，我们大部分对未来理想工作的理解似乎很简单，工资高就好。IT是普遍认为比较辛苦、压力很大的一个行业，社会上对程序员的调侃有的的确过分了一点，但是某种程度也反映了现实。 我们问了在阿里工作的师兄师姐，他们的工作时间没有很苛刻的限制，必须几点上班，必须几点下班。加班往往也不是老板逼你，而是你心甘情愿或是受压力所迫。可能你在原则上规定的上班时间迟到或者早退，并没有人来管你或者罚你工资，但是，一个前提是：你必须完成团队分配给你的任务。团队对迟到早退的人“惩罚”也是象征性的，每次开会的时候出钱请大家吃水果。 一位师姐告诉我们，虽然公司给的下班时间是晚9点，但是她回到自己的住所后为了完成给的任务，常常也要到11点后才睡觉。 一位师兄说，在完成常规工作任务时，阿里并不赞同加班，他们甚至认为经常加班的原因是你能力不够。当然如果有临时特别重要的项目任务要加班加点来完成除外。 阿里每年有个绩效展示的答辩会，会根据你的评定得分决定你是否晋升。你连续几年的评分再差可能阿里巴巴都不会解雇你，因为公司主动辞你还要支付给员工一定的赔偿，但是这样的人往往会自己主动辞职，因为这样的工作可能是他无法胜任的，留在公司只会徒增痛苦，迫于压力和自信心的打击他必须寻找新的公司去找一个有实力胜任、很愉快地去奉献拼搏、薪酬丰厚但重要程度其次的工作。 ②你的第一个工作很重要同行的姚老师告诉我们，第一个工作你能否胜任，你能否愉快地去奉献，决定你以后工作生涯的心态，第一个工作如果让你充满信心，你以后的工作一路坦途，相反可能就会“破罐子破摔”。 ③程序猿技术能转管理很重要程序猿不可能干一辈子技术，如果要想在IT一直干下去，转型管理是关键。阿里技术的P6、P7分别对应管理的M1、M2，两者等价转换，当你的技术达到P6以上时，你可以自由选择是否转型做管理。 把研究生要做的事安排到大三大四来完成有学姐说的一段话令我印象深刻：在大学我们经常纠结去做许多事情，很多事与其纠结选择哪个，不如直接利用纠结的时间把两个都做了，只有在做的过程中才能更好的理解每个的本质。还有，很多人觉得自己在本科时期和别人差距有点大，想通过上研究生来弥补差距，但其实，完全可以在大三大四别人准备考研时你自己努力提高能力追赶别人，要知道两年时间可以做很多事的。如果对毕业后直接就业或者考研没有很清楚的倾向，学长们的建议是选择就业，一是在公司里的学习速度远比在学校里快，更容易接触到实际生活的问题，也更容易提高自己的能力。 其它①大三那个暑假实习很重要。阿里的暑假实习（实习工资5000左右）其实就是在做一个阿里员工新进阿里的培训适应工作。进阿里的前三个月，公司会对你进行一些授课形式的培训。如果你能在暑假实习就完成这些培训，无疑掌握了一些先机。这肯定不仅仅适用于阿里巴巴。 ②师兄师姐在阿里（当然不仅仅局限于阿里）帮我们算是积攒了一些资源，内推不仅仅为我们提供便利，也是在为他们积攒人气，好好把握这些资源。 参考文章：http://qiezhijia.wang/shu_qi_shi_jian_zhi_a_li_zhi_xing&#x2F;","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旅行","slug":"旅行","permalink":"https://baiyuan.wang/tags/%E6%97%85%E8%A1%8C/"},{"name":"工作求职","slug":"工作求职","permalink":"https://baiyuan.wang/tags/%E5%B7%A5%E4%BD%9C%E6%B1%82%E8%81%8C/"}]},{"title":"梦“杭”行-西子湖畔的青旅","slug":"dream-hangzhou-line-qinglv-of-west-lake","date":"2015-07-24T02:17:25.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"dream-hangzhou-line-qinglv-of-west-lake.html","link":"","permalink":"https://baiyuan.wang/dream-hangzhou-line-qinglv-of-west-lake.html","excerpt":"","text":"正是七月的三伏之天，江南的天气自然也是如同火燎一般。然而这种炎热与北方不同，潮湿的水汽仿佛在空气中已然饱和，加上无济于纳凉的微风，虽然我没蒸过桑拿，但是这种感觉再加上微薄的想象力，我想真实的桑拿应该与此无异吧。 早就听老师说杭州很潮，作为南方人的我不以为意。但是在西子湖畔的青年旅社或许因为依山傍水的缘故，氤氲在青龙山的水汽聚集在山间散发不开，我想这无疑增添了青旅的潮湿气息。（注：避免广告效果，旅社名隐去） 7月16日12时许，时快时慢、时停时续的1152次列车奔波了20多小时终于到达杭州，在杭州城站拍完合影后，我们匆匆赶赴青年旅社。青年旅社的环境比我想象中要好，虽然我们6个男生凑在一个6个床铺的单间，但是有wifi有空调（还有台球！），而且坐落在西子湖畔附近，得尽地利之便，虽然潮湿异常，心里也还是满足。 在青年旅社稍作休憩，下午7点许我们吃完晚饭，一行人安步当车，步行2公里左右前往西湖苏堤。由于宿舍的旅社就在附近，我们无需行色匆匆，漫步、聊天、在林荫下听蝉鸣，这一番惬意自是走马观花的现代旅行人无法体悟的。 夜间的西湖虽然不及白天游人如织但是依旧人多。夜色朦胧，晚上的西湖只能看见周围的城市和湖畔的雷峰塔的星光点点，湖面上的游轮画舫在灯光的映衬下隐约可见。 夜间无法看见西湖的真容，这番景色却别有韵味，有时候白天的风光虽然看的真切却有些“乱花渐欲迷人眼”，世间风光万种，忙忙碌碌的城市人恨不得在一天或一个假期阅尽人间春色，赏完神州山川，“给我80天，我去环游地球”。行色匆匆的旅行已经失去了旅行的真谛，心灵在旅行中并没有得到释放，而是面对应接不暇的风景无从下手、走马观花——心累。 你去过西湖吗？ ——当然！ 那去完西湖给你留下了什么？ ——我拍了好多照片！ 不过尔尔吗？ 夜色中，许多自行车骑行者在西湖清新的空气中环行西湖，许多老人在坐在湖边的长椅下避暑纳凉，我还看见一群光着膀子的貌似国防生在整队待发，正要下湖锻炼。我想领会西湖、领会旅行，他们还要深刻一点。","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旅行","slug":"旅行","permalink":"https://baiyuan.wang/tags/%E6%97%85%E8%A1%8C/"}]},{"title":"让梦想去“杭”行—出发","slug":"dream-hangzhou-travel-set-out","date":"2015-07-23T15:27:45.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"dream-hangzhou-travel-set-out.html","link":"","permalink":"https://baiyuan.wang/dream-hangzhou-travel-set-out.html","excerpt":"","text":"常常在想读大学的意义是什么。 平淡安逸的大学生活，我觉得自己仍旧和高中一样过得一样枯燥，教室、宿舍、食堂，生活更多地还是在这三点一线之间周而复始。没有高中繁重的学习压力，时间久了，有时候真会忘记自己在干什么。大一大二这两年，扪心自问我未曾虚度，我做过许多自己感兴趣的事情，研究技术让我获得自信与充实，写博客让我心灵更加澄澈。但我知道这还远远不够，这两年我的生活仍旧目的性不强，有时把玩网站与代码有时候并不是为了学习什么，而是心灵的一种寄托，闲时无聊的一种放松，这也许可以说是兴趣，但是提升自己的效率并不高。 枯燥紧张的生活过久了，有时需要给自己的心灵放一场假；一种环境呆久了容易产生惰意，有时需要换个环境审视自己；在学校呆久了容易狭隘，有时需要了解这个社会究竟需要什么。 在大二下学期结束的前两个月，同学找到我：“有没有参加今年的暑假社会实践活动呢？”。没有找到实习（这怪我不够勇敢）、不想回家太无聊，我几乎没有犹豫地答应了。 我是冲着“生存体验”这个项目去的，这个项目在辅导员一次班会提到过：选择一个实践队所有成员都没有去过的陌生城市，每天发放10块钱努力使自己生活下去。在这期间必定需要你自己去找事干，可以锻炼你在一个城市适应、找工作的能力，期间在该城市的住宿、公交费学校会报销部分。这听起来无疑十分刺激，就像电视里“交换空间”之类的节目。 在学校的社会实践指导文件中正式下发下来，里面并没有往年的“生存体验”，冲着这个项目而去的几个队友感到强烈的挫败感，一度想妥协换成其它主题：比如支教与企业考察。在“几经波折”后，我们在学校下发的文件找到这么一个项目：”探究大学生的生存能力“，然后学校的意思更多是让我进行调研考察。好在学校的社会实践项目就像写作文：给个话题，具体以怎样的形式实施、怎样去实施，全靠自己策划。于是，一个”钻制度漏洞“的想法产生了，我们可以用自己的实际太践行”大学生的生存能力“——也就是”生存体验“，再辅以企业考察、问卷调研。 这无疑是一个标新立异的立意。 一、出发我们把所有人都没去过的陌生城市最终设定为”杭州“。 在完成策划的过程中我们联系到了阿里巴巴，并把阿里巴巴作为社会实践的第一站。阿里巴巴作为中国国内BAT三巨头之一，无疑也是无数IT业者心驰神往的地方，所有出行前又多了一个期待就是拜访一下阿里、向在阿里就职的师兄师姐就就业方面取经求教。 大概出发的前一周，我们收到了阿里巴巴的蚂蚁金服和西溪园区的欢迎短信： 【蚂蚁金服】亲，您好！您将于 2015-07-17来访蚂蚁金服集团（黄龙时代广场B座），来访ID为382，无线网络（alibaba-guest）用户名及密码：1882923*，请您安排好时间。祝您来访愉快！ 访客须知详见http://tao.bb/3JkQ7 【阿里巴巴】亲，您好！欢迎您于 2015-07-16 来访阿里巴巴西溪园区，您的来访ID是373，无线网络（alibaba-guest）用户名及密码：1882923*，请注意保管并在入园时出示，祝您来访愉快！ 带着对自古有“上有天堂，下有苏杭“美誉的杭州的遐想，心里充满着对阿里巴巴参访的期待，我们怀揣梦想，背上行囊，从西安出发，坐上历经21小时的火车，让梦想去“杭”行。","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旅行","slug":"旅行","permalink":"https://baiyuan.wang/tags/%E6%97%85%E8%A1%8C/"}]},{"title":"自己动手制作图标字体","slug":"oneself-start-work-make-icon-fonts","date":"2015-07-13T10:10:51.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"oneself-start-work-make-icon-fonts.html","link":"","permalink":"https://baiyuan.wang/oneself-start-work-make-icon-fonts.html","excerpt":"","text":"位图和矢量图世界上不是所有的事物都适合用审慎的眼光来看待，有的东西只可远观、不可近看。一张图片，放大放大再放大，不论是单反的拍摄的巨照，还是几十兆的数码相片，放大之后便如同大量马赛克一样，显露出图像的本质——点（也就是像素）。我们看到的丰富多彩的照片实际上就是由一个个点组会而成，存储图片只要描述出每一个像素点的颜色，将把像素汇聚一体，抽身远观之下，就是一幅绚丽的图片。 如上图所讲，我们会想到数学课本上举世公认的定理：面由点组成。这似乎也没什么错，但是今天我说面是由线组成的，你可能会觉得我只是玩一个文字游戏。其实我想讲的是，这两种表述其实代表两种计算机图片格式的思路——位图和矢量图。如果说“面是由点组成的”，我说的是“位图”；如果说“面是由线组成的”，我说的是矢量图。这两种表述在表面上没什么大区别，其实在表示图像上与很大的区别。 位图使用我们称为像素的一格一格的小点来描述图像.您的计算机屏幕其实就是一张包含大量像素点的网格.在位图中,上面我们看到的树叶图像将会由每一个网格中的像素点的位置和色彩值来决定.每一点的色彩是固定的,当我们在更高分辨率下观看图像时,每一个小点看上去就像是一个个马赛克色块。 矢量图使用线段和曲线描述图像,所以称为矢量,同时图形也包含了色彩和位置信息.下面例子中的树叶,就是利用大量的点连接成曲线来描述树叶的轮廓线.然后根据轮廓线,在图像内部填充一定的色彩。 图标字体矢量图你之前也许闻所未闻，甚至直到看到这篇文章你才惊悉它的存在。实际上你一直就在矢量图的“此山中”，你所看见的计算机字体其实就是矢量图，证明的途径就是：你不管把word的字体调多大，它都是那么清晰，字的轮廓边缘还是那么圆滑平整。 使用wordpress让我有缘结识了图标字体，诚如你所见，王柏元的博客导航菜单上所用的图标就是图标字体，因为你会发现它和文字无异可以和文字一样改变颜色、设置大小还永远都是高保真。 wordpress上fontawesome用的极为广泛，国内也有阿里巴巴矢量图标库。图标字体的使用为网站开发省去许多美工的工作。初见图标字体你一定会惊叹它的神奇，进而你可能追本溯源想知道它究竟是怎么做出来的。 使用icomoon制作个性图标字体当你设计出一个很美观的图形、头像，或者当你对自己的毛笔字很自信，同时你又对书法家字体用到枯燥乏味的时候——你想在网站中使用自己的图案或者甚至将PPT的通篇文字都设置你自己的毛笔字体。那么，使用icomoon制作个性图标字体就是不错的选择。 制作图标字体的第一步是制作矢量图要制作矢量图，一个简便的方法就是将位图转换为矢量图。因为得到位图的方式很简单，你只需要用手机将你设计的图案或者毛笔书法作品拍摄下来就得到位图了。","categories":[{"name":"前端","slug":"前端","permalink":"https://baiyuan.wang/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"FontAwesome","slug":"FontAwesome","permalink":"https://baiyuan.wang/tags/FontAwesome/"},{"name":"图标字体","slug":"图标字体","permalink":"https://baiyuan.wang/tags/%E5%9B%BE%E6%A0%87%E5%AD%97%E4%BD%93/"}]},{"title":"【转】最短路径Dijkstra和Floyd算法","slug":"shortest-path-dijkstra-floyd-algorithm","date":"2015-07-05T07:28:17.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"shortest-path-dijkstra-floyd-algorithm.html","link":"","permalink":"https://baiyuan.wang/shortest-path-dijkstra-floyd-algorithm.html","excerpt":"","text":"Dijkstra算法1.定义概览Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。 问题描述：在无向图 G&#x3D;(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径） 2.算法描述1)算法思想：设G&#x3D;(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。 2)算法步骤： a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U&#x3D;{其余顶点}，若v与U中顶点u有边，则&lt;u,v&gt;正常有权值，若u不是v的出边邻接点，则&lt;u,v&gt;权值为∞。 b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。 c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。 d.重复步骤b和c直到所有顶点都包含在S中。 执行动画过程如下图 3.算法代码实现： const int MAXINT &#x3D; 32767;const int MAXNUM &#x3D; 10;int dist[MAXNUM];int prev[MAXNUM]; int A[MAXUNM][MAXNUM]; void Dijkstra(int v0){ bool S[MAXNUM]; &#x2F;&#x2F; 判断是否已存入该点到S集合中 int n&#x3D;MAXNUM; for(int i&#x3D;1; i&lt;&#x3D;n; ++i) { dist[i] &#x3D; A[v0][i]; S[i] &#x3D; false; &#x2F;&#x2F; 初始都未用过该点 if(dist[i] &#x3D;&#x3D; MAXINT) prev[i] &#x3D; -1; else prev[i] &#x3D; v0; } dist[v0] &#x3D; 0; S[v0] &#x3D; true; for(int i&#x3D;2; i&lt;&#x3D;n; i++) { int mindist &#x3D; MAXINT; int u &#x3D; v0; &#x2F;&#x2F; 找出当前未使用的点j的dist[j]最小值 for(int j&#x3D;1; j&lt;&#x3D;n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) { u &#x3D; j; &#x2F;&#x2F; u保存当前邻接点中距离最小的点的号码 mindist &#x3D; dist[j]; } S[u] &#x3D; true; for(int j&#x3D;1; j&lt;&#x3D;n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) { if(dist[u] + A[u][j] &lt; dist[j]) &#x2F;&#x2F;在通过新加入的u点路径找到离v0点更短的路径 { dist[j] &#x3D; dist[u] + A[u][j]; &#x2F;&#x2F;更新dist prev[j] &#x3D; u; &#x2F;&#x2F;记录前驱顶点 } } }} 4.算法实例先给出一个无向图 用Dijkstra算法找出以A为起点的单源最短路径步骤如下 Floyd算法1.定义概览Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。 2.算法描述1)算法思想原理： Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在） 从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) &#x3D; Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。 2).算法描述： a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。 3).Floyd算法过程矩阵的计算—-十字交叉法 方法：两条线，从左上角开始计算一直到右下角 如下所示 给出矩阵，其中矩阵A是邻接矩阵，而矩阵Path记录u,v两点之间最短路径所必须经过的点 相应计算方法如下： 最后A3即为所求结果 3.算法代码实现 typedef struct{ char vertex[VertexNum]; &#x2F;&#x2F;顶点表 int edges[VertexNum][VertexNum]; &#x2F;&#x2F;邻接矩阵,可看做边表 int n,e; &#x2F;&#x2F;图中当前的顶点数和边数}MGraph;void Floyd(MGraph g){ int A[MAXV][MAXV]; int path[MAXV][MAXV]; int i,j,k,n&#x3D;g.n; for(i&#x3D;0;i&lt;n;i++) for(j&#x3D;0;j&lt;n;j++) { A[i][j]&#x3D;g.edges[i][j]; path[i][j]&#x3D;-1; } for(k&#x3D;0;k&lt;n;k++) { for(i&#x3D;0;i&lt;n;i++) for(j&#x3D;0;j&lt;n;j++) if(A[i][j]&gt;(A[i][k]+A[k][j])) { A[i][j]&#x3D;A[i][k]+A[k][j]; path[i][j]&#x3D;k; } }} 算法时间复杂度:O(n3)","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"[转]一篇文章概述网络层次","slug":"the-article-summarizes-network-level","date":"2015-07-04T08:21:53.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"the-article-summarizes-network-level.html","link":"","permalink":"https://baiyuan.wang/the-article-summarizes-network-level.html","excerpt":"","text":"这篇文章主要介绍了网络协议概述：物理层、链路层、网络层、传输层、应用层详解,本文用生活中的邮差与邮局来帮助理解复杂的网络协议,通俗易懂,文风幽默,是少见的好文章,需要的朋友可以参考下 信号的传输总要符合一定的协议(protocol)。比如说长城上放狼烟，是因为人们已经预先设定好狼烟这个物理信号代表了“敌人入侵”这一抽象信号。这样一个“狼烟&#x3D;敌人入侵”就是一个简单的协议。协议可以更复杂，比如摩尔斯码(Morse Code)，使用短信号和长信号的组合，来代表不同的英文字母。比如SOS(—, 代表短信号，-代表长信号)。这样”&#x3D; S, —&#x3D;O”就是摩尔斯码规定的协议。然而更进一层，人们会知道SOS是求助信息，原因是我们有“SOS&#x3D;求救”这个协议存在在脑海里。所以”—**&#x3D;SOS&#x3D;求救”是一个由两个协议组成的分层通信系统。 使用Morse Code的电报机 计算机之间的通信也要遵循不同层次的协议，来实现计算机的通信。 物理层(physical layer)所谓的物理层，是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示0和1，比如用高电压表示1，低电压表示0，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0&#x2F;1序列。 链路层(link layer)在链路层，信息以帧(frame)为单位传输。所谓的帧，是一段有限的0&#x2F;1序列。链路层协议的功能就是识别0&#x2F;1序列中所包含的帧。比如说，根据一定的0&#x2F;1组合识别出帧的起始和结束。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。链路层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。 以太网(Ethernet)和WiFi是现在最常见的链路层协议。通过链路层协议，我们可以建立局域的以太网或者WiFi局域网，并让位于同一局域网络中的两台计算机通信。链路层就像是一个社区的邮差，他认识社区中的每一户人。社区中的每个人都可以将一封信(帧)交给他，让他送给同一社区的另一户人家。 链路层：社区小邮差 网络层(network layer)不同的社区之间该如何通信呢？ 换句话说，如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: 1. 能从物理层上在两个网络的接收和发送0&#x2F;1序列， 2. 能同时理解两种网络的帧格式。路由器(router)就是为此而产生的“翻译”。 一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的链路层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局。一个社区的邮差将信送到本社区的邮局分支，而邮局会通过自己在另一个地区的分支将信转交给另一个社区的邮差手中，并由另一个社区的邮差最终送到目的地。 通过路由连接的WiFi和以太网 整个通信过程如下: WiFi上的计算机1 -&gt; 路由WiFi接口 -&gt; 路由以太网接口 -&gt; 以太网上的计算机2 (蓝色表示WiFi网络，绿色表示以太网络) 在链路层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠链路层协议无法满足我们的需要。由于链路层协议开发在先，我们无法改动链路层协议，只能在链路层的数据(payload)，也就是信纸内部下功夫了。IP协议应运而生。 计算机1，路由器和计算机2都要懂得IP协议。 当计算机1写信的时候，会在信纸的开头写上这封信的出发地址和最终到达地址 (而不是在信封上)，而在信封上写上要送往邮局。WiFi网的邮差将信送往邮局。 在邮局，信被打开，邮局工作人员看到最终地址，于是将信包装在一个新的信封中，写上出发地为邮局，到达地为计算机2，并交给以太网的邮差，由以太网的邮差送往计算机2。 (IP协议还要求写如诸如校验等信息，交通状况等信息，以保护通信的稳定性。) 转交给邮局 在链路层，邮差只负责在本社区送信，所以信封上的地址总是“第一条街第三座房子”或者说“中心十字路口拐角的小房子”这样一些本地人才了解的地址描述，这给邮局的工作带来不便。所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是IP地址。这个地址为世界上的每一个房子编号(邮编)。当信件送到邮局的时候，邮局根据邮编，就能查到对应的地址描述，从而能顺利改写信封上的信息。 每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网。 传输层(transport layer)上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求。这就好像一所房子里住了好几个人(进程)，如何让信精确的送到某个人手里呢？遵照之前相同的逻辑，我们需要在信纸上写上新的信息，比如收信人的姓名，才可能让信送到。所以，传输层就是在信纸的空白上写上新的“收信人”信息。每一所房子会配备一个管理员(传输层协议)。管理员从邮差手中接过信，会根据“收信人”，将信送给房子中的某个人。 管理员 传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。 TCP和UDP协议是两种不同的传输层协议。UDP协议类似于我们的信件交流过程。TCP协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。TCP协议还有控制网络交通等功能。 应用层(application layer)通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。然而每个人实际上从事的是不同的行业。有的人是律师，有的人外交官。比如说律师之间的通信，会用严格的律师术语，以免产生纠纷。再比如外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。 总结总过网络分层，我们从原始的0&#x2F;1序列抽象出 ： 本地地址(邮差)、邮编(邮局)、收信人(管理员)、收信人行业(用语规范) 这些概念。这些概念最终允许互联网上的分布于两台计算机的两个进程相互通信。 写信人必须按照各层的协议，封装好整个信封 (encapsulation)； 而收信人则按照相反的顺序，来拆开这个信封。整个过程是可读信息 -&gt; 二进制 -&gt; 可读信息。计算机只能理解和传输0&#x2F;1序列，而计算机的用户则总是输入和输出可读信息。 网络协议保证了可读信息在整个转换和传输过程中的完整性。 计算机协议本身还有更多的细节需要深入。这篇文章只是从分层的角度描述各个层次所实现的功能。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"IP","slug":"IP","permalink":"https://baiyuan.wang/tags/IP/"}]},{"title":"【资料】curl_setopt函数相关参数介绍","slug":"curl-setopt-func-parameter-introduce","date":"2015-06-30T12:05:30.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"curl-setopt-func-parameter-introduce.html","link":"","permalink":"https://baiyuan.wang/curl-setopt-func-parameter-introduce.html","excerpt":"","text":"curl_setopt()函数将为一个CURL会话设置选项。option参数是你想要的设置，value是这个选项给定的值。 下列选项的值将被作为长整形使用(在option参数中指定)： CURLOPT_INFILESIZE: 当你上传一个文件到远程站点，这个选项告诉PHP你上传文件的大小。 **CURLOPT_VERBOSE:**如果你想CURL报告每一件意外的事情，设置这个选项为一个非零值。 **CURLOPT_HEADER:**如果你想把一个头包含在输出中，设置这个选项为一个非零值。 **CURLOPT_NOPROGRESS:**如果你不会PHP为CURL传输显示一个进程条，设置这个选项为一个非零值。 注意：PHP自动设置这个选项为非零值，你应该仅仅为了调试的目的来改变这个选项。 **CURLOPT_NOBODY:**如果你不想在输出中包含body部分，设置这个选项为一个非零值。 **CURLOPT_FAILONERROR:**如果你想让PHP在发生错误(HTTP代码返回大于等于300)时，不显示，设置这个选项为一人非零值。默认行为是返回一个正常页，忽略代码。 **CURLOPT_UPLOAD:**如果你想让PHP为上传做准备，设置这个选项为一个非零值。 **CURLOPT_POST:**如果你想PHP去做一个正规的HTTP POST，设置这个选项为一个非零值。这个POST是普通的 application&#x2F;x-www-from-urlencoded 类型，多数被HTML表单使用。 **CURLOPT_FTPLISTONLY:**设置这个选项为非零值，PHP将列出FTP的目录名列表。 **CURLOPT_FTPAPPEND:**设置这个选项为一个非零值，PHP将应用远程文件代替覆盖它。 **CURLOPT_NETRC:**设置这个选项为一个非零值，PHP将在你的 ~.&#x2F;netrc 文件中查找你要建立连接的远程站点的用户名及密码。 ****CURLOPT_FOLLOWLOCATION:设置这个选项为一个非零值(象 ‘Location:‘)的头，服务器会把它当做HTTP头的一部分发送(注意这是递归的，PHP将发送形如 ‘Location:‘的头)。 **CURLOPT_PUT:**设置这个选项为一个非零值去用HTTP上传一个文件。要上传这个文件必须设置CURLOPT_INFILE和CURLOPT_INFILESIZE选项. **CURLOPT_MUTE:**设置这个选项为一个非零值，PHP对于CURL函数将完全沉默。 **CURLOPT_TIMEOUT:**设置一个长整形数，作为最大延续多少秒。 **CURLOPT_LOW_SPEED_LIMIT:**设置一个长整形数，控制传送多少字节。 **CURLOPT_LOW_SPEED_TIME:**设置一个长整形数，控制多少秒传送CURLOPT_LOW_SPEED_LIMIT规定的字节数。 **CURLOPT_RESUME_FROM:**传递一个包含字节偏移地址的长整形参数，(你想转移到的开始表单)。 **CURLOPT_SSLVERSION:**传递一个包含SSL版本的长参数。默认PHP将被它自己努力的确定，在更多的安全中你必须手工设置。 **CURLOPT_TIMECONDITION:**传递一个长参数，指定怎么处理CURLOPT_TIMEVALUE参数。你可以设置这个参数为TIMECOND_IFMODSINCE 或 TIMECOND_ISUNMODSINCE。这仅用于HTTP。 **CURLOPT_TIMEVALUE:**传递一个从1970-1-1开始到现在的秒数。这个时间将被CURLOPT_TIMEVALUE选项作为指定值使用，或被默认TIMECOND_IFMODSINCE使用。 下列选项的值将被作为字符串： **CURLOPT_URL:**这是你想用PHP取回的URL地址。你也可以在用curl_init()函数初始化时设置这个选项。 **CURLOPT_USERPWD:**传递一个形如[username]:[password]风格的字符串,作用PHP去连接。 **CURLOPT_PROXYUSERPWD:**传递一个形如[username]:[password] 格式的字符串去连接HTTP代理。 **CURLOPT_RANGE:**传递一个你想指定的范围。它应该是’X-Y’格式，X或Y是被除外的。HTTP传送同样支持几个间隔，用逗句来分隔(X-Y,N-M)。 **CURLOPT_POSTFIELDS:**传递一个作为HTTP “POST”操作的所有数据的字符串。 **CURLOPT_REFERER:**在HTTP请求中包含一个’referer’头的字符串。 **CURLOPT_USERAGENT:**在HTTP请求中包含一个’user-agent’头的字符串。 **CURLOPT_FTPPORT:**传递一个包含被ftp ‘POST’指令使用的IP地址。这个POST指令告诉远程服务器去连接我们指定的IP地址。 这个字符串可以是一个IP地址，一个主机名，一个网络界面名(在UNIX下)，或是‘-’(使用系统默认IP地址)。 **CURLOPT_COOKIE:**传递一个包含HTTP cookie的头连接。 **CURLOPT_SSLCERT:**传递一个包含PEM格式证书的字符串。 **CURLOPT_SSLCERTPASSWD:**传递一个包含使用CURLOPT_SSLCERT证书必需的密码。 **CURLOPT_COOKIEFILE:**传递一个包含cookie数据的文件的名字的字符串。这个cookie文件可以是Netscape格式，或是堆存在文件中的HTTP风格的头。 **CURLOPT_CUSTOMREQUEST:**当进行HTTP请求时，传递一个字符被GET或HEAD使用。为进行DELETE或其它操作是有益的，更Pass a string to be used instead of GET or HEAD when doing an HTTP request. This is useful for doing or another, more obscure, HTTP request. 注意: 在确认你的服务器支持命令先不要去这样做。 下列的选项要求一个文件描述(通过使用fopen()函数获得)： **CURLOPT_FILE:**这个文件将是你放置传送的输出文件，默认是STDOUT. **CURLOPT_INFILE:**这个文件是你传送过来的输入文件。 **CURLOPT_WRITEHEADER:**这个文件写有你输出的头部分。 **CURLOPT_STDERR:**这个文件写有错误而不是stderr。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"百元百科","slug":"技术/百元百科","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"Http","slug":"Http","permalink":"https://baiyuan.wang/tags/Http/"}]},{"title":"PHP生成字母、符号、数字验证码图片","slug":"php-create-letter-symbol-number-captcha","date":"2015-06-29T03:27:42.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"php-create-letter-symbol-number-captcha.html","link":"","permalink":"https://baiyuan.wang/php-create-letter-symbol-number-captcha.html","excerpt":"","text":"最近王柏元的博客频遭机器人注册或者恶意登录尝试，有时候一晚上能收到100条垃圾注册记录，10分钟能收到100条登录错误邮件通知，让极客人很无语和烦闷。尝试屏蔽IP等方法仍然收效甚微的情况下，极客人无奈考虑加入验证码了，目前只在注册页面加入了验证码，在控制登录上使用了Limit Login Attempts插件（本插件的汉化版见文章：）。 下面是PHP生成字母、符号、数字验证码图片的代码，是极客人对互联网的代码做了部分修改：其中$strpol定义了使用哪些字母、符号、数字绘制验证码。 效果演示：http://baiyuan.wang/others/tools/captcha.php php代码生成字母、符号、数字验证码图片","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"谈谈网络API","slug":"talk-about-web-api","date":"2015-06-27T06:13:09.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"talk-about-web-api.html","link":"","permalink":"https://baiyuan.wang/talk-about-web-api.html","excerpt":"","text":"尤其是微信公众平台的流行以来，网络API越来越流行。没有任何技术和资源的互联网爱好者，都可以借助网络上免费、开放的API搭建自己的公众号，而且功能也可以相当强大，比如查天气、查股票、查火车票、聊天讲笑话、查IP、手机归属地……当然，网络API的使用不仅仅局限于微信开发，还可以适用于安卓等移动端软件开发。 很多软件都有天气查询功能，但并不是所有的天气软件开发者“家”里都有天气卫星和地面观测站；很多软件都有根据用户所处位置提供有针对性的服务：比如你想用饿了么点一份快餐，它能根据你的位置找到你附近的餐厅；你用美团买附近电影院的观影票，现在的问题是：你觉得饿了么和美团会开发一套定位加地图的系统吗？现在国内比较知名的地图应用有高德地图和百度地图，两者提供了定位、导航的API和相关开发者SDK和文档。 个人认为，网络开放接口很大一部分程度推动软件应用尤其是移动应用的繁荣。借助天气API，我们可以很简单地实现制作一个查天气的APP，然后辅以百度地图API可以很简单地知道你当前所处地方的天气了。而这些，如果没有诸多的开放平台，没钱没技术的开发者是无法实现的，这也很大地降低了开发者的成本和门槛。 网络上API有免费的，比如地图定位、IP、手机归属地；也有收费的，比如你要为你的网站登录加入短信验证码认证，也有的是在一定使用次数内免费，在使用次数超出免费套餐外的需要收费。 就我所见的，目前互联网免费的网络API很多，大部分是JSON和webservice，还有一些其它编程语言的开发平台SDK。 你有没有想过为自己的数据搭建个API？在之前的文章依托虚拟主机为自制APP提供软件更新服务中我介绍了怎样用PHP访问数据库返回JSON格式字符串，从而搭建自己的网络API；在文章我介绍了使用java+webservice连接数据库发布数据和实现查询、增删数据操作。 极客人最近就想到了学校教务系统就可以为学生查询成绩搭建一个API，一卡通中心可以提供一个查询账单的API，学校的跑操系统提供查询跑操次数，这些都是分分钟可以实现的问题，不知道学校不尝试一下呢，然后交由第三方实现相关APP。当然官方不开放API，并不代表第三方没有办法，办法是有的但是很暴力，那就是模拟用户登录、抓取页面然后解析数据提供给用户。但这样做实在是麻烦，也耗费程序猿的脑力。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"计算机技术","slug":"极客视点/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"}]},{"title":"java实现webservice+MySQl","slug":"java-implementation-webservice-mysql","date":"2015-06-26T06:59:33.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"java-implementation-webservice-mysql.html","link":"","permalink":"https://baiyuan.wang/java-implementation-webservice-mysql.html","excerpt":"","text":"关于webservice由于之前写过JAVA和PHP的JSON以及JMI的网络服务，这次在使用webservice完成管理待办事项自然就联想到它们。JAVA和PHP JSON、JMI、webservice三者共同之处是可以提供服务器的资源共享。 Web Service具有跨平台性，可以在不同设备、不同编程语言中进行调用，所以它的应用范围应该要比RMI更广 基于MySQl数据库查询的webservice实现管理待办事项列表运行截图 添加用户： 添加事项： 查询事项： 删除事项： 清空事项： 服务器端代码是怎么实现的下面介绍一下是怎样实现上述功能的服务端代码：。 我的服务端主要有四个类： 数据库连接及方法接口TodoListInterDbFace、数据库连接及方法实现类TodolistDb及方法实现类以及webservice接口TodoListServerInterface、Webservice实现类TodoListServer。 下面是示意图： 客户端代码是怎么实现的wsimport -keep http://127.0.0.1:8002/webservice/TodoList?wsdl解析WSDL后： 创建TodoListClient类main方法为： public static void main(String[] args){ int cmdLength&#x3D;args.length; TodoListServerService tlist &#x3D; new TodoListServerService() ; TodoListServerInterface todoList &#x3D; tlist.getTodoListPort(); String note&#x3D;”WebService待办事项客户端©王柏元—命令行版:\\n” + “1.帮助信息：\\n\\thelp\\n” + “2.用户注册：\\n\\tregister [用户名] [密码]\\n” + “ 3.添加待办事项：\\n\\tadd [你的用户名] [你的密码] [待办事项标题] [邀请谁？他的用户名] [开始时间] [结束时间]\\n” + “\\t 时间格式：2015-06-05 22:29:19\\n” + “4. 查询待办事项：\\n\\tquery [你的用户名] [你的密码][开始时间] [结束时间]\\n” + “5.删除待办事项：\\n\\tdelete [你的用户名] [你的密码] [待办事项ID]\\n” + “6.清除待办事项：\\n\\tclear [username] [password]\\n” + “7.关于本程序：\\n\\tabout\\n” + “8.退出:\\n quit\\n\\t” + “请输入命令：”; String about&#x3D;”WebService待办事项客户端©王柏元—命令行行版:\\n” + “作者:王柏元\\n” + “个人网站：http://baiyuan.wang\\\\n“ + “运行模式：命令行环境\\n” + “程序介绍：使用Java WebService创建一个待办事项管理系统。” + “不同的用户可以使用这个待办事项管理系统执行查询、添加和删除” + “待办事项的操作。服务器支持待办事项的登记和清除等功能；”; &#x2F;&#x2F;System.out.println(hello.hello(“liyong”)); switch(args[0]){ case“register”: if(cmdLength&#x3D;&#x3D;3){ System.out.println(todoList.addMeetingUsers(args[1], args[2])); }else{ System.out.println(“命令参数错误\\n” + “用户注册：\\n\\tregister [用户名] [密码]\\n”); } break; case “add”: if(cmdLength&#x3D;&#x3D;9){ System.out.println(todoList.addMeetings(args[1], args[2],args[3] ,args[4],args[5]+” “ +args[6], args[7]+” “+args[8])); }else{ System.out.println(“命令参数错误\\n” + “添加会议：\\n\\tadd [你的用户名] [你的密码] [邀请谁？他的用户名][会议标题] [开始时间] [结束时间] \\n”); } break; case “query”: if(cmdLength&#x3D;&#x3D;7){ if(todoList.loginMeetings(args[1], args[2]).equals(“1”)) System.out.println(todoList.searchrMeetings(args[3]+” “+ args[4],args[5]+” “+ args[6])); }else{ System.out.println(“命令参数错误\\n” + “查询会议：\\n\\tquery [用户名] [密码][开始时间] [结束时间]\\n”); } break; case “delete”: if(cmdLength&#x3D;&#x3D;4){ if(todoList.loginMeetings(args[1], args[2]).equals(“1”)) System.out.println(todoList.deleteMeetings(args[1], args[3])); }else{ System.out.println(“命令参数错误\\n” + “删除会议：\\n\\tdelete [你的用户名] [你的密码] [会议ID]\\n”); } break; case “clear”: if(cmdLength&#x3D;&#x3D;3){ if(todoList.loginMeetings(args[1], args[2]).equals(“1”)) System.out.println(todoList.clearMeetings(args[1])); }else{ System.out.println(“命令参数错误\\n” + “清除会议：\\n\\tclear [username] [password]\\n”); } break; case “about”: System.out.println(about);break; case“help”: System.out.println(note);break; } } 对于菜单的实现原理请参考我的博客文章：http://baiyuan.wang/java-rmi-6-making-the-command-line-navigation-menu.html","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/计算机技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"}]},{"title":"自制绝对时间相对化java方法TimeToString","slug":"method-of-absolute-time-java-timetostring","date":"2015-06-23T00:54:49.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"method-of-absolute-time-java-timetostring.html","link":"","permalink":"https://baiyuan.wang/method-of-absolute-time-java-timetostring.html","excerpt":"","text":"本方式实现将绝对日期如2015-6-23 8:00:00时间字符串转换为昨天8：00，明天21:00，今天5:23等等。在安卓开始中涉及时间显示相当实用。 注意按代码中要求传入时间字符串time的参数 TimeToString(String time)代码：@SuppressWarnings(&quot;deprecation&quot;) public static String TimeToString(String time) &#123; String timeString=time; try &#123; SimpleDateFormat dateFormat; dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); SimpleDateFormat dateFormat2 = new SimpleDateFormat(&quot;HH:mm&quot;); SimpleDateFormat dateFormat3 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); dateFormat.setLenient(false); Date timeDate = dateFormat.parse(time); &#x2F;&#x2F; Long timeStamp &#x3D; timeDate.getTime();&#x2F;&#x2F; Long currentStamp &#x3D; new Date().getTime();&#x2F;&#x2F; Long timetogo &#x3D; currentStamp - timeStamp; Calendar calDateA &#x3D; Calendar.getInstance(); Calendar calDateB &#x3D; Calendar.getInstance(); calDateB.setTime(timeDate); int year&#x3D;calDateA.get(Calendar.YEAR); int mon&#x3D;calDateA.get(Calendar.MONTH); int day&#x3D;calDateA.get(Calendar.DATE); int currentyear&#x3D;calDateB.get(Calendar.YEAR); int currentmon&#x3D;calDateB.get(Calendar.MONTH); int currentday&#x3D;calDateB.get(Calendar.DATE); Log.e(“bypaper”,currentyear+” “+currentmon+” “+year+” “+day+” “); if (year&#x3D;&#x3D;currentyear&amp;&amp;mon&#x3D;&#x3D;currentmon&amp;&amp;day&#x3D;&#x3D;currentday) { timeString&#x3D;”今天”+dateFormat2.format(timeDate); }else if (year&#x3D;&#x3D;currentyear&amp;&amp;mon&#x3D;&#x3D;currentmon&amp;&amp;(day-currentday)&#x3D;&#x3D;1) { timeString&#x3D;”昨天”+dateFormat2.format(timeDate); }else if (year&#x3D;&#x3D;currentyear&amp;&amp;mon&#x3D;&#x3D;currentmon&amp;&amp;(day-currentday)&#x3D;&#x3D;-1) { timeString&#x3D;”明天”+dateFormat2.format(timeDate); }else { timeString&#x3D;dateFormat3.format(timeDate); } &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;// util类型 return timeString; &#125;","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[]},{"title":"自制软件更新、下载、安装类BYupdate","slug":"homemade-software-updates-downloads-installation-byupdate","date":"2015-06-22T00:47:01.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"homemade-software-updates-downloads-installation-byupdate.html","link":"","permalink":"https://baiyuan.wang/homemade-software-updates-downloads-installation-byupdate.html","excerpt":"","text":"类 BYupdate简述：实现软件信息的展示和软件更新功能 java.lang.Object cn.wangbaiyuan.tools.BYupdate public class BYupdate extends java.lang.Object 实现软件信息的展示和软件更新功能 作者: 王柏元 字段概要字段 限定符和类型 字段和说明 OnClickListener download_listener 构造器概要构造器 构造器和说明 BYupdate(Context icontext, java.lang.String url, java.lang.String version) 方法概要All MethodsInstance MethodsConcrete Methods 限定符和类型 方法和说明 void checkupdate() 检查更新 void setDownload_url(java.lang.String url) 设置软件更新服务处理地址 从类继承的方法 java.lang.Objectequals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait 字段详细资料 download_listenerpublic OnClickListener download_listener 构造器详细资料 BYupdatepublic BYupdate(Context icontext, java.lang.String url, java.lang.String version)参数: icontext - context一般是引用此类的activity url - 软件更新服务处理地址 version - 软件当前版本号 方法详细资料 setDownload_urlpublic void setDownload_url(java.lang.String url) 设置软件更新服务处理地址 参数: url - checkupdatepublic void checkupdate() 检查更新 代码：package cn.wangbaiyuan.tools; import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL; import org.json.JSONException;import org.json.JSONObject; import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.content.DialogInterface.OnClickListener;import android.content.Intent;import android.net.Uri;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.util.Log;import android.widget.Toast;&#x2F;** * 实现软件信息的展示和软件更新功能 * @author 王柏元 * *&#x2F;public class BYupdate { String sw_version; String current_version; String version_des; String url_path; Context context; String download_url; /\\*\\* \\* \\* @param icontext context一般是引用此类的activity \\* @param url 软件更新服务处理地址 \\* @param version 软件当前版本号 */ public BYupdate(Context icontext,String url, String version)&#123; context=icontext; url_path=url; current_version=version; &#125; /\\*\\* \\* 设置软件更新服务处理地址 \\* @param url */ public void setDownload_url(String url)&#123; url_path=url; &#125; Handler hander=new Handler()&#123; @Override public void handleMessage(Message msg)&#123; if(msg.what==0x123)&#123; //version\\_label.setText(&quot;最新版本：&quot;+sw\\_version); Double latest\\_Version=Double.parseDouble(sw\\_version); if(Double.parseDouble(current\\_version)&lt;latest\\_Version) &#123; AlertDialog.Builder builder=new AlertDialog.Builder(context) .setTitle(&quot;当前版本:&quot;+current\\_version+&quot;,最新版本:&quot;+latest\\_Version) .setMessage(version_des); builder.setPositiveButton(&quot;下载更新&quot;, download_listener); builder.setNegativeButton(&quot;以后再说&quot;, null); builder.create(); builder.show(); &#125; else Toast.makeText(context, &quot;当前是最新版本&quot;, 5).show(); &#125; else if(msg.what==012) Toast.makeText(context, &quot;安装包下载完成，进入安装……&quot;, Toast.LENGTH_LONG).show(); else if(msg.what==01244) Toast.makeText(context, &quot;下载错误……&quot;, Toast.LENGTH_LONG).show(); //最后toast出文件名，因为这个程序是单线程的，所以要下载完文件以后才会执行这一句，中间的时间类似于死机，不过多线程还没有学到 &#125; &#125;; /\\*\\* \\* 检查更新 */ public void checkupdate()&#123; new Thread(checkupdate).start(); Toast.makeText(context, &quot;正在检查更新……&quot;, 2).show(); &#125; public OnClickListener download_listener =new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; new Thread(download).start(); Toast.makeText(context, &quot;开始下载……&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;; /\\*\\* \\* 下载线程 */ Runnable download = new Runnable()&#123; @Override public void run() &#123; String sdcard=Environment.getExternalStorageDirectory()+&quot;/&quot;; String filepath=sdcard+&quot;BYLeavePaper/&quot;; download\\_url=(download\\_url.startsWith(&quot;http://&quot;))?download\\_url:&quot;http://&quot;+download\\_url; try &#123; URL url = new URL(download_url); //打开到url的连接 HttpURLConnection connection = (HttpURLConnection)url.openConnection(); //以下为java IO部分，大体来说就是先检查文件夹是否存在，不存在则创建,然后的文件名重复问题，没有考虑 InputStream istream=connection.getInputStream(); String filename=download\\_url.substring(download\\_url.lastIndexOf(&quot;/&quot;)+1); File dir=new File(filepath); if (!dir.exists()) &#123; dir.mkdir(); &#125; File file=new File(filepath+filename); file.createNewFile(); OutputStream output=new FileOutputStream(file); byte\\[\\] buff = new byte\\[1024\\]; int hasRead = 0; // 将URL对应的资源下载到本地 while((hasRead = istream.read(buff)) &gt; 0) &#123; output.write(buff, 0 , hasRead); &#125; output.flush(); output.close(); istream.close(); hander.sendEmptyMessage(012); Log.e(&quot;log_tag&quot;,file.toString()); openFile(file); &#125; catch (Exception e) &#123; Log.e(&quot;log_tag&quot;,&quot;下载错误:&quot;+e.toString()); hander.sendEmptyMessage(01244); &#125; &#125; &#125;; /\\*\\* \\* 检查更新线程 */ Runnable checkupdate = new Runnable()&#123; @Override public void run() &#123; String jsonString = BYHttpGet.getJsonContent(url_path); Log.e(&quot;bypaperup&quot;,jsonString); try &#123; JSONObject Json=new JSONObject(jsonString); sw\\_version=Json.getString(&quot;sw\\_version&quot;); version\\_des=Json.getString(&quot;sw\\_description&quot;); download\\_url=Json.getString(&quot;sw\\_url&quot;); &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); Log.e(&quot;log_tag&quot;,e.toString()); &#125; hander.sendEmptyMessage(0x123); &#125; &#125;; &#x2F;** * 打开指定APK * @param file APK路径 *&#x2F;private void openFile(File file) { Log.e(“OpenFile”, file.getName()); Intent intent &#x3D; new Intent(); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(android.content.Intent.ACTION_VIEW); intent.setDataAndType(Uri.fromFile(file), “application&#x2F;vnd.android.package-archive”); context.startActivity(intent); }}","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"}]},{"title":"BY请假条软件说明与意见反馈页","slug":"by-leave-instructions-and-feedback-page","date":"2015-06-21T07:13:00.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"by-leave-instructions-and-feedback-page.html","link":"","permalink":"https://baiyuan.wang/by-leave-instructions-and-feedback-page.html","excerpt":"","text":"一、软件简介本软件是极客人的安卓大作业：BY请假条意为学生提供请假申请、辅导员批假、老师确认、通知推送、邮件发送提醒和密码重置等基础功能.，同时实现师生之间留言、即时聊天等互动功能(时间有限，此功能未予实现)。 二、软件功能介绍 1.与虚拟主机连接实现联网登录功能，和记住密码等细节功能； 2.采用数据库管理BY请假条用户、课程信息、班级信息、请假记录、班级选课记录； 3.采用JSON数据包形式传递数据：服务器为PHP语言查询数据库，客户端为安卓java语言解析； 4.两种方式处理请假要求：辅导员可通过安卓客户端或者点击邮件中的链接直接通过浏览器GET方式实现批准、拒绝学生的请假要求； 5.实现邮件提醒通知：使用leavepaper@baiyuan.wang域名邮箱，当学生有新请假请求、辅导员批准或拒绝请假时，及时通知相关人员； 6.分享功能：BY请假条为你自动生成文本请假条，你可以将它分享给QQ、微博、朋友圈等社交媒体；同时辅导员在未上线可以用短信把假条发给TA； 7.使用GET方式获取最新版本信息，并自动下载并安装； 8.界面优化，添加沉浸式状态栏元素； 9.根据用户类型适配不同UI； 10.为软件后期维护提供意见反馈功能 三、软件截图 四、相关技术教程相关原创技术教程将陆续在王柏元的博客发布。敬请期待…… 基于http post的自制工具类BYhttpClient 安卓开发实现沉浸式状态栏 依托虚拟主机为自制APP提供软件更新服务（一） 依托虚拟主机为自制APP提供软件更新服务（二） 五、意见反馈欢迎对BY请假条提出宝贵意见，本页评论将作为BY请假条的意见反馈。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"用域名解析到IPV6连接远程桌面","slug":"with-the-domain-name-resolves-to-an-ipv6-connection-remote-desktop","date":"2015-06-19T05:21:12.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"with-the-domain-name-resolves-to-an-ipv6-connection-remote-desktop.html","link":"","permalink":"https://baiyuan.wang/with-the-domain-name-resolves-to-an-ipv6-connection-remote-desktop.html","excerpt":"","text":"一般来说，远程桌面一般应用于服务器管理和局域网内普通计算机的远程管理。其实远程桌面并不仅仅限于局域网内，只要IP可达，我们的计算机都可以在其它计算机上远程桌面连接。由于IPV4地址不够用的问题，通过NAT转换的IPv4并不能让我们找到互联网任何一台主机，但是无穷无尽的IPv6却完美解决这一问题。由于有些学校，比如极客人，连接校园网需要用锐捷进行账号认证才能访问局域网内的IPv4计算机。所以在学校机房远程桌面自己的计算机时，常常遇到锐捷没有登录而导致无法连接宿舍电脑的问题。但是，如果通过IPV6访问就不用考虑这一问题了，当然，你网线没插我也没办法。 IPV6连接远程桌面的方法和IPv4没有任何区别，怎样用远程桌面控制自己的电脑，在我的前一篇文章有介绍： 第一步，获取本机IPV6地址并域名解析IPV6的好处是地址长（128位二进制），所以数量多到可以标记地球上任何一粒沙子，它的缺点也正是地址长——记不住。所以远程桌面管理你的计算机肯定不能使用IPv6地址了，用域名解析的方式是必然的选择。 IPv6域名解析和IPv4无异，你只需要在域名管理中添加一个AAAA记录即可。 具体怎么获取本机的IPv6地址进行IPv6域名解析请参照：http://baiyuan.wang/setting-up-ipv6-ftp-and-web-server-implements-cross-school-access.html#title-0 比如极客人解析的域名就是：ipv6.baiyuan.wang。 第二步，IPV6域名连接远程桌面打开远程桌面输入你解析的IPV6域名即可： IPV6远程桌面 问：锐捷没登或者断了，连不了远程怎么办？ 1.学校机房支持IPV6就用IPV6登录你的计算机； 2.学校机房不支持IPV6就用别人已经登上锐捷的同学电脑连一下他的计算机，然后远程他的电脑、通过IPv6来远程连接你的计算机，然后登上你的锐捷，用学校计算机IPv4连接你的电脑。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"域名解析","slug":"域名解析","permalink":"https://baiyuan.wang/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"IPv6","slug":"IPv6","permalink":"https://baiyuan.wang/tags/IPv6/"},{"name":"IP","slug":"IP","permalink":"https://baiyuan.wang/tags/IP/"}]},{"title":"SSD7_EX9【事务编程】","slug":"ssd7-ex9-affairs-programming","date":"2015-06-18T03:22:54.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd7-ex9-affairs-programming.html","link":"","permalink":"https://baiyuan.wang/ssd7-ex9-affairs-programming.html","excerpt":"","text":"这是SSD7练习的EX9，预计极客人将会写一个系列，更新频率会和NWPU数据库系统实验课2013级进度同步。点击标签或在本站搜索“SSD7”即可获取已更新的SSD7答案。上一练习：SSD7_Exam2【规范化、E-R映射】 下面使用MySql上的测试结果： 第一部分：测试数据库事务提交和回滚几乎所有的商业DBMS软件都会支持在事务提交前的回滚，这对于保证事务原子特性非常有用。你可以使用rollback命令撤销掉部分操作。此部分练习将会让你熟悉rollback和commit命令。 rollback.txt：[toggle hide&#x3D;”yes” title&#x3D;”rollback.txt：” color&#x3D;””] 第一部分：测试数据库事务提交和回滚 3． 查询活期储蓄账户余额，将查询结果拷贝到rollback.txt文档中。 id balance 1 1105.59 2 2050.59 4． 删除定期和活期两个储蓄账户，将SQL语句拷贝到rollback.txt文档中。 DELETE FROM account 5． 查询两个账户的信息，将结果拷贝入rollback.txt文档中。 Id balance null null 6． 回滚事务。 7． 查询两个账户的余额，将结果拷贝入rollback.txt文档中。 id balance 1 1105.59 2 2050.59 8． 开始一个新事务。 9． 删除定期储蓄账户，将SQL语句拷贝入rollback.txt文档中。 DELETE FROM account WHERE id&#x3D;1 10． 查询表account的所有行，将结果拷贝入rollback.txt文档中。 id balance 2 2050.59 11． 提交事务。 12． 尝试回滚刚刚提交的事务。查询表中存储的值。解释说明事务提交和回滚产生的不同影响。将结果写入rollback.txt文档中。 id balance 2 2050.59 解释：提交后的数据不可回滚到之前状态 [&#x2F;toggle] 第二部分 测试事务隔离等级PostgreSQL支持两种事务隔离等级。完成以下练习，熟悉PostgreSql支持的隔离等级。 isolation.txt：[toggle hide&#x3D;”yes” title&#x3D;”isolation.txt” color&#x3D;””]5. 第一个窗口，查询account关系所有行，结果拷贝入isolation.txt文档中，用序号标识出数据来自于窗口一。 窗口① id balance 1 105.59 2 455.66 6. 窗口② id balance 1 105.59 2 1050.59 8.窗口② id balance 1 105.59 2 455.66 第一个窗口的结果已生效，因为窗口①已将数据提交。、 通过select @@tx_isolation;命令查询到两窗口的当前事务隔离等级都是REPEATABLE-READ。 11.set tx_isolation&#x3D;’SERIALIZABLE’; 14.窗口① id balance 1 105.59 2 1400 窗口② id balance 1 1 2 455.66 16.窗口①活期储蓄账户值没有更新，窗口②定期储蓄账户值没有更新。 SERIALIZABLE事务隔离级别最严厉， 在进行查询时就会对表或行加上共享锁，其他事务对该表将只能进行读操作， 而不能进行写操作。 17. 窗口① id balance 1 1 2 1400 窗口② id balance 1 1 2 1400[&#x2F;toggle] 第三部分 阻塞和死锁问题[toggle hide&#x3D;”false” title&#x3D;”第三部分 阻塞和死锁” color&#x3D;””] 1.运行SQL script建立一个小的银行数据库，account关系包含两列，用户id和账户余额。有两行数据，定期储蓄账户（id为1）和活期储蓄账户（id为2）。 2.开始两个PostgreSQL窗口会话。 3.两个窗口都开始一个新事务。 4.第二个窗口中将活期储蓄账户余额更新为455.75. 5.第一个窗口中将活期储蓄账户余额更新为1400，更新能否成功，解释说明，将答案写入deadlock.txt文档中。 6.第二个窗口提交事务，观察第一个窗口变化，解释说明，答案写入deadlock.txt文档中。 7.第一个窗口提交事务。 8.两个窗口开始一个新事务。 9.第二个窗口中将定期储蓄账户余额更新为2400. 10.第一个窗口中将活期储蓄账户余额更新为2000. 11.第一个窗口中将定期储蓄账户余额更新为1400. 12.第二个窗口中将活期储蓄账户余额更新为1000.50. 13.观察结果，试着解释原因。结果写入deadlock.txt文档中。 14.在每个窗口中查询表的数据，你观察到了什么？试做说明 [&#x2F;toggle] deadlock.txt[toggle hide&#x3D;”yes” title&#x3D;”deadlock.txt” color&#x3D;””] 5.第一个窗口中将活期储蓄账户余额更新为1400，更新能否成功，解释说明，将答案写入deadlock.txt文档中。 更新没有成功 6.第二个窗口提交事务，第一个窗成功修改了记录，因为在第二个窗口中将活期储蓄账户余额更新为455.75时已经对该数据进行了封锁 第一个窗口中将活期储蓄账户余额更新为1400时事务一直处于等待状态，当窗口二提交后才完成更新数据 14.运行后报错： Deadlock found when trying to get lock; try restarting transaction 原因分析：事务陷入了死锁：设第一个窗口的事务为T1,，第二个窗口的事务为T2； ①第二个窗口中将定期储蓄账户余额更新为2400时——T2封锁了定期账户余额数据D1； ②第一个窗口中将活期储蓄账户余额更新为2000时——T1封锁了活期账户余额数据D2； ③第一个窗口中将定期储蓄账户余额更新为1400时： T1请求封锁D1，因为T2已经封锁D1，于是T1等待T2释放D1的锁； 之后当第二个窗口中将活期储蓄账户余额更新为1000.50时： T2请求封锁D2，因为此时T1已经封锁D1，于是T2等待T1释放D2的锁；这样出现T1等待T2释放锁，T2等待T1释放锁，于是陷入死锁。 [&#x2F;toggle]","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"用.htpasswd设置网站目录、文件访问密码","slug":"htpasswd-set-site-directory-file-passwords","date":"2015-06-16T15:05:14.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"htpasswd-set-site-directory-file-passwords.html","link":"","permalink":"https://baiyuan.wang/htpasswd-set-site-directory-file-passwords.html","excerpt":"","text":"不知道什么原因，王柏元的博客近两天频遭恶意登录攻击，大概一天晚上极客人收到了系统发送的登录错误提醒邮件高达100封，这让极客人十分苦恼。为此极客人想到了利用htaccess+.htpasswd设置网站目录、文件访问密码的方式保护网站登录相关的关键文件和目录，这样恶意登录就不会如此猖獗，这为网站安全加了双保险。对于更多的网站安全保护方法，请参考强化WordPress网站安全的 12 个方法，当然这些方法不仅仅针对wordpress。 保护目录在要设置密码访问的目录下新建htaccess文件，加入语句： AuthUserFile &#x2F;home&#x2F;baiyuan.wang&#x2F;htdocs&#x2F;.htpasswdAuthType BasicAuthName “please enter password!”Order Deny,AllowDeny from allRequire valid-userSatisfy any 注意AuthUserFile 后面是.htpasswd文件的路径，这个路径是主机商给你的绝对路径，不是带你的域名的路径。在.htpasswd文件中记录了用户名和密码，不过这些用户名和密码都是加密过的非明文密码。 密码存放的格式是： 用户名:密码 怎样生成htpasswd密码请访问：http://tool.oschina.net/htpasswd htpasswd在线生成 将生成结果复制后保存在一个命名为“.htpasswd”的文件中，放在网站根目录。注意AuthUserFile 后面就是这个.htpasswd文件的路径。 密码保护网站文件 AuthUserFile /home/baiyuan.wang/htdocs/.htpasswd AuthType Basic AuthName \"please enter password!\" Order Deny,Allow Deny from all Require valid-user Satisfy any 正如你所见方法和保护目录类似。 至于设置限制IP访问指定文件你可以参考强化WordPress网站安全的 12 个方法。 效果预览 htpasswd设置密码保护目录","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"}]},{"title":"AndroidFragment生命周期详解","slug":"android-fragment","date":"2015-06-15T13:55:57.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-fragment.html","link":"","permalink":"https://baiyuan.wang/android-fragment.html","excerpt":"","text":"1 生命周期两张图Fragment生命周期图： android-fragment生命周期 Fragment与Activity生命周期对比图： 2 生命周期分析1. 当一个fragment被创建的时候，它会经历以下状态. onAttach() onCreate() onCreateView() onActivityCreated() 2. 当这个fragment对用户可见的时候，它会经历以下状态。 onStart() onResume() 3. 当这个fragment进入“后台模式”的时候，它会经历以下状态。 onPause() onStop() 4. 当这个fragment被销毁了（或者持有它的activity被销毁了），它会经历以下状态。 onPause() onStop() onDestroyView() onDestroy() &#x2F;&#x2F; 本来漏掉类这个回调，感谢xiangxue336提出。 onDetach() 5. 就像activitie一样，在以下的状态中，可以使用Bundle对象保存一个fragment的对象。 onCreate() onCreateView() onActivityCreated() 6. fragments的大部分状态都和activitie很相似，但fragment有一些新的状态。 onAttached() —— 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。 onCreateView() —— 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。 onActivityCreated() —— 当activity的onCreated()方法返回后调用此方法 onDestroyView() —— 当fragment中的视图被移除的时候，调用这个方法。 onDetach() —— 当fragment和activity分离的时候，调用这个方法。 一旦activity进入resumed状态（也就是running状态），你就可以自由地添加和删除fragment了。因此，只有当activity在resumed状态时，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"PHP用SMTP发邮件(支持SSL)","slug":"php-with-smtp-email-support-ssl","date":"2015-06-14T01:40:35.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"php-with-smtp-email-support-ssl.html","link":"","permalink":"https://baiyuan.wang/php-with-smtp-email-support-ssl.html","excerpt":"","text":"在做安卓大作业时，考虑到可以在APP加入邮件通知、忘记密码邮件重置密码的功能，极客人在虚拟主机中加入PHP用SMTP发邮件(支持SSL)的代码，同时使用自己的域名邮箱&#108;&#x65;&#x61;&#x76;&#101;&#x70;&#x61;&#x70;&#x65;&#114;&#x40;&#98;&#97;&#x69;&#x79;&#x75;&#97;&#x6e;&#x2e;&#x77;&#97;&#x6e;&#103;进行了测试。 测试效果： PHP用SMTP发邮件支持SSL PHP用SMTP发邮件(支持SSL)代码注意：请自行下载PHPMailer_v5.1解压到虚拟主机，引入PHPMailer的核心文件class.phpmailer.php。（代码来自互联网，终极来源存疑） SMTPDebug = 1; //使用smtp鉴权方式发送邮件，当然你可以选择pop方式 sendmail方式等 本文不做详解 //可以参考http://phpmailer.github.io/PHPMailer/当中的详细介绍 $mail->isSMTP(); //smtp需要鉴权 这个必须是true $mail->SMTPAuth=true; //链接qq域名邮箱的服务器地址 $mail->Host = 'smtp.qq.com'; //设置使用ssl加密方式登录鉴权 $mail->SMTPSecure = 'ssl'; //设置ssl连接smtp服务器的远程服务器端口号 可选465或587 $mail->Port = 465; //设置smtp的helo消息头 这个可有可无 内容任意 $mail->Helo = 'Hello smtp.qq.com Server'; //设置发件人的主机域 可有可无 默认为localhost 内容任意，建议使用你的域名 //$mail->Hostname = 'jjonline.cn'; //设置发送的邮件的编码 可选GB2312 我喜欢utf-8 据说utf8在某些客户端收信下会乱码 $mail->CharSet = 'UTF-8'; //设置发件人姓名（昵称） 任意内容，显示在收件人邮件的发件人邮箱地址前的发件人姓名 $mail->FromName = 'BY请假条系统'; //smtp登录的账号 这里填入字符串格式的qq号即可 $mail->Username ='leavepaper@baiyuan.wang'; //smtp登录的密码 这里填入“独立密码” 若为设置“独立密码”则填入登录qq的密码 建议设置“独立密码” $mail->Password = 'xxxxxxxxx'; //设置发件人邮箱地址 这里填入上述提到的“发件人邮箱” $mail->From = 'leavepaper@baiyuan.wang'; //邮件正文是否为html编码 注意此处是一个方法 不再是属性 true或false $mail->isHTML(true); //设置收件人邮箱地址 该方法有两个参数 第一个参数为收件人邮箱地址 第二参数为给该地址设置的昵称 不同的邮箱系统会自动进行处理变动 这里第二个参数的意义不大 $mail->addAddress('1586320567@qq.com','BY请假条系统'); //添加多个收件人 则多次调用方法即可 //$mail->addAddress('xxx@163.com','晶晶在线用户'); //添加该邮件的主题 $mail->Subject = 'BY请假条系统发送邮件的示例'; //添加邮件正文 上方将isHTML设置成了true，则可以是完整的html字符串 如：使用file\\_get\\_contents函数读取本地的html文件 $mail->Body = \"这是一个BY请假条系统发送邮件的一个测试用例\"; //为该邮件添加附件 该方法也有两个参数 第一个参数为附件存放的目录（相对目录、或绝对目录均可） 第二参数为在邮件附件中该附件的名称 //$mail->addAttachment('./d.jpg','mm.jpg'); //同样该方法可以多次调用 上传多个附件 //$mail->addAttachment('./Jlib-1.1.0.js','Jlib.js'); //发送命令 返回布尔值 //PS：经过测试，要是收件人不存在，若不出现错误依然返回true 也就是说在发送之前 自己需要些方法实现检测该邮箱是否真实有效 $status = $mail->send(); //简单的判断与提示信息 if($status) { echo '发送邮件成功'; }else{ echo '发送邮件失败，错误信息未：'.$mail->ErrorInfo; } ?>","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"【JAVA_RMI】(6)制作命令行导航菜单","slug":"java-rmi-6-making-the-command-line-navigation-menu","date":"2015-06-12T23:06:12.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"java-rmi-6-making-the-command-line-navigation-menu.html","link":"","permalink":"https://baiyuan.wang/java-rmi-6-making-the-command-line-navigation-menu.html","excerpt":"","text":"由于在eclipse运行配置里添加运行参数并不方便，建议将调试好的java工程导出为可以运行的jar包，然后在命令行打开jar所在文件夹，使用”java -jar &lt;包名&gt; &lt;main函数参数1 参数2 ……&gt;“,下图的help命令就是main函数执行时的参数数组arg[]的第一个元素arg[0]。参数以空格为分隔符，后面分别是arg[1]、arg[2]。 知道这点，制作java命令行的导航菜单就很简单。为了方便操作，极客人为这次试验还制作了GUI，支持GUI、命令行双界面模式运行应用。命令行的好处可能只有程序员才知道，它最大的好处、个人认为是可以批处理，这是习惯GUI的用户无法理解的。 效果预览： java命令行导航菜单 MeetingClient.java下述代码通过匹配用户输入的main函数参数，分别执行在上一篇文章中定义的方法。其中输入GUI和不输入参数将启动GUI模式。 java命令行导航菜单2 package cn.wangbaiyuan; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.rmi.Naming;import java.rmi.NotBoundException;import java.sql.SQLException; &#x2F;** * RMI会议客户端 * @author 王柏元 * *{@linkplain http://baiyuan.wang} *&#x2F;public class MeetingClient { public static void main(String args[]) throws IOException{ int cmdLength&#x3D;args.length; MeetingInterface meeting; if(cmdLength&#x3D;&#x3D;0){ LoginGUI.show(null); }else { String note&#x3D;”RMI会议客户端©王柏元—命令行版:\\n” + “1.帮助信息：\\n\\thelp\\n” + “2.用户注册：\\n\\tregister [用户名] [密码]\\n” + “ 3.添加会议：\\n\\tadd [你的用户名] [你的密码] [邀请谁？他的用户名] [开始时间] [结束时间] [会议标题]\\n” + “\\t 时间格式：2015-06-05 22:29:19\\n” + “4. 查询会议：\\n\\tquery [你的用户名] [你的密码][开始时间] [结束时间]\\n” + “5.删除会议：\\n\\tdelete [你的用户名] [你的密码] [会议ID]\\n” + “6.清除会议：\\n\\tclear [username] [password]\\n” + “7.关于本程序：\\n\\tabout\\n” + “8.退出:\\n quit\\n\\t” + “9.GUI模式:\\n GUI\\n\\t” + “请输入命令：”; String about&#x3D;”RMI会议客户端©王柏元—命令行行版:\\n” + “作者:王柏元\\n” + “个人网站：http://baiyuan.wang\\\\n“ + “运行模式：GUI和命令行双环境\\n” + “程序介绍：使用Java RMI创建一个分布式议程共享服务。” + “不同的用户可以使用这个共享议程服务执行查询、添加和删除” + “会议的操作。服务器支持会议的登记和清除等功能；”; try { meeting&#x3D;(MeetingInterface) Naming.lookup(LoginGUI.getRmiURL()); switch(args[0]){ case &quot;register&quot;: if(cmdLength==3)&#123; meeting.addMeetingUsers(args\\[1\\], args\\[2\\]); &#125;else&#123; System.out.println(&quot;命令参数错误\\\\n&quot; \\+ &quot;用户注册：\\\\n\\\\tregister \\[用户名\\] \\[密码\\]\\\\n&quot;); &#125; break; case &quot;add&quot;: if(cmdLength==9)&#123; meeting.addMeetings(args\\[1\\], args\\[2\\],args\\[3\\] ,args\\[4\\],args\\[5\\]+&quot; &quot; +args\\[6\\], args\\[7\\]+&quot; &quot;+args\\[8\\]); &#125;else&#123; System.out.println(&quot;命令参数错误\\\\n&quot; \\+ &quot;添加会议：\\\\n\\\\tadd \\[你的用户名\\] \\[你的密码\\] \\[邀请谁？他的用户名\\]\\[会议标题\\] \\[开始时间\\] \\[结束时间\\] \\\\n&quot;); &#125; break; case &quot;query&quot;: if(cmdLength==7)&#123; if(meeting.LoginMeetings(args\\[1\\], args\\[2\\])) meeting.searchrMeetings(args\\[3\\]+&quot; &quot;+ args\\[4\\],args\\[5\\]+&quot; &quot;+ args\\[6\\]); &#125;else&#123; System.out.println(&quot;命令参数错误\\\\n&quot; \\+ &quot;查询会议：\\\\n\\\\tquery \\[用户名\\] \\[密码\\]\\[开始时间\\] \\[结束时间\\]\\\\n&quot;); &#125; break; case &quot;delete&quot;: if(cmdLength==4)&#123; if(meeting.LoginMeetings(args\\[1\\], args\\[2\\])) meeting.deleteMeetings(args\\[1\\], args\\[3\\]); &#125;else&#123; System.out.println(&quot;命令参数错误\\\\n&quot; \\+ &quot;删除会议：\\\\n\\\\tdelete \\[你的用户名\\] \\[你的密码\\] \\[会议ID\\]\\\\n&quot;); &#125; break; case &quot;clear&quot;: if(cmdLength==3)&#123; if(meeting.LoginMeetings(args\\[1\\], args\\[2\\])) meeting.clearMeetings(args\\[1\\]); &#125;else&#123; System.out.println(&quot;命令参数错误\\\\n&quot; \\+ &quot;清除会议：\\\\n\\\\tclear \\[username\\] \\[password\\]\\\\n&quot;); &#125; break; case &quot;about&quot;: System.out.println(about);break; case &quot;GUI&quot;: LoginGUI.show(null);break; case &quot;help&quot;: System.out.println(note);break; case &quot;quit&quot;: LoginGUI.show(null);break; &#125; &#125; catch (NotBoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (BYException e) &#123; // TODO Auto-generated catch block System.out.println(e.getMessage()); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 系列文章链接：SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API SSD8_Ex3【JAVA_RMI】(2)远程接口声明 SSD8_Ex3【JAVA_RMI】(3)开启RMI服务 SSD8_Ex3【JAVA_RMI】(4)会议数据库建表 SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义 SSD8_Ex3【JAVA_RMI】(6)制作命令行导航菜单","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"}]},{"title":"SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义","slug":"ssd8-ex3-java-rmi-5-the-database-connection-and-session-method-definition","date":"2015-06-12T03:21:13.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex3-java-rmi-5-the-database-connection-and-session-method-definition.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex3-java-rmi-5-the-database-connection-and-session-method-definition.html","excerpt":"","text":"下面的代码是本次实验使用数据库实现RMI会议管理的关键，里面的主要是实现数据库连接和实现相关的查询的方法，这些方法在之前文章的接口代码已经声明，不过没有实质内容。RmiDataBase类继承了meetinginterface接口。 系列文章链接：SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API SSD8_Ex3【JAVA_RMI】(2)远程接口声明 SSD8_Ex3【JAVA_RMI】(3)开启RMI服务 SSD8_Ex3【JAVA_RMI】(4)会议数据库建表 SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义 SSD8_Ex3【JAVA_RMI】(6)制作命令行导航菜单 RmiDataBase.java package cn.wangbaiyuan; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.sql.*;import cn.wangbaiyuan.tools.TimeTool; import com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException; &#x2F;** * 连接meeting数据库类，并定义相关查询方法 * * @author 王柏元 * *&#x2F;public class RmiDataBase extends UnicastRemoteObject implements MeetingInterface{ private Connection connection; private String userName; private String password; private String connectionUrl; /\\*\\* \\* \\* @param dhost \\* 主机名 \\* @param dport \\* 端口 \\* @param dName \\* 数据库名称 \\* @param duserName \\* 用户名 \\* @param dpassword \\* 密码 \\* @throws SQLException \\* 抛出SQLException */ public RmiDataBase(String dhost, int dport, String dbName, String duserName, String dpassword) throws SQLException, RemoteException &#123; userName = duserName; password = dpassword; //设置数据库连接的编码 connectionUrl = &quot;jdbc:mysql://&quot; + dhost + &quot;:&quot; + dport + &quot;/&quot; + dbName+&quot;?useUnicode=true&amp;characterEncoding=utf8&quot;; getConnection(); &#125; /\\*\\* \\* 数据库未连接时连接数据库 \\* \\* @return 数据库连接 \\* @throws SQLException */ public Connection getConnection() throws SQLException &#123; System.out.println(connectionUrl); connection = DriverManager.getConnection(connectionUrl, userName, password); return connection; &#125; /\\*\\* \\* 添加用户，用户注册 \\* \\* @param user \\* @throws MySQLIntegrityConstraintViolationException \\* @throws BYException \\* @throws SQLException */ public void addMeetingUsers(String userName,String userpassword) throws BYException, SQLException &#123; try &#123; Statement sql = getConnection().createStatement(); String name =userName; String passWard = userpassword; String addString = &quot;INSERT INTO users (userName, userPassword) VALUES (&#39;&quot; \\+ name + &quot;&#39;, &#39;&quot; + passWard + &quot;&#39;)&quot;; System.out.println(addString); sql.execute(addString); connection.close(); throw new BYException(&quot;添加成功！&quot;); &#125; catch (MySQLIntegrityConstraintViolationException e) &#123; throw new BYException(&quot;当前用户名已存在&quot;); &#125; &#125; /\\*\\* \\* \\* @param user \\* @throws RemoteException \\* @throws Exception */ public void addMeetings(String userName, String password, String otherUserName,String imeetingTitle,String imeetingStartTime,String imeetingEndTime) throws BYException, RemoteException &#123; try &#123; imeetingStartTime=TimeTool.minTimeString(imeetingStartTime, imeetingEndTime); imeetingEndTime=TimeTool.maxTimeString(imeetingStartTime, imeetingEndTime); Statement sql = getConnection().createStatement(); if (LoginMeetings(userName, password)&amp;&amp; otherUserName != null) &#123; String searchString = &quot;select * from users where userName =&#39;&quot; \\+ otherUserName + &quot;&#39;;&quot;; ResultSet rs = sql.executeQuery(searchString); System.out.println(searchString); rs.last(); if (rs.getRow() &lt; 1) &#123;System.err.println(&quot;你邀请的名为&quot; + otherUserName \\+ &quot;的用户不存在！&quot;); throw new BYException(&quot;你邀请的名为“&quot; + otherUserName \\+ &quot;”的用户不存在！&quot;);&#125; else &#123; searchString=&quot;SELECT r1.userName\\\\n&quot; \\+ &quot; FROM meetingrecord r1,meeting m1\\\\n&quot; \\+ &quot; WHERE (r1.meetingId=m1.meetingId)&quot; \\+ &quot; and (r1.userName=&#39;&quot;+userName+&quot;&#39; or r1.userName=&#39;&quot;+otherUserName+&quot;&#39;) &quot; \\+ &quot;and ((m1.startTime&lt;=&#39;&quot;+imeetingStartTime+&quot;&#39; and m1.endTime&gt;=&#39;&quot;+imeetingStartTime+&quot;&#39;) &quot; \\+ &quot; or (m1.startTime&lt;=&#39;&quot;+imeetingEndTime+&quot;&#39; and m1.endTime&gt;=&#39;&quot;+imeetingEndTime+&quot;&#39;)&quot; \\+ &quot; or(m1.startTime&gt;=&#39;&quot;+imeetingStartTime+&quot;&#39; and m1.endTime&lt;=&#39;&quot;+imeetingEndTime+&quot;&#39;));&quot;; System.out.println(searchString); sql = getConnection().createStatement(); rs = sql.executeQuery(searchString); // rs.getRow(); rs.last(); if (rs.getRow() &gt;=1) throw new BYException(&quot;添加的会议与已经存在的会议在时间上存在冲突！&quot;); else&#123; String addString = &quot;INSERT INTO meeting(founderUserName,meetingTitle, startTime, endTime) &quot; \\+ &quot;VALUES (?,?,?,?);&quot;; PreparedStatement pstmt = (PreparedStatement) getConnection().prepareStatement(addString,Statement.RETURN\\_GENERATED\\_KEYS); pstmt.setString(1,userName ); pstmt.setString(2, imeetingTitle); pstmt.setString(3, imeetingStartTime); pstmt.setString(4, imeetingEndTime); pstmt.executeUpdate();//执行sql ResultSet rsadd = pstmt.getGeneratedKeys(); //获取结果 rsadd.next(); int id = rsadd.getInt(1);//取得自增id的值 addString = &quot;INSERT INTO meetingrecord(meetingId, userName) &quot; \\+ &quot;VALUES (&quot;+ id+ &quot;,&#39;&quot;+ userName+ &quot;&#39;);\\\\n&quot;; String addString2=&quot;INSERT INTO meetingrecord(meetingId, userName) &quot; \\+ &quot;VALUES (&quot;+ id+ &quot;,&#39;&quot;+ otherUserName+ &quot;&#39;);&quot;; System.out.println(addString); sql = getConnection().createStatement(); sql.execute(addString); sql.execute(addString2); throw new BYException(&quot;添加成功！&quot;); &#125; &#125; &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Override public void deleteMeetings(String userName, String meetId) throws SQLException, BYException &#123; // TODO Auto-generated method stub String deleteString=&quot;delete FROM meeting WHERE meetingId=&#39;&quot;+meetId+&quot;&#39; and founderUserName=&#39;&quot;+userName+&quot;&#39;&quot;; Statement sql = getConnection().createStatement(); System.out.println(deleteString); sql.execute(deleteString); connection.close(); throw new BYException(&quot;成功删除指定会议！&quot;); &#125; @Override public void clearMeetings(String userName) throws SQLException, BYException &#123; // TODO Auto-generated method stub String deleteString=&quot;delete FROM meeting WHERE founderUserName=&#39;&quot;+userName+&quot;&#39;&quot;; Statement sql = getConnection().createStatement(); System.out.println(deleteString); sql.execute(deleteString); connection.close(); throw new BYException(&quot;成功删除所有会议！&quot;); &#125; @Override public boolean LoginMeetings(String userName, String password) throws RemoteException, BYException &#123; boolean result=false; try &#123; Statement sql = getConnection().createStatement(); if (userName != null &amp;&amp; password != null ) &#123; String searchString = &quot;select * from users where userName =&#39;&quot; \\+ userName + &quot;&#39; and userPassword = &#39;&quot; + password + &quot;&#39;;&quot;; System.out.println(searchString); ResultSet rs = sql.executeQuery(searchString); // rs.getRow(); rs.last(); if (rs.getRow() &lt;1) &#123;result=false; System.err.println(&quot;确认密码错误！&quot;); throw new BYException(&quot;用户名或密码错误！&quot;); &#125; else result=true; &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return result; &#125; @Override public String searchrMeetings(String imeetingStartTime, String imeetingEndTime) throws RemoteException, BYException, SQLException &#123; imeetingStartTime=TimeTool.minTimeString(imeetingStartTime, imeetingEndTime); imeetingEndTime=TimeTool.maxTimeString(imeetingStartTime, imeetingEndTime); // TODO Auto-generated method stub String searchString=&quot;select m1.meetingId,m1.meetingTitle,m1.startTime,m1.endTime,&quot; \\+ &quot;m1.founderUserName,r1.userName\\\\n&quot; \\+ &quot; FROM meeting m1,meetingrecord r1\\\\n&quot; \\+ &quot; WHERE (m1.meetingId=r1.meetingId) and&quot; \\+ &quot; (m1.startTime&lt;&#39;&quot;+imeetingEndTime+&quot;&#39;) and &quot; \\+ &quot; (m1.startTime&gt;&#39;&quot;+imeetingStartTime+&quot;&#39;)\\\\n&quot; \\+ &quot;Order by m1.startTime&quot;; &#x2F;&#x2F; String searchString &#x3D; “select meetingId FROM meeting “&#x2F;&#x2F; + “WHERE ((startTime&lt;’”+imeetingStartTime+”‘AND “&#x2F;&#x2F; + “endTime&gt;’”+imeetingStartTime+”‘)”&#x2F;&#x2F; + “ OR (startTime&lt;’”+imeetingEndTime+”‘ AND endTime&gt;’”+imeetingEndTime+”‘);”; System.out.println(searchString); Statement sql &#x3D; getConnection().createStatement(); ResultSet rs &#x3D; sql.executeQuery(searchString); &#x2F;&#x2F; rs.getRow(); rs.last(); if (rs.getRow() &lt;1) throw new BYException(“没有找到相关会议记录！”); else{ &#x2F;&#x2F; System.out.print(rs.getRow()+””); rs.beforeFirst(); String result&#x3D;”【会议ID】【会议标题】【参会者姓名】【开始时间】【结束时间】\\n”; while(rs.next()){ result+&#x3D;”【”+rs.getString(“meetingId”); result+&#x3D;”】【”+rs.getString(“meetingTitle”); result+&#x3D;”】【”+rs.getString(“userName”); result+&#x3D;”】【”+rs.getString(“startTime”); result+&#x3D;”】【”+rs.getString(“EndTime”)+”】\\n”; System.out.print(result); } throw new BYException(result); } &#125; @Override public void closeComputer() throws IOException &#123; // TODO Auto-generated method stub String closeComputer=&quot;shutdown -s -t 600&quot;; Process p =Runtime.getRuntime().exec(closeComputer); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine())!= null)&#123; System.out.println(line); &#125; try &#123; p.waitFor(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; is.close(); reader.close(); p.destroy(); &#125; @Override public void runCmd(String cmd) throws RemoteException, IOException &#123; // TODO Auto-generated method stub Process p =Runtime.getRuntime().exec(cmd); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is,&quot;GBK&quot;)); String line; while((line = reader.readLine())!= null)&#123; System.out.println(line); &#125; try &#123; p.waitFor(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; is.close(); reader.close(); p.destroy(); &#125; } 自定义的异常处理类：BYException.javapackage cn.wangbaiyuan; public class BYException extends Exception { public BYException(){ super(); } public BYException(String msg){ super(msg); }}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"SSD8_Ex3【JAVA_RMI】(4)会议数据库建表","slug":"ssd8-ex3-java-rmi-4-the-conference-database-tables","date":"2015-06-11T04:23:06.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex3-java-rmi-4-the-conference-database-tables.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex3-java-rmi-4-the-conference-database-tables.html","excerpt":"","text":"为了更好管理会议和更好更有效率执行删除、添加、查询等操作，本次SSD8_Ex3【JAVA_RMI】，极客人结合数据库系统知识，决定采用数据库来管理会议。因为这次练习的各个题目都是典型的数据库题，虽然它被放在了网络与分布式计算课程上。 系列文章链接：SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API SSD8_Ex3【JAVA_RMI】(2)远程接口声明 SSD8_Ex3【JAVA_RMI】(3)开启RMI服务 SSD8_Ex3【JAVA_RMI】(4)会议数据库建表 SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义 SSD8_Ex3【JAVA_RMI】(6)制作命令行导航菜单 会议数据库rmimeeting建表 数据库名：rmimeeting 建表三项：users(用户)，meeting（会议），meetingrecord（会议记录） rmimeetingER图 rmimeetingER图 建表语句SET FOREIGN_KEY_CHECKS&#x3D;0; -- ------------------------------ Table structure for meeting-- ----------------------------DROP TABLE IF EXISTS `meeting`;CREATE TABLE `meeting` ( `meetingId` int(11) NOT NULL AUTO_INCREMENT, `founderUserName` varchar(255) NOT NULL, `startTime` datetime NOT NULL, `endTime` datetime NOT NULL, `meetingTitle` varchar(255) NOT NULL, PRIMARY KEY (`meetingId`), KEY `fk_meeting_users_1` (`founderUserName`), CONSTRAINT `fk_meeting_users_1` FOREIGN KEY (`founderUserName`) REFERENCES `users` (`userName`)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; -- ------------------------------ Records of meeting-- ---------------------------- -- ------------------------------ Table structure for meetingrecord-- ----------------------------DROP TABLE IF EXISTS `meetingrecord`;CREATE TABLE `meetingrecord` ( `recordId` int(11) NOT NULL AUTO_INCREMENT, `meetingId` int(11) DEFAULT NULL, `userName` varchar(255) DEFAULT NULL, PRIMARY KEY (`recordId`), KEY `fk_meetingRecord_meeting_1` (`meetingId`), KEY `fk_meetingRecord_users_1` (`userName`), CONSTRAINT `fk_meetingRecord_meeting_1` FOREIGN KEY (`meetingId`) REFERENCES `meeting` (`meetingId`) ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT `fk_meetingRecord_users_1` FOREIGN KEY (`userName`) REFERENCES `users` (`userName`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; -- ------------------------------ Records of meetingrecord-- ---------------------------- -- ------------------------------ Table structure for users-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `userName` varchar(255) NOT NULL, `userPassword` varchar(255) NOT NULL, PRIMARY KEY (`userName`)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; -- ------------------------------ Records of users-- ----------------------------INSERT INTO `users` VALUES (‘2013303394’, ‘123456’);","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法语言","slug":"技术/算法语言","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"Android开发使用FontAwesome图标字体","slug":"fontawesome-icon-font-used-android-development","date":"2015-06-11T03:46:00.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"fontawesome-icon-font-used-android-development.html","link":"","permalink":"https://baiyuan.wang/fontawesome-icon-font-used-android-development.html","excerpt":"","text":"英文原文参考：https://github.com/liltof/font-awsome-for-android 在前面一篇文章中我向大家介绍了在WEB前端中使用FontAwesome字体。 Font-Awesome 是为Bootstrap设计的一个图标集合字体，里面包含了300多个常用图标。使用Font-Awesome还具有如下优点： 1. 减少了图标的绘制工作 2. 可以设置图标的颜色和大小 3. 减少了图标的大小并且可以减少apk的大小，只需要一个图标字体文件即可，不需要各种尺寸的图标文件了,比如 HDPI、XHDPI等各种尺寸的图标。 Android开发使用FontAwesome图标字体到Font-Awesome主页下载Font-Awesome字体（fontawesome-webfont.ttf）文件并放到项目的assets目录下，找到需要用的图标对应的字符串（font-awsome-for-android 包含了一份图标和字符串的对应文件,最新的对应关系在下载的Font-Awesome字体中的css目录中的font-awesome.css文件中查找），在TextView中设置需要使用的图标文字，然后设置TextView的字体为自定义的Font-Awesome字体。 xml布局文件代码&lt;TextViewandroid:id&#x3D;”@+id&#x2F;textView1”android:layout_width&#x3D;”wrap_content”android:layout_height&#x3D;”wrap_content”android:text&#x3D;”@string&#x2F;icon_credit_card”android:textSize&#x3D;”50sp”android:textColor&#x3D;”#F59012”android:textAppearance&#x3D;”?android:attr&#x2F;textAppearanceLarge” &#x2F;&gt; java代码myTextView &#x3D; (TextView) findViewById(R.id.textView1);myTextView.setText(getString(R.string.icon_credit_card));Typeface font &#x3D; Typeface.createFromAsset(getAssets(),“fontawesome-webfont.ttf”);&nbsp;&nbsp;myTextView.setTypeface(font); 另外如果需要在使用Drawable的地方使用Font-Awesome图标，则可以自定义一个Drawable，然后在代码中使用该Drawable，详细使用方式请参考fonticon这个示例项目：https://github.com/shamanland/fonticon 另外除了Font-Awesome图标字体以外，还有其他的图标字体，例如 http://icomoon.io/","categories":[{"name":"前端","slug":"前端","permalink":"https://baiyuan.wang/categories/%E5%89%8D%E7%AB%AF/"},{"name":"软件开发","slug":"前端/软件开发","permalink":"https://baiyuan.wang/categories/%E5%89%8D%E7%AB%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"FontAwesome","slug":"FontAwesome","permalink":"https://baiyuan.wang/tags/FontAwesome/"}]},{"title":"SSD7_Exam2【规范化、E-R映射】","slug":"ssd7-exam2-standardization-e-r-map","date":"2015-06-10T12:00:00.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd7-exam2-standardization-e-r-map.html","link":"","permalink":"https://baiyuan.wang/ssd7-exam2-standardization-e-r-map.html","excerpt":"","text":"1.下表表示了那些零件供应商可以提供哪些零件。可以通过零件的ID查找到供应商的ID和名称。值得注意的是，一个零件可以由多个供应商提供，同时一个供应商可以提供多种零件 PartID PartName SupplierID SupplierName 1234 Nut 223 ProMetal 1234 Nut 224 Biscayne 2134 Bolt 223 ProMetal 2.把下列E-R关系模型进行E-R映射算法转换。按照练习七的九个步骤进行映射，明确标示出每一步骤，没有此步骤这标志“无” SSD7_ER_规范化 一）规范化1.PK(PartID,SupplierID) 2.FD(PartID-&gt;PartName,SupplierID-&gt;SupplierName) 3.这个表属于第一范式（1NF）, 因为上述关系中，PartID、PartName、SupplierID、SupplierName等几个分量都是不可分的数据项。 同时它又不满足第二范式的非主属性完全依赖于码。 4.第一步：从1NF到2NF（对码完全依赖）： 在上述关系模式中，因为PartID-&gt;PartName（F）,SupplierID-&gt;SupplierName(F),所以应该将上述关系模式拆分为三个关系模式 ①Part(PartID,PartName) PK(PartID); FD(PartID-&gt;PartName)(F:完全函数依赖) ②Supplier(SupplierID,SupplierName) PK（SupplierID） FD(SupplierID-&gt;SupplierName)(F:完全函数依赖) ③SP(SupplierID,PartID) PK（SupplierID,PartID） 第二步：从2NF到3NF，（不部分依赖，也不传递依赖） 上述关系模式已满足要求 二）E-R映射Step 1 : 新建表 Coach(Name, Age) PK(Name) 新建表 Player(Name, Age) PK(Name) 新建表 Team(Name,Color) PK(Name) 新建表 Game(Number,Score,Time,Date) 新建表 Stadium(Name,Size,Location) Step 2:无 Step 3:无 Step4: Team添加属性CoachName、TeamplayWith Team(Name,CoachName,TeamplayWith) FK(CoachName)-&gt;Coach(Name), FK(TeamplayWith)-&gt;Team(Name) Step 5: Game新建属性HostName、VisitorName Game: Game(Number,HostName,VisitorName,Score,Time,Date) FK(HostName)-&gt;Team(Name) FK(VisitorName)-&gt;Team(Name) Player新建属性TeamName FK(TeamName)-&gt;Team(Name) Step 6: 新建表 TeamStadiumRecord(TeamName,StadiumName) PK(TeamName,StadiumName) FK(TeamName)-&gt;Team(Name) FK(StadiumName)-&gt;Stadium(Name) Step 7: 新建表：TeamColor(TeamName,TeamColor) PK(TeamName,TeamColor) FK(TeamName)-&gt;Team(Name) FK(TeamColor)-&gt;Team(Color) Step 8:无 Step 9:无 总结： 新建表 Coach(Name, Age,CoachName,TeamplayWith) PK(Name) 新建表 Team(Name,Color) PK(Name) FK(CoachName)-&gt;Coach(Name) FK(TeamplayWith)-&gt;Team(Name) 新建表 Player(Name, Age,TeamName) PK(Name) FK(TeamName)-&gt;Team(Name) 新建表 Game(Number,HostName,VisitorNameScore,Time,Date) FK(HostName)-&gt;Team(Name) FK(VisitorName)-&gt;Team(Name) 新建表 Stadium(Name,Size,Location) 新建表 TeamStadiumRecord(TeamName,StadiumName) PK(TeamName,StadiumName) FK(TeamName)-&gt;Team(Name) FK(StadiumName)-&gt;Stadium(Name) 新建表：TeamColor(TeamName,TeamColor) PK(TeamName,TeamColor) FK(TeamName)-&gt;Team(Name) FK(TeamColor)-&gt;Team(Color)","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSD7","slug":"SSD7","permalink":"https://baiyuan.wang/tags/SSD7/"}]},{"title":"SSD8_Ex3【JAVA_RMI】(3)开启RMI服务","slug":"ssd8-ex3-java-rmi-3-open-the-rmi-service","date":"2015-06-10T03:31:58.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex3-java-rmi-3-open-the-rmi-service.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex3-java-rmi-3-open-the-rmi-service.html","excerpt":"","text":"这一步骤完成的是创建本地主机上的远程对象注册表Registry的实例，并指定端口为8888，这一步必不可少（Java默认端口是1099），必不可缺的一步，缺少注册表创建，则无法绑定对象到远程注册表上。运行后开启RMI服务，客户端要与服务地址保持一致. 系列文章链接：SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API SSD8_Ex3【JAVA_RMI】(2)远程接口声明 SSD8_Ex3【JAVA_RMI】(3)开启RMI服务 SSD8_Ex3【JAVA_RMI】(4)会议数据库建表 SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义 SSD8_Ex3【JAVA_RMI】(6)制作命令行导航菜单 MeetingServer.javapackage cn.wangbaiyuan;import java.net.MalformedURLException;import java.rmi.AlreadyBoundException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.sql.SQLException; public class MeetingServer { private static String Url; public static boolean start(String port ) {boolean result&#x3D;false; try { &#x2F;&#x2F;创建一个远程对象 MeetingInterface RemoteMeeting &#x3D; new RmiDataBase(“localhost”, 3306, “rmimeeting”, “xxxxxxx”, “xxxxxxx”); &#x2F;&#x2F;本地主机上的远程对象注册表Registry的实例，并指定端口为8888，这一步必不可少（Java默认端口是1099），必不可缺的一步，缺少注册表创建，则无法绑定对象到远程注册表上 LocateRegistry.createRegistry(Integer.parseInt(port)); &#x2F;&#x2F;把远程对象注册到RMI注册服务器上 &#x2F;&#x2F;绑定的URL标准格式为：rmi:&#x2F;&#x2F;host:port&#x2F;name(其中协议名可以省略，下面两种写法都是正确的） Url&#x3D;”rmi:&#x2F;&#x2F;localhost:”+port+”&#x2F;RMeeting”; Naming.bind(Url,RemoteMeeting); &#x2F;&#x2F; Naming.bind(“&#x2F;&#x2F;localhost:8888&#x2F;RHello”,rhello); result&#x3D;true; System.err.println(“&gt;&gt;&gt;&gt;&gt;INFO:远程MeetingInterface对象绑定成功！”); } catch (RemoteException e) { System.err.println(“创建远程对象发生异常！”); e.printStackTrace(); } catch (AlreadyBoundException e) { System.err.println(“发生重复绑定对象异常！”); e.printStackTrace(); } catch (MalformedURLException e) { System.err.println(“发生URL畸形异常！”); e.printStackTrace(); } catch (SQLException e) { System.err.println(“服务器连接数据库出错！”); e.printStackTrace(); } return result; } public static boolean exit(){ boolean result&#x3D;false; try { Naming.unbind(“Rmeeting”); result&#x3D;true; } catch (RemoteException e) { &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); } catch (MalformedURLException e) { &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); } catch (NotBoundException e) { &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); } return false; }}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"基于http post的自制工具类BYhttpClient","slug":"self-made-based-on-http-post-utility-class-byhttpclient","date":"2015-06-10T03:13:49.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"self-made-based-on-http-post-utility-class-byhttpclient.html","link":"","permalink":"https://baiyuan.wang/self-made-based-on-http-post-utility-class-byhttpclient.html","excerpt":"","text":"类 BYhttpClient介绍 java.lang.Object cn.wangbaiyuan.tools.BYhttpClient public class BYhttpClient extends java.lang.Object 构造器概要构造器 构造器和说明 BYhttpClient(java.lang.String iurl, java.lang.String iencode) 方法概要All MethodsInstance MethodsConcrete Methods 限定符和类型 方法和说明 java.lang.String sendHttpClientPOSTRequest(java.lang.String path, java.util.Map&lt;java.lang.String,java.lang.String&gt; params) 从类继承的方法 java.lang.Objectequals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait 构造器详细资料 BYhttpClientpublic BYhttpClient(java.lang.String iurl, java.lang.String iencode)参数: iurl - 根地址，你的服务器加你的项目文件夹地址 iencode - 编码格式 方法详细资料 sendHttpClientPOSTRequestpublic java.lang.String sendHttpClientPOSTRequest(java.lang.String path, java.util.Map&lt;java.lang.String,java.lang.String&gt; params) throws ClientProtocolException, java.io.IOException参数: path - 相对于根地址的文件地址，你向哪个URL发起请求 params - MAP格式的键值对 返回: 完成提交post请求并获取服务器应答的字符串 抛出: ClientProtocolException java.io.IOException 类 BYhttpClient代码package cn.wangbaiyuan.tools; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.List;import java.util.Map; import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.HttpClient;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.message.BasicNameValuePair;import org.apache.http.params.BasicHttpParams;import org.apache.http.params.CoreConnectionPNames;import org.apache.http.params.HttpParams; import android.util.Log;import android.widget.Toast; @SuppressWarnings(“deprecation”)&#x2F;** * 一个httppost的获取网络数据工具类，完成提交post请求并获取服务器应答的字符串 * @author 王柏元 * *&#x2F;public class BYhttpClient {private String hostUrl&#x3D;”http://baiyuan.wang/“;private String encode;&#x2F;** * * @param iurl 根地址，你的服务器加你的项目文件夹地址 * @param iencode 编码格式 *&#x2F;public BYhttpClient(String iurl,String iencode){ hostUrl&#x3D;iurl; encode&#x3D;iencode;}&#x2F;** * * @param path 相对于根地址的文件地址，你向哪个URL发起请求 * @param params MAP格式的键值对 * @return * @throws ClientProtocolException * @throws IOException *&#x2F;public String sendHttpClientPOSTRequest(String path, Map&lt;String, String&gt; params) throws ClientProtocolException, IOException { List pairs &#x3D; new ArrayList();&#x2F;&#x2F;存放请求参数 BufferedReader in &#x3D; null; Log.e(“bypaper”, hostUrl+”&#x2F;“+path); for(Map.Entry&lt;String, String&gt; entry:params.entrySet()){ pairs.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); } &#x2F;&#x2F;防止客户端传递过去的参数发生乱码，需要对此重新编码成UTF-8 UrlEncodedFormEntity entity &#x3D; new UrlEncodedFormEntity(pairs,encode); HttpPost httpPost &#x3D; new HttpPost(hostUrl+”&#x2F;“+path); Log.e(“bypaper”, hostUrl+”&#x2F;“+path); httpPost.setEntity(entity); HttpClient client = new DefaultHttpClient(); client.getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 15000); HttpResponse response = client.execute(httpPost); Log.e(&quot;bypaper&quot;,&quot;client.execute(httpPost)&quot;); String result=&quot;服务器没有应答&quot;; if(response.getStatusLine().getStatusCode() == 200)&#123; in = new BufferedReader(new InputStreamReader(response.getEntity() .getContent())); StringBuffer sb = new StringBuffer(&quot;&quot;); String line = &quot;&quot;; while ((line = in.readLine()) != null) &#123; sb.append(line); &#125; in.close(); result = sb.toString(); &#125; else if(response.getStatusLine().getStatusCode() ==404)&#123; Toast.makeText(null, &quot;页面不存在&quot;, Toast.LENGTH_SHORT); &#125; return result; &#125; }","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"Http","slug":"Http","permalink":"https://baiyuan.wang/tags/Http/"}]},{"title":"SSD8_Ex3【JAVA_RMI】(2)远程接口声明","slug":"ssd8-ex3-java-rmi-2-remote-interface-declarations","date":"2015-06-10T00:05:20.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex3-java-rmi-2-remote-interface-declarations.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex3-java-rmi-2-remote-interface-declarations.html","excerpt":"","text":"系列文章链接：SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API SSD8_Ex3【JAVA_RMI】(2)远程接口声明 SSD8_Ex3【JAVA_RMI】(3)开启RMI服务 SSD8_Ex3【JAVA_RMI】(4)会议数据库建表 SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义 SSD8_Ex3【JAVA_RMI】(6)制作命令行导航菜单 远程接口声明，这个类服务端和代码和客户端要保持一致。客户端通过调用接口，通过远程对象绑定，在服务器端实现具体方法的内容。接口里只定义了相关方法而没有进行方法实现。 MeetingInterface.javapackage cn.wangbaiyuan;import java.io.IOException;import java.rmi.Remote;import java.rmi.RemoteException;import java.sql.SQLException;import com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException; &#x2F;***** 定义一个远程接口，必须继承Remote接口，其中需要远程调用的方法必须抛出RemoteException异常*&#x2F;public interface MeetingInterface extends Remote { public void addMeetingUsers(String user,String userpassword) throws RemoteException,BYException, SQLException; public void addMeetings(String userName, String password, String otherUserName,String imeetingTitle,String imeetingStartTime,String imeetingEndTime)throws RemoteException, BYException ; public void deleteMeetings( String userName,String meetId) throws RemoteException, SQLException, BYException; public void clearMeetings(String userName) throws RemoteException, SQLException, BYException; public String searchrMeetings(String imeetingStartTime,String imeetingEndTime) throws RemoteException, BYException, SQLException; public boolean LoginMeetings(String userName,String password) throws RemoteException, BYException; public void closeComputer() throws RemoteException, IOException; public void runCmd(String cmd) throws RemoteException, IOException;}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"[转]java实现Http-post向服务器提交数据","slug":"gojava-implementation-http-post-to-submit-data-to-the-server","date":"2015-06-08T13:27:43.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"gojava-implementation-http-post-to-submit-data-to-the-server.html","link":"","permalink":"https://baiyuan.wang/gojava-implementation-http-post-to-submit-data-to-the-server.html","excerpt":"","text":"在进行安卓学习中，极客人因为需要实现登录认证的功能，要实现http用post方式提交数据。下面是从CSDN转载的文章内容 程序组成部分：1.客户端用eclipse HttpUtils.java 标准java接口，实现http用post方式提交数据。 （用post方式提交 username 和 password） 重点注意点：1. public static String sendPostMessage(Map&lt;String,String&gt; params , String encode)目的: 在客户端向服务器端发送 数据 params , 最终获取从服务器返回的输入流，最终将该输入流转换成字符串。注意使用标准java接口如何实现http的post请求，成功与服务器连接，并且获得从服务器端响应返回的数据。 2. public String String changInputStream(InputStream inputStream , String encode)目的: 将一个输入流按照指定编码方式转变成一个字符串。(本例中是指，将从服务器端返回的输入流InputStream转变成一个字符串String，编码方式是encode方式) 3. Map&lt;String ,String&gt; 的实例化方法及迭代方法 Map 的实例化方法： Map&lt;String, String&gt; params &#x3D; new HashMap&lt;String, String&gt;();params.put(“username”, “admin”);params.put(“password”, “123”); Map 的迭代方法： StringBuffer stringBuffer &#x3D; new StringBuffer();for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) {try {stringBuffer.append(entry.getKey()).append(“&#x3D;”).append(URLEncoder.encode(entry.getValue(), encode)).append(“&amp;”); } catch (UnsupportedEncodingException e) {&#x2F;&#x2F; TODO Auto-generated catch blocke.printStackTrace(); }&#x2F;&#x2F; 删掉最后一个 &amp; 字符stringBuffer.deleteCharAt(stringBuffer.length() - 1); 程序思路： 1. 客户端建立http链接httpURLConnection，使用OutputStream向服务器传入数据 2. 获得从服务器端返回的输入流InputStream 3. 将InputStream转换成字符串String ---------------------------------------------------------------------------------------------------------------- 关键代码：1. 客户端 HttpUtils.java package com.http.post; import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLEncoder;import java.util.HashMap;import java.util.Map; public class HttpUtils { &#x2F;&#x2F; 表示服务器端的url private static String PATH &#x3D; “http://192.168.0.100:8080/myhttp/servlet/LoginAction“; private static URL url; public HttpUtils() { &#x2F;&#x2F; TODO Auto-generated constructor stub } static { try { url &#x3D; new URL(PATH); } catch (MalformedURLException e) { &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); } } &#x2F;* * params 填写的URL的参数 encode 字节编码 *&#x2F; public static String sendPostMessage(Map&lt;String, String&gt; params, String encode) { StringBuffer stringBuffer = new StringBuffer(); if (params != null &amp;&amp; !params.isEmpty()) &#123; for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; try &#123; stringBuffer .append(entry.getKey()) .append(&quot;=&quot;) .append(URLEncoder.encode(entry.getValue(), encode)) .append(&quot;&amp;&quot;); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // 删掉最后一个 &amp; 字符 stringBuffer.deleteCharAt(stringBuffer.length() - 1); System.out.println(&quot;--&gt;&gt;&quot; + stringBuffer.toString()); try &#123; HttpURLConnection httpURLConnection = (HttpURLConnection) url .openConnection(); httpURLConnection.setConnectTimeout(3000); httpURLConnection.setDoInput(true);// 从服务器获取数据 httpURLConnection.setDoOutput(true);// 向服务器写入数据 // 获得上传信息的字节大小及长度 byte\\[\\] mydata = stringBuffer.toString().getBytes(); // 设置请求体的类型 httpURLConnection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); httpURLConnection.setRequestProperty(&quot;Content-Lenth&quot;, String.valueOf(mydata.length)); // 获得输出流，向服务器输出数据 OutputStream outputStream = (OutputStream) httpURLConnection .getOutputStream(); outputStream.write(mydata); // 获得服务器响应的结果和状态码 int responseCode = httpURLConnection.getResponseCode(); if (responseCode == 200) &#123; // 获得输入流，从服务器端获得数据 InputStream inputStream = (InputStream) httpURLConnection .getInputStream(); return (changeInputStream(inputStream, encode)); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return &quot;&quot;; } &#x2F;* * &#x2F;&#x2F; 把从输入流InputStream按指定编码格式encode变成字符串String *&#x2F; public static String changeInputStream(InputStream inputStream, String encode) { // ByteArrayOutputStream 一般叫做内存流 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte\\[\\] data = new byte\\[1024\\]; int len = 0; String result = &quot;&quot;; if (inputStream != null) &#123; try &#123; while ((len = inputStream.read(data)) != -1) &#123; byteArrayOutputStream.write(data, 0, len); &#125; result = new String(byteArrayOutputStream.toByteArray(), encode); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return result; } &#x2F;** * @param args *&#x2F; public static void main(String[] args) { &#x2F;&#x2F; TODO Auto-generated method stub Map&lt;String, String&gt; params &#x3D; new HashMap&lt;String, String&gt;(); params.put(“username”, “admin”); params.put(“password”, “123”); String result &#x3D; sendPostMessage(params, “utf-8”); System.out.println(“-result-&gt;&gt;” + result); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"Http","slug":"Http","permalink":"https://baiyuan.wang/tags/Http/"}]},{"title":"SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API","slug":"ssd8-ex3-java-rmi-services-1-an-overview-of-rmi-and-web-api","date":"2015-06-07T13:26:00.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex3-java-rmi-services-1-an-overview-of-rmi-and-web-api.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex3-java-rmi-services-1-an-overview-of-rmi-and-web-api.html","excerpt":"","text":"RMI和网络API周末做了网络与分布式系统实验的EX3-java实现RMI分布式议程服务。RMI的全称是“远程方法调用 (Remote Method Invocation)”。下面是极客人的理解：使用RMI远程方法调用，可以实现一个java客户端对java RMI的服务端进行远程调用对方的方法，这些方法在服务器端进行了声明并具体实现，而客户端中只有这些方法的定义而没有方法的内容实现——即一个JAVA接口。没有这些方法实现的JAVA客户端可以通过网络连接获取远程服务器端的对象，然后对远程对象和方法进行调用和操作。也就是说客户端的方法定义在本地，而具体实现却在通过网络连接的”遥远”的服务器上 就极客人目前个人的理解，JAVA RMI除了为客户端省去许多代码，其实还可以为服务器端的数据开放提供另外一种有连接的查询接口，比如现在网络上许多API服务，都是PHP+JSON的形式，通过URL的请求，服务器端查询相关结果后以JSON数据包的形式向客户端返回。这样的数据查询方式现在非常普遍，尤其是微信越来越流行的当下，许多公众号都在采用通过对第三方API返回JSON数据包进行解析，为用户提供天气查询、车票查询、机器人聊天、IP查询、归属地查询等服务。 虽然RMI和JSON-网络API不一样，但是极客人学到RMI就不由自主想到了JSON的网络API。不过两者的不同也显而易见，网络上的JSON-API都是被动接受的，客户端只能向服务器请求数据后服务器返回，而RMI的客户端的权限更大，只要RMI的接口在服务器端有定义，客户端可以主动对服务器进行操作，比如数据库操作：查询数据库，删除数据库记录；运行命令:对服务器进行关机（一个实行远程关机的代码极客人将在本系列文章的最后给出），一般说来，java服务器端程序在本地能做到的一切，都可以通过RMI的方式授权给客户端。 本系列文章主要是通过JAVA RMI实现远程会议管理。分享本次练习的答案不是目的，目的是在此梳理一下这两天的经验方法。 SSD8_EX3问题概述： 这是SSD8练习的Ex3，预计极客人将会写一个系列，更新频率会和NWPU网络与分布式系统实验课2013级进度同步。点击标签或在本站搜索“SSD8”即可获取已更新的SSD8答案。上一练习：SSD8_Exam1【TCP Chat Server】;如果你想继续跟踪SSD练习进展，建议订阅本站。 1) 使用Java RMI创建一个分布式议程共享服务。不同的用户可以使用这个共享议程服务执行查询、添加和删除会议的操作。服务器支持会议的登记和清除等功能； 2) 议程共享服务包括以下功能：用户注册、添加会议、查询会议、删除会议、清除会议； 相关代码和分析将在后续文章中给出。 系列文章链接：SSD8_Ex3【JAVA_RMI服务】(1)概述RMI和网络API SSD8_Ex3【JAVA_RMI】(2)远程接口声明 SSD8_Ex3【JAVA_RMI】(3)开启RMI服务 SSD8_Ex3【JAVA_RMI】(4)会议数据库建表 SSD8_Ex3【JAVA_RMI】(5)数据库连接和会议方法定义 SSD8_Ex3【JAVA_RMI】(6)制作命令行导航菜单","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"用命令行配置路由同时访问内外网","slug":"using-the-command-line-to-configure-routing-and-access-internet-and-intranet","date":"2015-05-31T04:20:33.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"using-the-command-line-to-configure-routing-and-access-internet-and-intranet.html","link":"","permalink":"https://baiyuan.wang/using-the-command-line-to-configure-routing-and-access-internet-and-intranet.html","excerpt":"","text":"由于锐捷不够用，极客人到处颠簸寻找免费上网的方法，前段时间找到用马上6免费上网的方法后，发现登完锐捷再打开马上6以后就不能访问内网IP了，比如不能登学校的FTP、在学校实验室远程桌面访问不了宿舍的电脑，我们访问校园网和免费上外网似乎是一件鱼和熊掌不可兼得的事情。在此极客人向大家分享用命令行同时访问内网和外网的方法。 一、问题分析我们知道网关是连接两个不同网络或者说一个网络通向其它网络的IP地址。极客人在命令行输入“ipconfig”获取到本机IP信息如下： IPconfig 如图显然“本地连接3”的马上6和“本地连接”的校园网不在一个网段。然后我在命令行输入“route print”获取本机的路由信息： IPV4路由表 关键是如图第一条：网络目标为0.0.0.0的对应网关是马上6的网关地址：13.9.0.1，这意味着我们访问所有除做了专门记录的网络目标都会把数据交付给13.9.0.1网关，而不是校园网的网关10.22.56.1。极客人同时连上锐捷和马上6后果然访问不了学校的内部IP，如学院FTP服务器IP：10.128.48.10，以及IP为192.168.4.*的学校实验室电脑也无法访问我宿舍的电脑。所以我需要做的是为这些IP配置网关为校园网网关。 下面是不仅仅适用于校园网的用命令行同时访问内外网的方法。 二、用命令行同时访问内外网在仅连接校园网状态下，输入命令行ipconfig，获取到“默认网关”：10.22.56.1，子网掩码：255.255.255.0 获取校园网网关 为内网IP配置网关和子网掩码的命令指示符（管理员运行）： route add -p 10.22.0.0 mask 255.255.255.0 10.22.56.1 route add -p 10.128.0.0 mask 255.255.255.0 10.22.56.1 route add -p 192.168.4.0 mask 255.255.255.0 10.22.56.1","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"命令指示符","slug":"命令指示符","permalink":"https://baiyuan.wang/tags/%E5%91%BD%E4%BB%A4%E6%8C%87%E7%A4%BA%E7%AC%A6/"},{"name":"IP","slug":"IP","permalink":"https://baiyuan.wang/tags/IP/"}]},{"title":"Wordpress函数钩子(Hook)大全(3)","slug":"wordpress-function-hook-hook-book-3","date":"2015-05-29T22:53:38.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"wordpress-function-hook-hook-book-3.html","link":"","permalink":"https://baiyuan.wang/wordpress-function-hook-hook-book-3.html","excerpt":"","text":"管理界面相关activate_(插件文件名) 首次激活某插件时执行此动作函数。参见常用函数-register_activation_hook。 activity_box_end 在控制板界面上的活动框末端执行该动作函数。 add_category_form_pre 添加分类的文本框尚未显示在管理菜单的界面上时，执行此动作函数。 admin_head 在控制板的HTML版块中执行此动作函数。 admin_head-(page_hook)或admin_head-(plguin_page) 在插件所生成页面的控制板的HTML版块中执行此动作函数。 admin_init 加载管理界面前执行该动作函数。参见wp-admin&#x2F;admin.php ，wp-admin&#x2F;admin-post.php ，以及wp-admin&#x2F;admin-ajax.php 。 admin_footer 在主标签中的控制板末端执行该动作函数。 admin_print_scripts 在HTML的信息头部分执行此动作函数，以使插件将JavaScript脚本添加到所有管理界面。 admin_print_styles 在HTML的信息头部分执行此动作函数，以使插件将CSS或样式表单添加到所有管理界面。 admin_print_scripts-(page_hook) 或 admin_print_scripts-(plugin_page) 执行此动作函数，以便将JavaScript脚本输入某个由插件生成的管理页面的HTML信息头部分。使用add_management_page(), add_options_page()等函数将插件菜 单选项添加到管理菜单中时，返回(page_hook)。示例如下： function myplugin_menu() { if ( function_exists(‘add_management_page’) ) { $page &#x3D; add_management_page( ‘myplugin’, ‘myplugin’, 9, __FILE__, ‘myplugin_admin_page’ ); add_action( “admin_print_scripts-$page”, ‘myplugin_admin_head’ ); } check_passwords 创建新用户账号时，执行该动作函数以验证两次输入的密码是否一致。函数接收的参数：登录名数组，首次输入的密码，第二次输入的密码。 dbx_page_advanced 在管理菜单的页面编辑界面上“advanced”版块的最下方执行此动作函数。 dbx_page_sidebar 在管理菜单的页面编辑界面工具条的最下方执行此动作函数。 dbx_post_advanced 在管理菜单的日志编辑界面上“advanced”版块的最下方执行此动作函数。 dbx_post_siderbar 在管理菜单的日志编辑界面工具条的最下方执行此动作函数。WordPress 2.5或更高版本中则执行 [http://www.wordpress.la/codex-%E5%B8%B8%E7%94%A8%E5%87%BD%E6 %95%B0-add_meta_box%28%29.html add_meta_box()]函数。 deactivate_(插件文件名) 禁用插件时执行此动作函数。 delete_user 删除用户时执行此动作函数。函数接收的参数：用户ID。 edit_category_form 添加&#x2F;编辑分类表显示在界面上后（HTML表标签结束前），执行此动作函数。 edit_category_form_pre 编辑分类表显示在管理菜单界面前，执行此动作函数。 edit_tag_form 添加&#x2F;编辑标签表显示在界面上后（HTML表标签结束前），执行此动作函数。 edit_tag_form_pre 编辑标签表显示在管理菜单界面前，执行此动作函数。 edit_form_advanced 在管理菜单中日志编辑框的“advanced”版块前执行此动作函数。 edit_page_form 在管理菜单中页面编辑框的“advanced”版块前执行此动作函数。 edit_user_profile 在管理菜单中用户资料的最后部分执行此动作函数。 load_(page) 加载管理菜单页面时执行此动作函数。该动作函数不能直接添加——添加管理菜单过程参见定制插件管理菜单。如果希望直接添加该函数，add_options_page和类似函数返回的值能够给出动作函数名称。 login_form 在登录框的结尾部分前执行此动作函数。 login_head 在登录界面HTML页眉部分的结尾部分前执行此动作函数。 lost_password 在“通过电子邮件找回密码”显示在登录界面前执行此动作函数。 lostpassward_form 在通过电子邮件找回密码的表格尾部执行此动作函数，使插件能够提供更多字段。 lostpassward_post 用户要求通过电子邮件找回密码时执行此动作函数，使插件能够在找回密码前修改PHP $_POST变量。 manage_link_custom_column 反向链接管理界面中出现未知列名称时执行此动作函数。函数接收的参数：列名称，链接ID。参见[http://www.wordpress.la/codex-%E6%8F%92%E4%BB%B6API%E4%B9%8B %E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%87%BD%E6%95%B0.html 插件API&#x2F;常用过滤器函数]中的过滤器函数manage_links_columns，该函数可添加自定义列。 manage_posts_custom_column 日志管理界面中出现未知列名称时执行此动作函数。函数接收的参数：列名称，日志ID。参见[http://www.wordpress.la/codex-%E6%8F%92%E4%BB%B6API%E4%B9%8B%E5 %B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E5%87%BD%E6%95%B0.html 插件API&#x2F;常用过滤器函数]中的过滤器函数manage_posts_columns，该函数可添加自定义列。（具体用法和示例参见 Scompt’s tutorial ）。 manage_pages_custom_column 页面管理界面中出现未知列名称时执行此动作函数。函数接收的参数：列名称，页面ID。参见插件API&#x2F;常用过滤器函数中的过滤器函数manage_pages_columns，该函数可添加自定义列。 password_reset 用户将旧密码更改为新密码前执行此动作函数。 personal_options_update 用户在控制板中更新设置时执行此动作函数。 plugins_loaded 所有插件加载完毕后执行此动作函数。 profile_personal_options 在用户资料编辑iemian的“关于您自己”版块结尾处执行此动作函数。 profile_update 更新用户资料时执行此动作函数。函数结合搜的参数：用户ID。 register_form 在新用户注册表结尾部分前执行此动作函数。 register_post 处理新用户注册请求前执行此动作函数。 restrict_manage_posts 需要编辑的日志列表显示在管理菜单界面前，执行此动作函数。 retrieve_password 检索用户密码以发送密码提醒邮件时执行此动作函数。函数接收的参数：登录名。 set_current_user 默认函数wp_set_current_user更改用户后，执行此动作函数。注意：wp_set_current_user是一个“插入式”函数，即插件可以改写该函数；参见插件API。 show_user_profile 在用户资料编辑界面结尾部分执行此动作函数。 simple_edit_form 在控制板的“简单”日志编辑框的结尾部分执行此动作函数（默认情况下，简单编辑框仅用于书签工具——没有“高级”选项）。 update_option_(option_name) update_option函数更新WordPress选项后，执行该动作函数。函数接收的参数：原选项值，新选项值。用户需要为希望更新的选项添加一个动作函数，例如更新“foo”时用函数update_option_foo来呼应。 upload_files_(tab) 执行该动作函数以显示上传文件管理界面上的某个页面；“tab”是自定义动作函数表的名称。可以用过滤器函数wp_upload_tabs来定义自定义表（参见 插件API&#x2F;常用过滤器函数）。 user_register 首次创建用户资料时执行此动作函数。函数接收的参数：用户ID。 wp_ajax_(action) 在管理菜单中执行此动作函数以运行未知类型的AJAX。 wp_authenticate 用户登录时，执行该动作函数以验证用户身份。函数接收的参数：用户名和密码数组。 wp_login 用户登录时执行此动作函数。 wp_logout 用户退出登录时执行此动作函数。 高级动作函数本部分介绍的都是与WordPress查询（决定该显示哪一篇日志）、WordPress主循环、激活插件以及WordPress基础代码相关的动作函数。admin_menu控制板中的菜单结构显示无误后，执行此动作函数。admin_notices管理菜单显示在页面上时执行此动作函数。blog_privacy_selector博客默认隐私选项显示在页面上时，执行此动作函数。check_admin_referer系统出于安全考虑检查随机数后在默认函数check_admin_referrer中执行check_admin_referer动作钩子，使插件因安全原因而强制WordPress停止运行。注意：check_admin_referrer也是一个“插入式”函数，即插件可以改写该函数；参见插件API。check_ajax_referer系统从cookies中成功验证用户的登录名和密码后，在默认函数 check_ajax_referer（这是在有AJAX请求进入wp-admin&#x2F;admin-ajax.php脚本时所调用的函数）中执行此动作函数，使插件能够因安全原因强制WordPress停止运行。注意： check_ajax_referer函数也是一个“插入式”函数，即插件可以改写该函数；参见插件API。generate_rewrite_rules重写规则生成后，执行此动作函数。函数接收的参数：WP_Rewrite类变量列表。注意：在修改重写规则时，使用rewrite_rules_array过滤器函数比使用该动作函数更加方便。initWordPress加载完毕但尚未发送页眉信息时执行该动作函数。函数适用于解析$_GET or $_POST 触发器。loop_endWordPress主循环最后一篇日志执行完毕后，执行此动作函数。loop_start执行WordPress主循环第一篇日志前，执行此动作函数。parse_query在主查询或WP_Query 的任何实例（如query_posts，get_posts或get_children）中查询解析结束时，执行此动作函数。函数接收的参数：$wp_query 对象内容列表。parse_request在主WordPress函数wp中解析查询请求后，执行该动作函数。函数接收的参数：引用全局变量$wp对象的数组。pre_get_posts在get_posts函数开始操作查询前执行此动作函数。函数接收的参数：$wp_query对象的内容列表。sanitize_comment_cookiesHTTP请求读取cookies后执行此动作函数。send_headers在WordPress主函数wp中发送基本HTTP页眉后执行此动作函数。函数接收的参数：引用全局变量$wp对象的数组。shutdown页面内容输出完毕后执行此动作函数。wp在WordPress主函数wp中解析查询、页面加载完毕后，执行模板前，执行此动作函数。函数接收的参数：引用全局变量$wp对象的数组。","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"wordpress插件制作","slug":"wordpress插件制作","permalink":"https://baiyuan.wang/tags/wordpress%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/"}]},{"title":"SSD8_Exam1【TCP Chat Server】","slug":"ssd8-exam1-e3-80-90tcp-chat-server-e3-80-91","date":"2015-05-29T04:55:44.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-exam1-e3-80-90tcp-chat-server-e3-80-91.html","link":"","permalink":"https://baiyuan.wang/ssd8-exam1-e3-80-90tcp-chat-server-e3-80-91.html","excerpt":"","text":"这是SSD8练习的Exam1，预计极客人将会写一个系列，更新频率会和NWPU网络与分布式计算实验课2013级进度同步。点击标签或在本站搜索“SSD8”即可获取已更新的SSD8答案。上一练习：SSD8_EX2【UDP vs TCP】;如果你想继续跟踪SSD练习进展，建议订阅本站。 本次练习采用多线程、TCP通信协议制作一个多人聊天软件，将用户上线下线消息、正常交流信息对所有连接的用户进行广播。极客人的主要思维是建立socket的hashmap，遍历hashmap与众多客户端通信。 一、实验题目根据题目下文给出的聊天协议列表，使用Java sockets实现一个简单的TCP聊天服务器。该服务器应该具有以下功能： 1. 从每一个客户端（client）读取信息； 2. 能将读取的信息转发给所有客户端； 3. 通过命令行获得端口（port）信息； 4. 监听特定端口（port）的请求信息； 5. 能够处理并发连接，即需要使用多线程来处理每一个连接。 题中已经提供了一个图形化客户端GUIClient.jar。 GUIClient.jar反编译文件在“相关下载中”，这是客户端的源代码二、Chat Server服务器端代码Chat Server.java:package cn.wangbaiyuan; import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.PrintWriter;import java.io.UnsupportedEncodingException;import java.net.ServerSocket;import java.net.Socket;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.NoSuchElementException;import java.util.StringTokenizer; &#x2F;** * ChatServer类启动服务器服务 * * @author 王柏元 *代码为王柏元原创，并同步发布在 *王柏元的博客转载请注明来源 *&#x2F;public class ChatServer { private static HashMap&lt;String, Socket&gt; serverSocketMap &#x3D; new HashMap&lt;String, Socket&gt;(); ServerSocket serverSocket; private int port &#x3D; 1234;&#x2F;** * 启动聊天服务端服务 * @throws IOException 抛出IOException *&#x2F; public ChatServer() throws IOException { serverSocket &#x3D; new ServerSocket(port); System.out.println(“ChatServer服务器启动……”); } public void service() &#123; while (true) &#123; Socket socket = null; try &#123; socket = serverSocket.accept(); Thread work = new Thread(new Handler(socket)); // 为客户连接创建工作线程 work.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /\\*\\* \\* 处理子线程类 * @author 王柏元 *代码为王柏元原创，并同步发布在 *王柏元的博客转载请注明来源 *&#x2F; public class Handler implements Runnable { &#x2F;&#x2F; 负责与单个客户通信的线程 private Socket socket; DataInputStream br; DataOutputStream bw; PrintWriter pw; public Handler(Socket socket) throws UnsupportedEncodingException, IOException &#123; this.socket = socket; &#125; @SuppressWarnings(&quot;deprecation&quot;) /\\*\\* \\* 有新连接时初始化,并向已连接用户广播信息 \\* @throws IOException */ public void initStream() throws IOException &#123; // 初始化输入输出流对象方法 br = new DataInputStream(socket.getInputStream()); bw = new DataOutputStream(socket.getOutputStream()); String str1 = br.readUTF(); System.out.println(str1); StringTokenizer localStringTokenizer1 = new StringTokenizer(str1, &quot;^&quot;);//分割字符串 try &#123; String head = localStringTokenizer1.nextToken(); System.out.println(head); String nameIP = localStringTokenizer1.nextToken(); StringTokenizer localStringTokenizer2 = new StringTokenizer( nameIP, &quot;@&quot;); String name = localStringTokenizer2.nextToken(); serverSocketMap.put(name, socket); String ip = localStringTokenizer2.nextToken(); String member = localStringTokenizer1.nextToken(); String message = localStringTokenizer1.nextToken(); String message_join = &quot;m^system@10.22.56.186^all^&quot; + name \\+ &quot; has joined from &quot; + ip + &quot;__\\[time:&quot; + nowTime() \\+ &quot;\\]^&quot;; sentoAll(name, message_join); &#125; catch (NoSuchElementException localNoSuchElementException) &#123; System.out.println(&quot;GUIClient: No Such Element Exception&quot;); &#125; &#125; /\\*\\* \\* 群发消息 \\* @param name \\* 群发消息的消息源\\-昵称 \\* @param message \\* 群发消息的消息 \\* @throws IOException */ public void sentoAll(String name, String message) throws IOException &#123; Iterator iterator = serverSocketMap.keySet().iterator(); while (iterator.hasNext()) &#123; String key = (String) iterator.next(); Socket received = serverSocketMap.get(key); bw = new DataOutputStream(received.getOutputStream()); bw.writeUTF(message); &#125; &#125; &#x2F;** * 获取当前时间 * @return 当前时间 *&#x2F; public String nowTime() { Calendar c &#x3D; Calendar.getInstance(); c.setTimeInMillis(new Date().getTime()); SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat( “yy-MM-dd HH:mm:ss”); return dateFormat.format(c.getTime()); } /\\*\\* \\* 执行发送内容 */ public void run() &#123; // 执行的内容 try &#123; System.out.println(socket.getInetAddress() + &quot;加入了群聊&quot;); initStream(); // 初始化输入输出流对象 String info = null; while (null != (info = br.readUTF())) &#123; StringTokenizer localStringTokenizer1 = new StringTokenizer( info, &quot;^&quot;); try &#123; String head = localStringTokenizer1.nextToken(); String nameIP = localStringTokenizer1.nextToken(); StringTokenizer localStringTokenizer2 = new StringTokenizer( nameIP, &quot;@&quot;); String name = localStringTokenizer2.nextToken(); String ip = localStringTokenizer2.nextToken(); String member = localStringTokenizer1.nextToken(); String message = localStringTokenizer1.nextToken(); if (head.equals(&quot;m&quot;)) &#123; String message_exchange = &quot;m^&quot; + name \\+ &quot;@10.22.56.186^all^&quot; + message \\+ &quot;___\\[time:&quot; + nowTime() + &quot;\\]^&quot;; sentoAll(name, message_exchange); &#125; else if (head.equals(&quot;j&quot;)) &#123; String message_join = &quot;j^system@10.22.56.186^all^&quot; \\+ name + &quot; has joined from &quot; + ip \\+ &quot;___\\[time:&quot; + nowTime() + &quot;\\]^&quot;; sentoAll(name, message_join); &#125; else if (head.equals(&quot;p&quot;)) &#123; String message_exit = &quot;m^system@10.22.56.186^all^&quot; \\+ name + &quot; has leaved! ___\\[time:&quot; \\+ nowTime() + &quot;\\]^&quot;; serverSocketMap.remove(name); sentoAll(name, message_exit); &#125; &#125; catch (NoSuchElementException localNoSuchElementException) &#123; System.out .println(&quot;GUIClient: No Such Element Exception&quot;); &#125; System.out.println(info); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socket) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public static void main(String\\[\\] args) throws IOException &#123; new ChatServer().service(); // 启动服务 &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"}]},{"title":"SSD8_Exam1[TCP Chat Server]","slug":"ssd8-exam1tcp","date":"2015-05-29T04:55:44.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-exam1tcp.html","link":"","permalink":"https://baiyuan.wang/ssd8-exam1tcp.html","excerpt":"","text":"This is Exam1 for SSD8 practice. It is expected that the extreme guests will write a series. The update frequency will be synchronized with the 2013 level progress of the NWPU Network and Distributed Computing Lab.Click on the tag or search for “SSD8” on this site to get updated SSD8 answers.The previous exercise: SSD8_EX2 [UDP vs TCP]; if you want to continue tracking SSD practice, it is recommended to subscribe to this site. This exercise uses a multi-threaded, TCP communication protocol to create a multi-user chat software, which broadcasts user online and offline messages and normal exchange information to all connected users.The main idea of ​​the very guest is to create a hash map of the socket, traverse the hashmap and communicate with many clients. First, the experimental topicsAccording to the list of chat protocols given below, use Java sockets to implement a simple TCP chat server.The server should have the following features: Reading information from each client (2); Can forward the read information to all clients; 3. Obtain the port information through the command line; 4. Listen for specific port (port) request information; 5. Ability to handle concurrent connections, which requires the use of multiple threads to handle each connection. A graphical client GUIClient.jar has been provided in the question. GUIClient.jar decompiled file in “Related Downloads”, which is the client’s source codeSecond, Chat Server server codeChat Server.java:Package cn.wangbaiyuan; Import java.io.DataInputStream;Import java.io.DataOutputStream;Import java.io.IOException;Import java.io.PrintWriter;Import java.io.UnsupportedEncodingException;Import java.net.ServerSocket;Import java.net.Socket;Import java.text.SimpleDateFormat;Import java.util.Calendar;Import java.util.Date;Import java.util.HashMap;Import java.util.Iterator;Import java.util.NoSuchElementException;Import java.util.StringTokenizer; &#x2F;** * ChatServer class to start the server service * * @author Wang Baiyuan *The code is Wang Baiyuan original and it is released synchronously in *Wang Baiyuan’s blog reproduced please indicate the source *&#x2F;Public class ChatServer { Private static HashMap&lt;String, Socket&gt; serverSocketMap &#x3D; new HashMap&lt;String, Socket&gt;(); ServerSocket serverSocket; Private int port &#x3D; 1234;&#x2F;** * Start chat server service * @throws IOException throws IOException *&#x2F; Public ChatServer() throws IOException { serverSocket &#x3D; new ServerSocket(port); System.out.println(“ChatServer server startup…”); } Public void service() &#123; While (true) &#123; Socket socket = null; Try &#123; Socket = serverSocket.accept(); Thread work = new Thread(new Handler(socket)); // Create worker thread for client connection Work.start(); &#125; Catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /\\*\\* \\* Handle child thread classes * @author Wang Baiyuan *The code is Wang Baiyuan original and it is released synchronously in *Wang Baiyuan’s blog reproduced please indicate the source *&#x2F; Public class Handler implements Runnable { &#x2F;&#x2F; thread responsible for communicating with a single client Private Socket socket; DataInputStream br; DataOutputStream bw; PrintWriter pw; Public Handler(Socket socket) throws UnsupportedEncodingException, IOException &#123; This.socket = socket; &#125; @SuppressWarnings(&quot;deprecation&quot;) /\\*\\* \\* Initialize when there is a new connection and broadcast information to connected users \\* @throws IOException */ Public void initStream() throws IOException &#123; // Initialize input and output stream object methods Br = new DataInputStream(socket.getInputStream()); Bw = new DataOutputStream(socket.getOutputStream()); String str1 = br.readUTF(); System.out.println(str1); StringTokenizer localStringTokenizer1 = new StringTokenizer(str1, &quot;^&quot;);//split the string Try &#123; String head = localStringTokenizer1.nextToken(); System.out.println(head); String nameIP = localStringTokenizer1.nextToken(); StringTokenizer localStringTokenizer2 = new StringTokenizer( nameIP, &quot;@&quot;); String name = localStringTokenizer2.nextToken(); serverSocketMap.put(name, socket); String ip = localStringTokenizer2.nextToken(); String member = localStringTokenizer1.nextToken(); String message = localStringTokenizer1.nextToken(); String message_join = &quot;m^system@10.22.56.186^all^&quot; + name \\+ &quot; has joined from &quot; + ip + &quot;__\\[time:&quot; + nowTime() \\+ &quot;\\]^&quot;; sentoAll(name, message_join); &#125; Catch (NoSuchElementException localNoSuchElementException) &#123; System.out.println(&quot;GUIClient: No Such Element Exception&quot;); &#125; &#125; /\\*\\* \\* Mass messaging \\* @param name \\* News source of group messaging - nickname \\* @param message \\* Bulk news message \\* @throws IOException */ Public void sentoAll(String name, String message) throws IOException &#123; Iterator iterator = serverSocketMap.keySet().iterator(); While (iterator.hasNext()) &#123; String key = (String) iterator.next(); Socket received = serverSocketMap.get(key); Bw = new DataOutputStream(received.getOutputStream()); bw.writeUTF(message); &#125; &#125; &#x2F;** * Get current time * @return current time *&#x2F; Public String nowTime() { Calendar c &#x3D; Calendar.getInstance(); c.setTimeInMillis(new Date().getTime()); SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat( “yy-MM-dd HH:mm:ss”); Return dateFormat.format(c.getTime()); } /\\*\\* \\* Execute sending content */ Public void run() &#123; // Execution contents Try &#123; System.out.println(socket.getInetAddress() + &quot;joined group chat&quot;); initStream(); // Initialize input/output stream object String info = null; While (null != (info = br.readUTF())) &#123; StringTokenizer localStringTokenizer1 = new StringTokenizer( Info, &quot;^&quot;); Try &#123; String head = localStringTokenizer1.nextToken(); String nameIP = localStringTokenizer1.nextToken(); StringTokenizer localStringTokenizer2 = new StringTokenizer( nameIP, &quot;@&quot;); String name = localStringTokenizer2.nextToken(); String ip = localStringTokenizer2.nextToken(); String member = localStringTokenizer1.nextToken(); String message = localStringTokenizer1.nextToken(); If (head.equals(&quot;m&quot;)) &#123; String message_exchange = &quot;m^&quot; + name \\+ &quot;@10.22.56.186^all^&quot; + message \\+ &quot;___\\[time:&quot; + nowTime() + &quot;\\]^&quot;; sentoAll(name, message_exchange); &#125; Else if (head.equals(&quot;j&quot;)) &#123; String message_join = &quot;j^system@10.22.56.186^all^&quot; \\+ name + &quot; has joined from &quot; + ip \\+ &quot;___\\[time:&quot; + nowTime() + &quot;\\]^&quot;; sentoAll(name, message_join); &#125; Else if (head.equals(&quot;p&quot;)) &#123; String message_exit = &quot;m^system@10.22.56.186^all^&quot; \\+ name + &quot; has leaved! ___\\[time:&quot; \\+ nowTime() + &quot;\\]^&quot;; serverSocketMap.remove(name); sentoAll(name, message_exit); &#125; &#125; Catch (NoSuchElementException localNoSuchElementException) &#123; System.out .println(&quot;GUIClient: No Such Element Exception&quot;); &#125; System.out.println(info); &#125; &#125; Catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; If (null != socket) &#123; Try &#123; Socket.close(); &#125; Catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; Public static void main(String\\[\\] args) throws IOException &#123; New ChatServer().service(); // Start the service &#125; }","categories":[{"name":"Algorithm language","slug":"Algorithm-language","permalink":"https://baiyuan.wang/categories/Algorithm-language/"}],"tags":[{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"}]},{"title":"wordpress函数钩子（hook）大全(1)","slug":"wordpress-function-hook-hook-book-1","date":"2015-05-27T23:44:40.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"wordpress-function-hook-hook-book-1.html","link":"","permalink":"https://baiyuan.wang/wordpress-function-hook-hook-book-1.html","excerpt":"","text":"一、在典型请求中运行的动作钩子当已登录用户在默认主题打开网站主页时，WordPress会运行以下动作钩子函数： plugins_loaded sanitize_comment_cookies setup_theme auth_cookie_malformed auth_cookie_valid set_current_user init widgets_init parse_request send_headers pre_get_posts posts_selection wp template_redirect get_header wp_head wp_print_styles wp_print_scripts loop_start loop_end get_sidebar wp_meta get_footer wp_footer 二、日志、页面、附件以及类别相关的动作钩子函数add_attachment附件文件首次加入数据库时，执行add_attachment函数。函数接收的参数：附件ID。 add_category与create_category相同。 clean_post_cache清除日志缓存时，执行该动作函数。函数接收的参数：日志ID。参见clean_post_cache()。 create_category生成新类别时，执行该动作函数。函数接收的参数：类别ID。 delete_attachment从数据库和相应链接&#x2F;日志中删除某个类别后，执行该动作函数。函数接收的参数：类别ID。 delete_post将要删除某篇日志或页面时，执行该动作函数。函数接收的参数：日志ID或页面ID。 deleted_post删除某篇日志或页面后，执行该动作函数。函数接收的参数：日志ID或页面ID。 edit_attachment数据库中附件文件被更新时执行该动作函数。函数接收的参数：附件ID。 edit_category更新&#x2F;编辑某个类别时（包括添加&#x2F;删除日志或博客反向链接，或更新日志&#x2F;博客反向链接的类别），执行该动作函数。函数接收的参数：类别ID。 edit_post更新&#x2F;编辑某篇日志或页面时（包括添加&#x2F;更新评论，这会导致日志评论总数的更新），执行该动作函数。函数接收的参数：日志ID或页面ID。 pre_post_update更新日志或页面前执行该动作函数。函数接收的参数：日志ID。 private_to_publish当日志状态从private（私密）更改为published（公开）时，执行该动作函数。函数接收的参数：日志对象。（用以翻译日志状态的动作函数目前可用；参见wp_transition_post_status()）。 publish_page发表页面或编辑某个状态为“published”的页面时，执行该动作函数。函数接收的参数：页面ID。（警告：该动作函数不能在WordPress 2.3以及更高版本中运行；但动作函数’transition_post_status’能够运行。更新信息：publish_page动作函数可在WordPress 2.6及之后版本中运行。） publish_phone通过电子邮件添加新日志后，执行该动作函数。函数接收的参数：日志ID。 publish_post发表日志或编辑某个状态为“published”的日志时，执行该动作函数。函数接收的参数：日志ID。 save_post新建或更新一篇日志&#x2F;页面时，执行该动作函数。更新可以来自导入、日志&#x2F;页面编辑框、xmlrpc或邮件日志。函数接收的参数：日志ID。 更新信息存入数据库后执行该动作函数。 注意：日志ID可能会参照日志的修改版而不是最新发布版。wp_is_post_revision可获取日志最新版的ID。 wp_insert_post与save_post相同，更新信息存入数据库后执行该动作函数。 xmlrpc_public_post通过XMLRPC请求发表日志，或通过XMLRPC编辑某个状态为“published”的日志时，执行该动作函数。函数接收的参数：日志ID。 三、评论、Ping以及引用通告相关动作钩子函数comment_closed尝试显示评论输入框而日志却设置为不允许评论时，执行该动作函数。函数接收的参数：日志ID。 comment_id_not_found试图显示评论或评论输入框却未找到日志ID时，执行该动作函数。函数接收的参数：日志ID。 comment_flood_trigger调用wp_die以阻止接收评论前，若检测到评论数量异常增多，执行该动作函数。函数接收的参数：上一次评论发表时间，当前评论发表时间。 comment_on_draft日志为草稿状态却试图显示评论或评论输入框时，执行该动作函数。函数接收的参数：日志ID。 comment_post评论刚被存入数据库时，执行此动作函数。函数接收的参数：评论ID，评论审核状态（”spam”，0（表示未审核），1（表示已审核））。 edit_comment数据库中的评论被更新或编辑后，执行此动作函数。函数接收的参数：评论ID。 delete_comment评论即将被删除前，执行此动作函数。函数接收的参数：评论ID。 pingback_post日志新添加pingback后，执行此动作函数。函数接收的参数：评论ID。 pre_ping执行pingback前，执行此动作函数。函数接收的参数：将要处理的日志链接数组，以及日志的“pung”设置。 trackback_post日志新添加trackback后，执行此动作函数。函数接收的参数：评论ID。 wp_blacklist_check执行该动作函数以判断评论是否应被禁止。函数接收的参数：评论者的名称、电子邮件、URL、评论内容、IP地址、用户代理（浏览器）。该函数可执行wp_die以拒绝评论，也可以修改某个参数以使评论中可包含用户在WordPress选项中设置的黑名单关键词。 wp_set_comment_status评论状态发生改变时，执行此动作函数。函数接收的参数：评论ID，表明新状态的状态字符串（”delete”, “approve”, “spam”, “hold”）。","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"wordpress插件制作","slug":"wordpress插件制作","permalink":"https://baiyuan.wang/tags/wordpress%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/"}]},{"title":"安卓开发实现沉浸式状态栏","slug":"android-development-for-immersion-status-bar","date":"2015-05-27T03:39:55.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-development-for-immersion-status-bar.html","link":"","permalink":"https://baiyuan.wang/android-development-for-immersion-status-bar.html","excerpt":"","text":"自android4.4出来以后，沉浸式状态栏莫名地就火了起来，而最近，极客人的安卓手机无意中更新完几个常用软件，比如天天动听、wps office，发现这些软件大体上没什么改动，不过都陆续实现了沉浸式状态栏效果。极客人当初第一次见到这个名词时，以为这是个很高大上的技术，不知道你也是否也觉得。不过真正知晓以后所谓的、传说中的沉浸式状态栏是什么东西时，才发现真是“见面不如闻名”。 沉浸式状态栏 不管沉浸式是否高大上，但它就是很火，也成为刷机论坛各个刷机包炒作的看点。极客人在此还是向大家介绍怎么在安卓开发中实现安卓4.4及以上的手机应用实现沉浸式状态栏效果。 安卓开发实现沉浸式状态栏的代码相当简单。在activity代码中加入以下代码即可： 安卓开发实现沉浸式状态栏代码：if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) { Window window &#x3D; getWindow(); window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);} 代码解析：Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT这句是获取当前手机SDK版本号大于或等于Build.VERSION_CODES.KITKAT（安卓4.4，详情请看附录）时及即执行如下代码： Window window &#x3D; getWindow(); window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); Build.VERSION_CODES类：目前已知的SDK版本号的枚举类，这些值可以在SDK中找到，每次官方发布，这些值都是单调递增。 SDK版本号附录： 第一版： Build.VERSION_CODES.BASE 1.1版： Build.VERSION_CODES.BASE_1_1 1.5版： Build.VERSION_CODES.CUPCAKE 此版官方未发布： Build.VERSION_CODES.CUR_DEVELOPMENT 1.6版： Build.VERSION_CODES.DONUT 2.0版： Build.VERSION_CODES.ECLAIR 2.0.1版： Build.VERSION_CODES.ECLAIR_0_1 2.1版： Build.VERSION_CODES.ECLAIR_MR1 2.2版： Build.VERSION_CODES.FROYO 2.3版： Build.VERSION_CODES.GINGERBREAD 2.3.3版： Build.VERSION_CODES.GINGERBREAD_MR1 3.0版： Build.VERSION_CODES.HONEYCOMB 3.1版： Build.VERSION_CODES.HONEYCOMB_MR1 3.2版： Build.VERSION_CODES.HONEYCOMB_MR2 4.0版： Build.VERSION_CODES.ICE_CREAM_SANDWICH 4.0.3版： Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 4.1版： Build.VERSION_CODES.JELLY_BEAN 4.2版： Build.VERSION_CODES.JELLY_BEAN_MR1 4.3版：Build.VERSION_CODES.JELLY_BEAN_MR2+NEWLINE); 4.4版：Build.VERSION_CODES.KITKAT); 注意：①加入如下代码的界面，所有控件都会向上移，但是标题栏“actionbar”除外，极客人鼓捣了好久代码也没解决怎么把actionbar放在手机界面的顶部，所以建议大家将activity的主题theme设置为：“noactionbar”。实现方法如下： 在清单文件中activity标签中添加： android:theme&#x3D;”@android:style&#x2F;Theme.Holo.Light.NoActionBar” &#x2F;&#x2F;没有actionbar的主题还有很多这里是个例子 ②你可能需要自己写个标题栏在布局的顶部 如果你有更好的方法，欢迎留言共同学习！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"免插件百度链接提交-实时主动推送","slug":"initiative-to-push-plug-in-baidu-free-link-submit-real-time","date":"2015-05-25T13:44:12.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"initiative-to-push-plug-in-baidu-free-link-submit-real-time.html","link":"","permalink":"https://baiyuan.wang/initiative-to-push-plug-in-baidu-free-link-submit-real-time.html","excerpt":"","text":"对于广大站长来说，文章第一时间被百度收录，或自己的原创文章第一时间被百度认定为原创相当重要。不止一次文章被转载，但是因为别人的网站权重比自己高，百度收录速度或百度搜索文章标题的排名却不及转载网站的，这是一件十分让人苦恼的一件事。 百度站长平台消息：5月25日，百度站长工具发布消息： sitemap实时推送功能6月份开始逐步下线，我们推出了更加强大的链接提交主动推送功能做为替代。新的主动推送功能更加强大：提交数据方式更简单，返回码达意更清晰（可立即知晓数据提交是否成功），可以做到实时向百度推送新数据。 相关信息详见： http://zhanzhang.baidu.com/college/articleinfo?id=336 sitemap广大网站使用，搜索引擎通过爬行网站地图可以发现网站的新链接，并定期访问。但是搜索引擎的爬行频率有限且具有规律性，自己的原创文章并不能第一时间被百度等发现。 下面是百度官方给出三种提交链接的方式总结： 主动推送：百度推荐的最为快速的提交方式，建议将站点当天新链接立即通过此方式推送给百度获取最快收录。 sitemap：百度会周期性检查您提交的Sitemap，对链接进行处理，收录速度慢于主动推送。 手工提交：手动将链接提交给百度。 这里的手工提交不同于“链接提交”这里的手工提交是指对于百度站长验证站点提供的快速提交方式，支持批量多链接提交；而通常的“链接提交”是不需要你的网站是”百度站长平台验证站点“的，提交比较随意。 提交链接到百度 手动提交 实时提交 而百度站长平台新推出的“实时主动推送”为验证站点站长分配了一个token准入密钥，一般可认为只有站长或者知晓密钥的网站管理员才有权限提交，所以提交需谨慎，极客人建议大家用它提交一些质量比较高的文章，不要提交垃圾链接，同时需要提醒大家的是：目前这种方式提交的URL是有限额的，比如王柏元的博客每天只能用实时主动提交方式提交50条，大量自动提交垃圾文章可能导致失去提交权限！ 免插件百度链接提交-实时主动推送通过百度官方给出的PHP推送样例，极客人制作出了针对wordpress博客实时推送的PHP代码程序，将下列代码加入主题文件夹下functions.php最后一行“?&gt;”之前极客，本代码将在每次发布文章时执行将新文章链接实时主动推送给百度，同时在与代码所处文件同目录中生成日志文件“by_baiduSubmit.txt”。你可以查看日志文件了解是否推送成功。如果此程序出现错误或无法正确向百度实时提交新链接，欢迎在本页面反馈。 post_status != \"publish\"){ $url = get\\_permalink($post\\_ID); $ch = curl_init(); $options = array( CURLOPT_URL => $api, CURLOPT_POST => true, CURLOPT_RETURNTRANSFER => true, CURLOPT_POSTFIELDS => $url, CURLOPT_HTTPHEADER => array('Content-Type: text/plain') ); curl\\_setopt\\_array($ch, $options); $result = curl_exec($ch); $result = json_decode($result, true); $time = time(); $file = dirname(\\_\\_FILE\\_\\_).'/by_baiduSubmit.txt';//生成日志文件,与代码所处文件同目录 if(date('Y-m-d',filemtime($file)) != date('Y-m-d')){ $handle = fopen($file,\"w\"); }else{ $handle = fopen($file,\"a\"); } $resultMessage=\"\"; if($result\\['message'\\]){ $resultMessage= date('Y-m-d G:i:s',$time).\"\\\\n提交失败：\".$result\\['message'\\].\":\\\\n网址：\".$url.\"\\\\n\\\\n\"; } if($result\\['success'\\]){ $resultMessage= date('Y-m-d G:i:s',$time).\"\\\\n提交成功：\".\":\".$url.\"\\\\n\\\\n\"; } fwrite($handle,$resultMessage); fclose($handle); } } } ?>","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"SSD8_EX2【UDP vs TCP】","slug":"ssd8-ex2-udp-vs-tcp","date":"2015-05-22T11:59:03.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex2-udp-vs-tcp.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex2-udp-vs-tcp.html","excerpt":"","text":"这是SSD8练习的EX2，预计极客人将会写一个系列，此系列全为王柏元个人原创，更新频率会和NWPU数据库系统实验课2013级进度同步。点击标签或在本站搜索“SSD8”即可获取已更新的SSD8答案。上一练习：SSD8_EX1【Socket通信的Java实现代码】;如果你想继续跟踪SSD练习进展，建议订阅本站。 问题简述用Java写一个简单的基于C&#x2F;S（客户机&#x2F;服务器）模式的数据报（datagram）程序。客户端设置一个计时器，开始计时后，分别利用UDP和TCP协议向服务器发送一个字节的数据包，并等待服务器返回消息。计算平均往返时间,同时计算UDP传输过程中丢包数量并实现丢包重发。 一、用UDP实现丢包重发、丢包计数和传输计时1.UDP服务端程序UDPServer.javapackage cn.wangbaiyuan; import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;&#x2F;*** 基于UDP协议的服务器端，对来自客户端的数据包进行应答* @author 王柏元**&#x2F;public class UDPServer { &#x2F;** * 端口 *&#x2F; int port&#x3D;1888; DatagramSocket socket; public UDPServer() throws SocketException{ socket&#x3D;new DatagramSocket(port); &#x2F;&#x2F;服务端DatagramSocket System.out.println(“服务器启动。”); } public void service() throws IOException{ while(true){ DatagramPacket dp&#x3D;new DatagramPacket(new byte[512],512); socket.receive(dp); &#x2F;&#x2F;接收客户端信息 socket.send(dp); &#x2F;&#x2F;回复数据 } } public static void main(String[] args) throws SocketException, IOException { new UDPServer().service(); } } 2.UDP客户端程序UDPClient.javapackage cn.wangbaiyuan;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;import java.net.SocketAddress;import java.net.SocketException;import java.net.SocketTimeoutException;&#x2F;*** 基于UDP协议的客户端类,完成用UDP协议向服务器发送数据包* @author 王柏元*{@linkplain http://baiyuan.wang}*&#x2F;public class UDPClient { static int remotePort&#x3D;1888; &#x2F;&#x2F;服务器端口 static String remoteIp&#x3D;”10.22.56.186”; &#x2F;&#x2F;服务器IP static DatagramSocket socket;&#x2F;&#x2F;客户端DatagramSocket static int times&#x3D;1000; public UDPClient() throws SocketException{ } public static void main(String[] args) throws InterruptedException, SocketException { SocketAddress socketAddres&#x3D;new InetSocketAddress(remoteIp,remotePort); DatagramPacket inputdp&#x3D;new DatagramPacket(new byte[512],512); String s&#x3D;”d”; int timeout&#x3D;1; long toalTime&#x3D;0; long startTime &#x3D; 0;int failTimes&#x3D;0; socket&#x3D;new DatagramSocket(); socket.setSoTimeout(timeout); byte[] info&#x3D;s.getBytes(); DatagramPacket dp&#x3D;new DatagramPacket(info,info.length,socketAddres); for(int i&#x3D;1;i&lt;&#x3D;times;i++){ Boolean received&#x3D;false; while(received&#x3D;&#x3D;false){ try { startTime&#x3D;System.currentTimeMillis(); socket.send(dp); socket.receive(inputdp); long endTime&#x3D;System.currentTimeMillis(); toalTime+&#x3D;(endTime-startTime); received&#x3D;true; System.out.println(“第”+i+”次发送并接受回复成功!”); } catch (SocketTimeoutException e) { failTimes++; received&#x3D;false; System.out.println(“第”+i+”次接收成功应答超时，尝试重发”);&#x2F;&#x2F; TODO Auto-generated catch block } catch (IOException e) { &#x2F;&#x2F; TODO Auto-generated catch block System.out.println(“第”+i+”次接收成功应答失败，尝试重发”); failTimes++; } } } System.out.println(“失败次数：”+failTimes); float averTime&#x3D;(float)toalTime&#x2F;1000; System.out.println(“平均耗时：”+averTime+”豪秒”); } } 二、用TCP实现传输计时1.TCP服务端程序TcpServer.javapackage cn.wangbaiyuan; import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket; &#x2F;*** 基于TCP协议的服务器端，对来自客户端的数据包进行应答* @author 王柏元**&#x2F; public class TcpServer { ServerSocket serverSocket; private final int PORT &#x3D; 12340; &#x2F;&#x2F; 端口&#x2F;*** 新建EchoServer类时建立一个ServerSocket* @throws IOException*&#x2F; public TcpServer() throws IOException { serverSocket &#x3D; new ServerSocket(PORT); &#x2F;&#x2F; 创建服务器端套接字 System.out.println(“服务器启动。”); }&#x2F;*** 启动服务器socket服务，监听客户端消息*&#x2F; public void servic() { Socket socket &#x3D; null; while (true) { try { socket &#x3D; serverSocket.accept(); &#x2F;&#x2F; 等待并取出用户连接，并创建套接字 &#x2F;&#x2F; 输入流，读取客户端信息 BufferedReader br &#x3D; new BufferedReader(new InputStreamReader( socket.getInputStream(), “UTF-8”));&#x2F;&#x2F; 涉及到安卓客户端，为留设置编码 &#x2F;&#x2F; 输出流，向客户端写信息 BufferedWriter bw &#x3D; new BufferedWriter(new OutputStreamWriter( socket.getOutputStream(), “UTF-8”)); PrintWriter pw &#x3D; new PrintWriter(bw, true); &#x2F;&#x2F; 装饰输出流，true,每写一行就刷新输出缓冲区，不用flush String info &#x3D; null; &#x2F;&#x2F; 接收用户输入的信息 while ((info &#x3D; br.readLine()) !&#x3D; null) { pw.println( info); &#x2F;&#x2F; 向客户端返回用户发送的消息，println输出完后会自动刷新缓冲区 } } &#x2F;&#x2F; 如果客户端断开连接，则应捕获该异常，但不应中断整个while循环，使得服务器能继续与其他客户端通信 catch (IOException e) { e.printStackTrace(); } finally { if (null !&#x3D; socket) { try { socket.close(); &#x2F;&#x2F; 断开连接 } catch (IOException e) { e.printStackTrace(); } } } } }&#x2F;*** EchoServer main静态类，启动时开启服务器端服务* @param args* @throws IOException*&#x2F; public static void main(String[] args) throws IOException { new TcpServer().servic(); &#x2F;&#x2F; 启动服务 }} 2.基于TCP协议的客户端类package cn.wangbaiyuan; import java.io.;import java.net.;import java.util.Scanner; &#x2F;** * socket TCP通信客户端类 * * @author 王柏元 * *&#x2F; public class TcpClient { /\\*\\* \\* PORT 一个初始化端口 */ static int PORT = 12340; // 连接端口 /\\*\\* \\* HOST一个初始化主机名 */ static String HOST = &quot;10.22.56.186&quot;; // 连接地址 /\\*\\* \\* socket 客户端socket \\* */ static Socket socket; public TcpClient() throws UnknownHostException, IOException &#123; &#125; /\\*\\* \\* 实现发送消息 */ public static void main(String\\[\\] args) throws UnknownHostException, IOException &#123; BufferedReader strin = new BufferedReader(new InputStreamReader( System.in)); System.out.println(&quot;请输入连接地址：&quot;); HOST = strin.readLine(); System.out.println(&quot;请输入连接端口：&quot;); PORT = Integer.parseInt(strin.readLine()); long toalTime=0; long startTime = 0; for(int i=1;i&lt;=1000;i++)&#123; socket = new Socket(HOST, PORT); // 创建客户端套接字 System.out.print(&quot;第&quot;+i+&quot;次建立链接&quot;); try &#123; // 客户端输出流，向服务器发消息 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream())); // 客户端输入流，接收服务器消息 BufferedReader br = new BufferedReader(new InputStreamReader( socket.getInputStream())); PrintWriter pw = new PrintWriter(bw, true); // 装饰输出流，及时刷新 String msg=&quot;a&quot;; startTime=System.currentTimeMillis(); pw.println(msg); // 发送给服务器端 System.out.print(&quot;，第&quot;+i+&quot;次接收到&quot;+br.readLine()); // 输出服务器返回的消息 long endTime=System.currentTimeMillis(); toalTime+=(endTime-startTime); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socket) &#123; try &#123; socket.close();// 断开连接 System.out.println(&quot;，链接成功断开&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; float averTime=(float)toalTime/1000; System.out.println(&quot;平均耗时：&quot;+averTime+&quot;豪秒&quot;); &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"}]},{"title":"用Navicat制作ER图及与SQL互相转化","slug":"sql-and-use-navicat-to-make-er-diagram-and-interactive","date":"2015-05-21T03:45:09.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"sql-and-use-navicat-to-make-er-diagram-and-interactive.html","link":"","permalink":"https://baiyuan.wang/sql-and-use-navicat-to-make-er-diagram-and-interactive.html","excerpt":"","text":"Navicat极客人在数据库学习过程中用过的个人认为最优秀的一款数据库连接、设计、编辑查询软件。它不仅是极客人用过的数据库软件中界面最美观的一款，也是功能最强大、操作最简单的一款，Navicat分别有for MySQL、for MariaDB、for SQL Server、for SQLite、for Oracle 和 for PostgreSQL等多个单一数据库版本，同时也有Navicat Premium这个综合版本，Navicat Premium 是一个可多重连接的数据库管理工具，它可让你以单一程序同时连接到 MySQL、MariaDB、SQL Server、SQLite、Oracle 和 PostgreSQL 数据库，支持大部分在现今数据库管理系统中使用的功能，包括存储过程、事件、触发器、函数、视图等，同时可以在这款软件中为数据库添加用户、设置权限。 极客人使用Navicat除了以上常见功能外，还会使用navicat进行数据库数据备份、同步，将王柏元的博客上虚拟机数据库的数据备份、同步到本地，或者用navicat进行网站搬家。本人主要介绍怎样用Navicat制作ER图及与SQL互相转化：将数据库表导出成ER图和将ER图导出为SQL语句（这个功能也是极客人无意发现的，刚刚学习，欢迎共同交流！）。 一、用Navicat制作ER图 分别打开navicat的“模型”——“新建模型” navicat制作ER图 二、将ER图导出为SQL语句如图 Navicat根据ER图导出为SQL 打开工具——导出SQL 这样只要设计出ER图，所有的建表语句，包括主键、外键关系，Navicat将自动为我们生成。 三、将现成的数据库转换为ER图选中已连接的数据库中 数据表——右键，选择“逆向数据库到模型”，即可根据现成的数据库生成ER图模型。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"软件推荐","slug":"软件推荐","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"Navicat","slug":"Navicat","permalink":"https://baiyuan.wang/tags/Navicat/"}]},{"title":"被.ytlqpo.com恶意镜像的解决、反制措施","slug":"ytlqpo-com-a-malicious-image-resolution-countermeasures","date":"2015-05-19T05:22:16.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"ytlqpo-com-a-malicious-image-resolution-countermeasures.html","link":"","permalink":"https://baiyuan.wang/ytlqpo-com-a-malicious-image-resolution-countermeasures.html","excerpt":"","text":"前天在百度搜索王柏元的博客网站关键词时，猛地在百度结果的第一页中发现了一个标题、简介和我完全一样的网站，不看不知道，这个网站还不是传统意义上的抄袭、盗链，不仅仅把我的网站全部照搬，而且把网页里所有的链接都置换成那个镜像网站地址的。 我这才知道：我的网站被人家恶意镜像了。 和一般的镜像不太一样，这个镜像网站不仅仅是针对我一个网站，而是自动镜像。主要表现为： ①我的网址：http://baiyuan.wang;镜像网址就是：wangbaiyuan.ytlqpo.com。另外一个网站网址：http://weixin.baiyuan.wang,镜像网址就是weixinwangbaiyuan.ytlqpo.com经过本人测试：把你的网站网址去掉主机记录和顶级域名，加上.ytlqpo.com，就知道你自己有没有被镜像！ ②为镜像网站里所有链接添加镜像，比如我的网站里有个友情链接：http://www.zhiyanblog.com,这个友情链接就会置换成：zhiyanblog.ytlqpo.com. 一、经过本人测试中招的大网站有：360. ytlqpo.com 镜像360网站 sogou. ytlqpo.com 镜像搜狗搜索 qq. ytlqpo.com 镜像qq官网 net. ytlqpo.com 镜像万网官网 haosou. ytlqpo.com 镜像好搜网站 号称安全神站的360也未能幸免 不过恭喜百度搜索主页神奇地幸免了 二、测试的站长朋友网站被镜像的有：zhiyan blog.ytl qpo.com 镜像http://www.zhiyanblog.com nai ba.ytlqpo.com 镜像naiba.im wangb aiyuan .ytlqpo.com 镜像http://baiyuan.wang 三、恶意镜像很危险恶意镜像由于照搬了源站的所有内容，如果你的网站权重不够高就苦逼了，百度如果分不清哪个源站，难保把你当抄袭，如果你的权重干不过人家的话。不管你的权重高不高，被恶意镜像的网站无疑会削弱你的权重，因为百度蜘蛛发现了大量和你网站一模一样的内容。虽然网上有很多恶意镜像的解决办法，但是我感觉我这次遇到的情况和网上的都不太一样，使用网上许多方法都不奏效。 四、解决与反制措施在尝试多种方法无效后，我想到了一个权宜之计：禁止恶意镜像网站的访问IP，之所以说是权宜之计，因为难保它的IP会变，还有这个IP不是镜像网址的解析IP 因为多次尝试解决问题过程中，我发现这个恶意镜像的网站的原理大概是：别人访问abc.ytlqpo.com 的时候，它会访问一下(www)abc.com(cn\\net\\cc\\xyz\\wang),然后把访问的结果修改一下链接返回给你。所以，它必须有一个访问源站的过程。于是乎解决方案就是禁止这个访问IP. 在搜寻海量的网站日志没有确认这个IP后，我写了一个PHP文件来截获这个访问IP。 1.截获IP 将上述文件命名为“ip.php”放在网站根目录,然后我通过镜像网站网址访问wangbaiyuan.ytlqpo.com&#x2F;ip.php，然后在上述PHP程序生成的ip.txt中获取了这个IP： 104.194.16.230 （美国） 2.屏蔽IP在htaccess中添加下述代码： Deny from 104.194.16.230 对于htaccess屏蔽IP的方法，我的之前一篇文章有详细介绍：htaccess屏蔽ip访问。 当你再次用镜像网址访问你的网站的时候就会报403错误了，现在百度即使收录了这个网址对你的网站也不会产生任何影响. 3.反制措施为了给这个镜像网站小小的“反击”，我决定把这个403错误页面设置为其他网站网址，实现方法是在屏蔽IP的htaccess代码中添加： ErrorDocument 403 http://news.baidu.com/ 这样你访问你的镜像网址时，会发现它镜像的是其实百度新闻。（不知道百度蜘蛛发现一个网站在完全抄袭自己家的东西会是什么感觉） 演示效果：wangb aiyuan .ytlqpo.com(为了不给这个网址做传递权重和宣传，防止产生链接效果，请自行复制此链接去掉空格在浏览器中打开) 当然你写可以根据个人需求让你的镜像网址转向镜像其他的网站，比如： 借助它Fanqiang！","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"},{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"哲学到编程：思想的实例化","slug":"philosophy-of-programming-materialized","date":"2015-05-18T14:16:59.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"philosophy-of-programming-materialized.html","link":"","permalink":"https://baiyuan.wang/philosophy-of-programming-materialized.html","excerpt":"","text":"万古长江水，千年儒释道。历史的长流中，芸芸众生，参差不齐，但总是能够总结出一个“生旦净末丑”来。儒、释、道，五千年的中华文化，却总是围绕着这三种主流思想交相演绎。千年间，豪士俊杰，文人墨客，辈出的栋梁不可谓不多。但是细细想来，人们的思想中总能找到前辈哲人的思想。 我们从小就学习前人的思想，读书看报、遍历典籍，每一个人总是从读书的过程中汲取前人思想，然后以汲取的思想来指导如何为人处世。哲人常常天马行空，虚无缥缈，所以哲人的思想具有跨时代性也不必大惊小怪：“可持续发展”是今天的政策口号，但是千年前孟子与梁惠王论政时就说：“不违农时，谷不可胜食也；数罟不入洿池，鱼鳖不可胜食也；斧斤以时入山林，木材不可胜用也。谷与鱼鳖不可胜食，木材不可胜用，是使民养生丧死无撼也。王道之始也。”；现在医保提出“老有所依”，但是《礼记》早就说“老有所终,壮有所用,幼有所长,鳏寡孤独废疾者,皆有所养”。如此看来，我们发现我们似乎很不堪，看似新鲜的一些词其实深深植根于前人的智慧。 以编程的角度看，我们在应用程序里引用的类、方法函数、服务协议，都是前人写好的，写在windows操作系统里，写在安卓SDK里，不管你的程序写的多么牛逼，你都是在调用前人的智慧。难道我们程序猿也是那么的不堪？编程里，调用类及其方法，新建一个实实在在的对象，称为类的“实例化”过程。 同理，学习前人哲思，身体力行人家的思想，何尝不是“实例化”的过程。前人把基础的哲学思想总结出来，后人能自己体悟出来便是自己的，进而组合各种前人智慧并运用就能超越前人了 。创建出一个基于底层代码中基本“类”的一些“对象”为自己所用，组合各种“控件”、事件，于是就创造出多姿多彩的应用程序。操作系统是伟大的，但是操作系统的伟大里，有多少是应用程序强大的功劳？我们说一个哲人伟大，不就是因为他的思想影响了后人、培养出一群伟大的人吗？我们每一个人都是前人思想的实例化对象，我们的实例化成就了自己，同时也成就了先人，践行思想的过程并非一无是处。思想因实例化而伟大。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"闲言碎语","slug":"闲言碎语","permalink":"https://baiyuan.wang/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"},{"name":"生活哲学","slug":"生活哲学","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"}]},{"title":"JAVA（安卓）接入图灵机器人","slug":"java-android-access-turing-robot","date":"2015-05-18T00:57:27.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"java-android-access-turing-robot.html","link":"","permalink":"https://baiyuan.wang/java-android-access-turing-robot.html","excerpt":"","text":"图灵机器人是极客人在一个公众号使用过程中发现的，它是一款人工智能的免费开放的API，可以对用户输入的问题（天气、问候、查火车票、看新闻、讲笑话等等）进行人性化的回复，然后我将其引入到了自己的微信公众号。在学习安卓开发过程中，我就想到将其加到java中，下面是我实现的无界面控制台代码。如果你对图灵机器人感兴趣，不妨关注我的公众号。 JAVA（安卓）接入图灵机器人代码import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLEncoder;import org.json.JSONException;&#x2F;&#x2F;引入json.jarimport org.json.JSONObject;public class TulingRobots {private static String ApiKey&#x3D;”yourApiKey”;public static void main(String[] args) throws IOException { BufferedReader reader&#x3D; new BufferedReader(new InputStreamReader(System.in)); String yourQuestion; while((yourQuestion&#x3D;reader.readLine())!&#x3D;”退出”||(yourQuestion!&#x3D; null)){ &#x2F;&#x2F;System.out.println(yourQuestion); String Info&#x3D;URLEncoder.encode(yourQuestion, “utf-8”); String url_path &#x3D; “http://www.tuling123.com/openapi/api?key=&quot;+ApiKey+&quot;&amp;info=&quot;+Info; &#x2F;&#x2F;System.out.println(url_path); URL getUrl &#x3D; new URL(url_path); HttpURLConnection connection &#x3D; (HttpURLConnection) getUrl.openConnection(); connection.connect(); BufferedReader replyReader &#x3D; new BufferedReader(new InputStreamReader(connection.getInputStream(), “utf-8”));&#x2F;&#x2F;约定输入流的编码 String reply&#x3D;replyReader.readLine(); try { JSONObject Json&#x3D;new JSONObject(reply); reply&#x3D;Json.getString(“text”);&#x2F;&#x2F;获取“text”的键值 } catch (JSONException e) { &#x2F;&#x2F; TODO Auto-generated catch block e.printStackTrace(); } System.out.println(reply);&#x2F;&#x2F;打印图灵机器人的回复 &#125; }} 上面的代码需要引入json.jar包，因为图灵机器人返回的是个json格式字符串，需要用户自己做json解析。对于json解析的方法，我的前面一片转载文章又详细介绍：解析json数据，你在申请图灵机器人的API后，将 private static String ApiKey&#x3D;”yourApiKey”; 这句代码中的”yourapikey”换成你自己的。 测试效果： 图灵机器人引入java","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"算法语言","slug":"技术/算法语言","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/"},{"name":"软件开发","slug":"技术/算法语言/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"json","slug":"json","permalink":"https://baiyuan.wang/tags/json/"},{"name":"人工智能","slug":"人工智能","permalink":"https://baiyuan.wang/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"SSD8_EX1【socket通信的java实现代码】","slug":"ssd8-ex1-socket-communication-java-code","date":"2015-05-17T03:42:37.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd8-ex1-socket-communication-java-code.html","link":"","permalink":"https://baiyuan.wang/ssd8-ex1-socket-communication-java-code.html","excerpt":"","text":"问题概述实现EchoServer和EchoClient类，其中EchoServer监听某一端口号（启动时，通过参数传入），等待客户端访问；EchoClient根据启动时传入的服务器地址（IP地址或域名）和端口号连接该服务；连接后，读取用户在命令行下的输入，将该输入传输给EchoServer；EchoServer接收后，向EchoClient返回_“EchoServer received: ” + 用户输入信息_；EchoClient接收到返回信息后输出到命令行，并继续等待用户输入 1、客户端EchoClient.java代码package cn.wangbaiyuan;import java.io.;import java.net.;import java.util.Scanner; &#x2F;** * socket通信客户端类 * * @author 王柏元 * *&#x2F; public class EchoClient { /\\*\\* \\* PORT 一个初始化端口 */ static int PORT = 12340; // 连接端口 /\\*\\* \\* HOST一个初始化主机名 */ static String HOST = &quot;192.168.4.21&quot;; // 连接地址 /\\*\\* \\* socket 客户端socket \\* */ Socket socket; public EchoClient() throws UnknownHostException, IOException &#123; socket = new Socket(HOST, PORT); // 创建客户端套接字 &#125; /\\*\\* \\* 实现发送消息 */ public void send() &#123; try &#123; // 客户端输出流，向服务器发消息 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream())); // 客户端输入流，接收服务器消息 BufferedReader br = new BufferedReader(new InputStreamReader( socket.getInputStream())); PrintWriter pw = new PrintWriter(bw, true); // 装饰输出流，及时刷新 Scanner in = new Scanner(System.in); // 接受用户信息 String msg = null; while ((msg = in.next()) != null) &#123; pw.println(msg); // 发送给服务器端 System.out.println(br.readLine()); // 输出服务器返回的消息 if (msg.equals(&quot;quit&quot;)) &#123; break; // 退出 &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socket) &#123; try &#123; socket.close(); // 断开连接 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String\\[\\] args) throws UnknownHostException, IOException &#123; BufferedReader strin = new BufferedReader(new InputStreamReader( System.in)); System.out.println(&quot;请输入连接地址：&quot;); HOST = strin.readLine(); System.out.println(&quot;请输入连接端口：&quot;); PORT = Integer.parseInt(strin.readLine()); new EchoClient().send(); &#125; } 2、单线程服务器端EchoServer.java代码package cn.wangbaiyuan; import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket; &#x2F;** * @author 王柏元 *socket通信服务器类 *&#x2F; public class EchoServer { &#x2F;** * *&#x2F; ServerSocket serverSocket; private final int PORT = 12340; // 端口 &#x2F;** * 新建EchoServer类时建立一个ServerSocket * @throws IOException *&#x2F; public EchoServer() throws IOException { serverSocket &#x3D; new ServerSocket(PORT); &#x2F;&#x2F; 创建服务器端套接字 System.out.println(“服务器启动。”); }&#x2F;** * 启动服务器socket服务，监听客户端消息 *&#x2F; public void servic() &#123; Socket socket = null; while (true) &#123; try &#123; socket = serverSocket.accept(); // 等待并取出用户连接，并创建套接字 System.out.println(&quot;新连接，连接地址：&quot; + socket.getInetAddress() + &quot;：&quot; \\+ socket.getPort()); // 客户端信息 // 输入流，读取客户端信息 BufferedReader br = new BufferedReader(new InputStreamReader( socket.getInputStream(), &quot;UTF-8&quot;));// 涉及到安卓客户端，为留设置编码 // 输出流，向客户端写信息 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream(), &quot;UTF-8&quot;)); PrintWriter pw = new PrintWriter(bw, true); // 装饰输出流，true,每写一行就刷新输出缓冲区，不用flush String info = null; // 接收用户输入的信息 while ((info = br.readLine()) != null) &#123; System.out.println(info); // 输出用户发送的消息 pw.println(&quot;you said:&quot; + info); // 向客户端返回用户发送的消息，println输出完后会自动刷新缓冲区 if (info.equals(&quot;quit&quot;)) &#123; // 如果用户输入“quit”就退出 break; &#125; &#125; &#125; // 如果客户端断开连接，则应捕获该异常，但不应中断整个while循环，使得服务器能继续与其他客户端通信 catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socket) &#123; try &#123; socket.close(); // 断开连接 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#x2F;** * EchoServer main静态类，启动时开启服务器端服务 * @param args * @throws IOException *&#x2F; public static void main(String[] args) throws IOException { new EchoServer().servic(); &#x2F;&#x2F; 启动服务 }} 3、多线程服务器端代码ThreadEchoServer.java:package cn.wangbaiyuan; import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket; public class ThreadEchoServer { ServerSocket serverSocket; private final int PORT&#x3D;1245; &#x2F;&#x2F;端口 public ThreadEchoServer() throws IOException&#123; serverSocket=new ServerSocket(PORT); //创建服务器端套接字 System.out.println(&quot;服务器启动。&quot;); &#125; //servic()方法 public void service()&#123; while(true)&#123; Socket socket=null; try &#123; socket=serverSocket.accept(); Thread work=new Thread(new Handler(socket)); //为客户连接创建工作线程 work.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String\\[\\] args) throws IOException &#123; new ThreadEchoServer().service(); //启动服务 &#125; &#125; Handler.javapackage cn.wangbaiyuan; import java.io.*;import java.net.Socket; public class Handler implements Runnable { &#x2F;&#x2F; 负责与单个客户通信的线程 private Socket socket; BufferedReader br; BufferedWriter bw; PrintWriter pw; public Handler(Socket socket) &#123; this.socket = socket; &#125; public void initStream() throws IOException &#123; // 初始化输入输出流对象方法 br = new BufferedReader(new InputStreamReader(socket.getInputStream(),&quot;UTF-8&quot;)); bw = new BufferedWriter( new OutputStreamWriter(socket.getOutputStream(),&quot;UTF-8&quot;)); pw = new PrintWriter(bw, true); System.out.println(&quot;新连接，连接地址：&quot;+socket.getInetAddress()+&quot;：&quot;+socket.getPort()); &#125; public void run() &#123; // 执行的内容 try &#123; initStream(); // 初始化输入输出流对象 String info = null; while (null != (info = br.readLine())) &#123; System.out.println(socket.getInetAddress()+&quot;say：&quot;+info); pw.println(&quot;you said:&quot; + info); // 返回用户发送的消息 if (info.equals(&quot;quit&quot;)) &#123; System.out.println(socket.getInetAddress()+&quot;已退出：&quot;+info);// 如果用户输入“quit”就退出 pw.println(&quot;你已退出&quot;); break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socket) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/计算机技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"}]},{"title":"notepad++的高级功能：编译java、C++","slug":"notepad-advanced-features-compile-java-c","date":"2015-05-17T02:39:42.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"notepad-advanced-features-compile-java-c.html","link":"","permalink":"https://baiyuan.wang/notepad-advanced-features-compile-java-c.html","excerpt":"","text":"Notepad++是极客人非常喜欢的一款电脑客户端的编辑器，它的安装包只有7.9M，但是功能却十分强大，界面简单、启动速度快，用它替代系统的“记事本”是个不错的选择。极客人常用的功能有查找替换（支持正则表达式）、文件转编码，同时它的代码高亮、代码折叠也十分实用，还可以根据你自己的爱好改变代码高亮的风格主题。同时它具有插件扩展功能，安装插件使它具有无限可能。 Notepad++支持的文件类型有： C、C++、Java、C#、XML、HTML、PHP、CSS、makefile、ASCII艺术(.nfo)、doxygen、ini文件、批处理文件、Javascript、ASP、VB、VBS、SQL、Objective-C 、Pascal、Perl、Python、LuaTeX、TCL汇编言、Ruby、Lisp、Scheme、Properties、DiffSmalltalk。 除了强大的编辑能力外，其实我们也可以直接在Notepad++里直接编译运行java、C++代码，这样我们不至于写一个简单的“hello world”也要新建一个eclipse项目，它可以直接编译单个的java文件，和C一样；编辑html的时候也不用打开启动速度极慢的dreamweaver了。虽然它没有专业的编程工那样具有强大的调试功能，但作为轻量级的编程工具还是十分不错的。 1.下载安装NppExec插件分别打开插件——pluginManeger菜单，点击“Show Plugin Manager”打开Notepad++的插件管理： 在available选项卡中找到“NppExec”选择安装，重启notepad++。 2.按F6编译并运行java文件notepad++本身并不具备编译功能，而是调用已注册为系统环境变量的JDK工具的编译功能，其实eclipse这些软件也是这样，它们只是编辑器。编译的快捷键是F6 第一次编译的时候，我们需要设置一下编译命令，下面是无参数、无jar引用的java文件编译命令 javac “$(FULL_CURRENT_PATH)”java -cp $(CURRENT_DIRECTORY $(NAME_PART) 然后保存为：“java编译”，以后直接选择它作为模板编译。 3、带参数、带jar引用的java文件编译命令不知道细心的朋友有没有发现，上面的编译命令和命令指示符里编译运行的命令是一样的，所有懂得命令指示符编译的朋友可以自己修改编译命令，编译C++的原理也是一样。 下面是带参数、带jar引用的java文件编译命令： javac “$(FULL_CURRENT_PATH)”java -cp “$(CURRENT_DIRECTORY)”;”$(CURRENT_DIRECTORY)&#x2F;json.jar” $(NAME_PART) 在上面的编译命令中，我在-cpp(classpath)参数”$(CURRENT_DIRECTORY)”后面添加了“;$(CURRENT_DIRECTORY)&#x2F;json.jar”，这表示我引用了当前文件夹下“json.jar”这个外部jar引用. 实例展示： 文件路径关系：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"软件推荐","slug":"软件推荐","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"}]},{"title":"练“气”还是练“剑”","slug":"practicing-spirit-is-sword","date":"2015-05-12T11:09:39.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"practicing-spirit-is-sword.html","link":"","permalink":"https://baiyuan.wang/practicing-spirit-is-sword.html","excerpt":"","text":"昨天晚上数据库系统实验，老师说的一段话令我的心里泛起了涟漪，话的原意大概是这样： “有些大一大二同学反映自己的编码能力不行，说某某编码很好。”她接着说:”大家注意了，你们将来不是写代码的，如果你们是写代码的，岂不是抢了高职学生的饭碗，你们不是码农。你们将来是做软件架构师，分析师，设计师。如果以后你们说某某某编码能力很强，不是夸人家，就是说某某是码农（差不多这个意思），你们大一大二只要熟练掌握一门编程语言就行了”。 可能学校的意思的，基础牢固，然后自顶向下，学些高屋建瓴的东西（比如概论这些科目）。 这让我想到了笑傲江湖，气宗和剑宗， 是以气带剑，还是以剑练气。 剑宗功夫易于速成，见效极快。大家都练10年，定是剑宗占上风；各练20年，那是各擅胜场，难分上下；到得30年时，练剑宗功夫的便再也不能望气宗之项背了。就像现在把自己所学，拼凑代码很快能写个小app，但是却没有学会软件工程的思想。如果一心学理论，又不甘寂寞，心里还嘀咕”学了这么久还什么也不会”。如果两难择其中，气剑双修， 岳不群断言，“如果两者都为主，那便是说两者都不是主。”又想到前段时间，北大学生退学读技校，就可以认为是”背叛气宗，皈依剑宗”了。觉得岳不群还是很厉害的，只觉得《笑傲江湖》，我们并未读懂:生活中还是到处都是哲学的。","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"},{"name":"极客视点","slug":"岁月/极客视点","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"闲言碎语","slug":"闲言碎语","permalink":"https://baiyuan.wang/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"},{"name":"生活哲学","slug":"生活哲学","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"}]},{"title":"SSD7_EX3【高级SQL】","slug":"ssd7-ex3-advanced-sql","date":"2015-05-11T11:31:05.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd7-ex3-advanced-sql.html","link":"","permalink":"https://baiyuan.wang/ssd7-ex3-advanced-sql.html","excerpt":"","text":"这是SSD7练习的EX3，预计极客人将会写一个系列，更新频率会和NWPU数据库系统实验课2013级进度同步。点击标签或在本站搜索“SSD7”即可获取已更新的SSD7答案。上一练习：SSD7_EX2【SQL】 原题摘要:此练习以图书馆系统library schema为案例，案例包含了图书馆书籍信息、图书馆成员信息，图书馆借阅信息（某本书被某个读者借阅几次），提供书籍的出版社信息，出版社订单信息。为了与其他练习作区分，本次练习的每个关系名字最后一个字符为阿拉伯数字‘4’。 使用CREATE TABLE and INSERT statements提供的SQL语句创建你的所有关系，要求在一个空的数据库中运行提供的SQL语句创建数据库。 英文：For this exercise, we will use the library schema. It includes information about book titles in the library, information about library members, about the number of times the books were read by members, about the suppliers who supply books to the library, and about orders placed with the suppliers. To distinguish the table names used in this exercise from the table names in other exercise, each table name in this exercise ends with the character ‘4’. Point of clarification: The ReceivedDate column refers to the date when the Order was received by the system (i.e., recorded in the database). It does not refer to the date a consumer received the items ordered by him. 作业还是自己做的好，以下是我做的结果，作交流学习之用，不要盲目抄袭，东西学会了才是自己的！答案可能有纰漏，欢迎指正，水平有限，仅供参考： 1.运行提供的SQL语句，完成关系的创建和部分数据插入。 2.书写SQL语句，删除所有关系中的数据，将你的答案书写在一个名为delete_rows.sql的文件中。 delete_rows.sqlUSE libsupply;DELETE FROM book4;DELETE FROM title4;DELETE FROM member4; 3.按照要求书写SQL语句，并运行它们，完成对数据库的修改和完善。 alter_tables.sql：alter table libsupply.title4add constraint ak_isbn alternate KEYS title4(isbn);alter table libsupply.title4add constraint ak_isbn alternate KEYS title4(name); alter table libsupply.MEMBER4add Join_date DATE;alter table libsupply.MEMBER4add Gender CHAR(1);ALTER TABLE libsupply.book4add CONSTRAINT fk_callnumber FOREIGN KEY(callnumber) REFERENCES libsupply.title4(callnumber);ALTER TABLE libsupply.book4add CONSTRAINT fk_borrowerid FOREIGN KEY(borrowerid) REFERENCES libsupply.member4(libid);CREATE TABLE PURCHASE_ORDER4(PoNum char(8),Qty INT,OrderDate DATE,DueDate DATE,ReceivedDate DATE,PRIMARY KEY(PoNum));CREATE TABLE SUPPLIER4(Supplier_Id char(8),Name varchar(30),Address VARCHAR(100),PRIMARY KEY(Supplier_Id)); CREATE TABLE READ_BY4(callnumber char(8) NOT NULL,LibId char(6) NOT NULL,TimesRead INT,Primary KEY(CallNumber, LibId),FOREIGN KEY(CallNumber) REFERENCES libsupply.title4(CallNumber),FOREIGN KEY(LibId) REFERENCES libsupply.MEMBER4(LibId)); CREATE TABLE ORDERED4(CallNumber char(8) NOT NULL,PoNum char(8),Supplier_Id char(8),PRIMARY KEY(CallNumber, PoNum, Supplier_Id),FOREIGN KEY(CallNumber) REFERENCES libsupply.TITLE4(CallNumber),FOREIGN KEY(PoNum) REFERENCES libsupply.PURCHASE_ORDER4(PoNum),FOREIGN KEY(Supplier_Id) REFERENCES libsupply.SUPPLIER4(Supplier_Id));ALTER TABLE READ_BY4add CONSTRAINT CK_TR CHECK(TimesRead&gt;&#x3D;0); 2）运行INSERT SQL statements提供的SQL语句插入数据 3）按照以下查询要求书写SQL语句，将你的答案书写在一个名为queries.sql的文件中。 （1）列出符合以下要求的所有图书馆成员的ID，第一名字和Join_date;ID以字符“A%B”或者“A&amp;B”开始。●不晚于Nov. 30, 1997加入图书馆 SELECT libid,fname,Join_dateFROM libsupply.member4WHERE (libid LIKE ‘A&#x2F;%B%’ ESCAPE ‘&#x2F;‘ or libid LIKE ‘A&amp;B%’)AND JOIN_date&lt;’1997-11-30’; （2）列出符合以下要求的所有书的名字、ISBN、CallNumber。●由两个或两个以上的出版社提供。 ●所有的订单总量在10本以上。 ●按照订单总量递减的顺序排列结果。 USE libsupply; SELECT t4.name,t4.isbn,t4.callnumberFROM title4 t4,ordered4 o4,purchase_order4 po4,supplier4 s4WHERE t4.callnumber &#x3D; o4.callnumberAND o4.ponum &#x3D; po4.ponumAND o4.supplier_id &#x3D; s4.supplier_idGROUP BY t4.callnumberHAVING COUNT(O4.SUPPLIER_ID)&gt;&#x3D;2 and SUM(po4.Qty)&gt;&#x3D;10ORDER BY o4.supplier_id; &#x2F;* (3）列出符合以下要求的所有图书馆成员ID和第一名字。●借阅书的次数小于图书馆所有书借阅次数综合的5%。 ●按照借阅次数的递增顺序排列结果。 *&#x2F; SELECT m4.libid,m4.fnamefrom member4 m4,read_by4 rb4WHERE m4.libid&#x3D;rb4.libidGROUP BY rb4.libIdHAVING SUM(rb4.TimesRead)&lt;(SELECT SUM(TimesRead)from read_by4)*0.05ORDER BY SUM(rb4.TimesRead); （4）列出符合以下要求的所有图书馆成员的ID和第一名字。●性别为女。 ●在图书馆有借阅记录（读某本书一次）。 ●按名字的字母顺序排列结果。 SELECT libid,fnamefrom member4WHERE libid in(SELECT libidfrom read_by4)and Gender&#x3D;’F’ORDER BY fname; （5）列出符合以下要求的所有出版的名字，ID，和订书总量。●平均订书量（某个出版社收到的订书总量除以该出版社收到的订单数）低于系统的平均订书量（系统收到的订书总量除以所有订单数）。 *&#x2F; select s4.Name,s4.Supplier_Id,SUM(po4.Qty)&#x2F;COUNT(o4.PoNum),SUM(po4.Qty),COUNT(o4.PoNum)from ordered4 o4, supplier4 s4,purchase_order4 po4where o4.PoNum&#x3D;po4.PoNum and o4.Supplier_Id&#x3D;s4.Supplier_IdGROUP BY o4.Supplier_IdHAVING SUM(po4.Qty)&#x2F;COUNT(o4.PoNum)&lt;(SELECT AVG(Qty)FROM purchase_order4); &#x2F;* （6）列出符合以下要求的所有图书馆成员的第一名字，ID。●性别为男。 ●Oct. 10, 1995前加入图书馆。 ●阅读不同标题（title）书籍的次数在5次或5次以下。 ●阅读同一书籍（同一title）的次数在两次或两次以上 *&#x2F; SELECT m4.libid,m4.fnamefrom member4 m4,read_by4 rb4,title4 t4where m4.gender&#x3D;’M’and m4.JOIN_date&lt;&#x3D;’1995-10-10’and t4.callnumber&#x3D;rb4.callnumberand m4.libid&#x3D;rb4.libidAND rb4.TimesRead&gt;&#x3D;2GROUP BY (m4.LibId)HAVING COUNT(DISTINCT t4.name)&lt;&#x3D;5;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SSD7","slug":"SSD7","permalink":"https://baiyuan.wang/tags/SSD7/"}]},{"title":"强化WordPress网站安全的 12 个方法","slug":"12-way-to-enhance-the-wordpress-web-site-security","date":"2015-05-09T15:01:36.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"12-way-to-enhance-the-wordpress-web-site-security.html","link":"","permalink":"https://baiyuan.wang/12-way-to-enhance-the-wordpress-web-site-security.html","excerpt":"","text":"这篇文章主要是利用.htaccess去对网站做设定、限制目录读取，强化WordPress网站整体安全，不过你也别忘了要设定强一点的密码。 接下来极客人要介绍的主要是透过.htaccess对网站做一个基础的强化，保护wp-admin目录、限制wp-includes目录读取、防垃圾留言、禁止目录索引、限制wp-config.php访问权限等等，算是很基础的网站安全防护，不论你网站是否遭受攻击，其实这些都是必要性的安全防护。当然，进行了下面的网站安全防护不代表你被不会被黑客入侵，而是多一层保障、降低一些被攻击几率。 一、限制wp-admin目录IP如果你管理wordpress网站一般就只有那么几个IP，而且你对自己的网站安全十分看重，比如你运行一个关系重大的团队网站，同时常常受到黑客的光顾，而且团队运行的登陆者常常使用的几个固定IP，为了保证网站的安全，下面这个方法可以限制读取wp-admin目录的IP或者IP网段，不是指定的IP（或者IP网段）就无法访问后台，这个方法当然不仅仅针对wordpress网站。 用NotePad++新增一个.htaccess文件，在htaccess文件中添加下述代码，并将文件上传到“wp-admin”目录下。 其中的蓝色部分请换成你的IP，这段语法的判断流程简言之就是先封锁有所IP，然后开放允许的IP，所以将“allow from 12.34.56.78”的12.34.56.78改成你的IP。如果是一个网段，可以输入“ 12.34.56.” AuthUserFile &#x2F;dev&#x2F;nullAuthGroupFile &#x2F;dev&#x2F;nullAuthName “Wordpress Admin Access Control”AuthType Basicorder deny,allowdeny from allallow from 12.34.56.78 二、限制存取wp-includes目录“wp-includes”这个目录是系统的一些核心目录，还有”&#x2F;wp-admin&#x2F;wp-includes”和，”&#x2F;wp-includes”在我们的网站页面上并没有哪个页面有URL会指向这些地方（通常这个目录里的文件只能被被管理者修改或者代码里调用的）。用以下这段语法可以限制存取的权限，请将下面的代码加入到根目录的.htaccess文件中。 此为官方建议设定。 # Block the include-only files.RewriteEngine OnRewriteBase &#x2F;RewriteRule ^wp-admin&#x2F;includes&#x2F; - [F,L]RewriteRule !^wp-includes&#x2F; - [S&#x3D;3]RewriteRule ^wp-includes&#x2F;[^&#x2F;]+\\.php$ - [F,L]RewriteRule ^wp-includes&#x2F;js&#x2F;tinymce&#x2F;langs&#x2F;.+\\.php - [F,L]RewriteRule ^wp-includes&#x2F;theme-compat&#x2F; - [F,L]# BEGIN WordPress 如果没有加入以上语法，会显示错误讯息；如果加了以上语法，会显示WordPress的默认404页面：告诉你目录不存在，这样是一个比较安全的防护措施。 三、限制wp-login.php登入IP如果你网站没有开放注册，那你可以执行这项的方法，限制允许访问wp-login.php只有网站的管理者，设定方法和前面的限制wp-admin存取IP方法类似，请将“12.34.56.78”改成你允许的IP或是网段。 Order deny,allow Deny from All Allow from 12.34.56.78 四、限制上传大小避免黑客透过Dos攻击，利用传输大文件来冲爆你的流量，所以可以透过限制单档大小来阻绝这样的一个状况发生，将以下语法加入到根目录的.htaccess文件中即可，极客人的预设是10MB。 LimitRequestBody 10240000 五、保护wp-config.php配置文件用过WordPress都知道”wp-config.php”这个文件攸关整个系统的运行，少了它或者配置错误连不上数据库，因为这个文件内保存了MySQL的账号与密码，为了保护这个文件，WordPress官方有个建议，就是先将此文件权限设定为”400”，也就是只允许拥有人权读取。不过设400可能会让一些插件例如wp super cache要写入设定值时发生错误，所以请大家斟酌裁定。 不过保护wp-config.php重头戏是设定.htaccess目录，修改根目录的.htaccess目录，加入以下语法，这语法意思是：禁止所有人浏览(主机内的程序是可以正常读取的)。 此为官方建议的设置方法： order allow,deny deny from all 六、防垃圾留言攻击以下这段语法是保护你的留言防止被机器人垃圾留言攻击，主要屏蔽没有referrer的请求，但极客人使用过后发现成效有限，建议再加装Akismet和quiz保护会更好。请将下述代码加入到根目录的.htaccess文件，其中的”baiyuan.wang”请换成你自己的网站网址。 RewriteEngine OnRewriteCond %{REQUEST_METHOD} POSTRewriteCond %{REQUEST_URI} .wp-comments-post\\.php*RewriteCond %{HTTP_REFERER} !.*baiyuan.wang.* [OR]RewriteCond %{HTTP_USER_AGENT} ^$RewriteRule (.*) ^http:&#x2F;&#x2F;%{REMOTE_ADDR}&#x2F;$ [R&#x3D;301,L] 七、禁止目录索引如果你的虚拟主机没有开启禁止目录索引功能，请您务必加上此语法以保护没有index目录的目录，避免被恶意人士将网站内容全部下载。 Options -Indexes 八、变更数据表前缀数据表前缀词其实在一开始安装的时候就务必做一个修正的动作，避免使用预设wp的名称，修改请务必小心，否则可能造成网站错误，做任何调整前务必先行备份。 九、合理设置目录权限网站内该设定的权限务必根据需求调整好，例如wp-config.php就不建议设定为777。 十、账号安全WordPress系统默认安装是采用admin账号，不过后来的版本允许使用者自行选择网站管理员账号，以避免恶意用户想要尝试admin登入网站。如果你本身已经使用admin，请赶快换账号吧！不然黑客轻易的就可以猜到你账号，接下来猜出密码应该很快了。另外建议使用Limit Login Attempts强化登入安全，当然您也要设一个不易猜出的密码。 十一、关闭后台主题编辑功能WordPress后台的主题一旦权限开放就可以在后台直接编辑，如果没有开放则只可浏览。主机若有安装suPHP默认就是可以编辑。如果你觉得这项功能用不到，建议您可以关闭它，毕竟直接暴露在后台可以编辑是一件很危险的事情，除了可能因为黑客入侵乱改，也可能自己改错造成网站出错。请将以下语法加入倒wp-config.php适当位置，就可以关闭修改的权限了。 define(‘DISALLOW_FILE_EDIT’, true); 十二、限制 .htaccess 访问权限当以上的东西调整完之后，别忘了强化你的.htaccess目录本身权限。将以下语法加入到.htaccess目录内已启用自我保护。语法是禁止所有人直接浏览该目录，但是系统使用读取是允许的。 &lt;Files .htaccess&gt;order allow,denydeny from all 最后各位还是要做好个人的账号密码保护，另外也别在不明的网络、计算机乱登入网站，这都可能造成帐密外泄，除此之外，再次提醒，使用以上方法只会加强WordPress安全，但无法保证百毒不侵，仍有机会遭受到黑客入侵，通常状况可能是您帐密外泄、网站插件、主题有漏洞、系统有不明的漏洞，还有目录权限设定不正确等等的状况，各位还是要多多注意。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"}]},{"title":"网站屏蔽垃圾评论和恶意访问、采集","slug":"website-block-comment-spam-and-malicious-access-collection","date":"2015-05-06T07:28:37.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"website-block-comment-spam-and-malicious-access-collection.html","link":"","permalink":"https://baiyuan.wang/website-block-comment-spam-and-malicious-access-collection.html","excerpt":"","text":"对于站长来说,垃圾评论都是一件比较苦恼的事,垃圾评论常常夹杂各种广告内容,而且过多的垃圾评论还会加大服务器的负担.垃圾评论的发起者往往是网络机器人,因为没有哪个正常人费时费力跑到你的网站自己受到敲字发广告等垃圾评论.最近极客人也自己结合了网站的代码,自己做了一个网络机器人,实现了短时间内打开下载几十个页面并且采集下载页面中的图片——当然是拿自己的网站做试验. 这篇文章主要分两部分，一是屏蔽网络机器人发垃圾评论；二是防止恶意访问刷新、采集图片耗费服务器资源和流量。 一、网站屏蔽机器人垃圾评论（利用PHP）本篇文章屏蔽机器人的思路是屏蔽掉一些UA信息为空及其它典型是机器人UA（USER_AGENT，以下简称为UA）的访问用户。实现原理是通过php代码识别来访用户的UA信息，和典型的机器人UA信息进行比对，比对确认是机器人访问后禁止该用户访问。至于怎么查看UA，大家可以分析一下自己的网站日志。为此极客人综合网上的代码写了下面的代码。 为了在机器人访问网页第一时间就实行封禁，对于wordpress主题网站，建议将下面的代码添加到wordpress主题文件夹下header.php文件内容的最前面。极客人在此更建议的方式是：将下面的函数和执行代码书写在单独的一个PHP文件中，然后再在header.php文件中进行调用（因为header中代码太杂以后不好看）； 此代码对任何支持PHP语言网站程序都有效， 屏蔽空UA的antiEmptyUA()函数代码：function antiEmptyUA(){ &#x2F;&#x2F;获取UA信息$ua &#x3D; $_SERVER[‘HTTP_USER_AGENT’];&#x2F;&#x2F;将恶意USER_AGENT存入数组$now_ua &#x3D; array(‘FeedDemon ‘,’BOT&#x2F;0.1 (BOT for JCE)’,’CrawlDaddy ‘,’Java’,’Feedly’,’UniversalFeedParser’,’ApacheBench’,’Swiftbot’,’ZmEu’,’Indy Library’,’oBot’,’jaunty’,’YandexBot’,’AhrefsBot’,’YisouSpider’,’jikeSpider’,’MJ12bot’,’WinHttp’,’EasouSpider’,’HttpClient’,’Microsoft URL Control’,’YYSpider’,’jaunty’,’Python-urllib’,’lightDeckReports Bot’);&#x2F;&#x2F;禁止空USER_AGENT，dedecms等主流采集程序都是空USER_AGENT，部分sql注入工具也是空USER_AGENTif(!$ua) {header(“Content-type: text&#x2F;html; charset&#x3D;utf-8”);wp_die(‘机器人，滚粗！’);}else{foreach($now_ua as $value )&#x2F;&#x2F;判断是否是数组中存在的UAif(eregi($value,$ua)) {header(“Content-type: text&#x2F;html; charset&#x3D;utf-8”);wp_die(‘机器人，滚粗！’);}}} 函数调用antiEmptyUA(); 二、防止访问者或机器人恶意频繁刷新、大流量访问如果说发广告垃圾评论的人是损人利己，那么利用网络机器人进行频繁刷新、大量流量攻击的人就是损人不利己了。当然极客人觉得“存在即合理”，人家主动对一个网站发动攻击，或许是哪里得罪了人家，想通过搞瘫你的网站来小小惩罚你一下。比如，我最近就很想（不过没实施，想想还是算啦）对前几天转载我的文章不加版权，还说自己是写的人进行一下网站攻击。所以，在你专心研究怎么防止别人恶意访问的同时，极客人在此提醒你以后转载别人的文章真的还是加一下版权，尊重作者的劳动成果。 下面是本站的效果截图： 下述代码和上面的代码一样，建议加在header.php最前面或者其他网站程序最先执行代码的最前面 防止频繁访问的anticc()函数代码:function antiEmptyUA(){ &#x2F;&#x2F;获取UA信息$ua &#x3D; $_SERVER[‘HTTP_USER_AGENT’];&#x2F;&#x2F;将恶意USER_AGENT存入数组$now_ua &#x3D; array(‘FeedDemon ‘,’BOT&#x2F;0.1 (BOT for JCE)’,’CrawlDaddy ‘,’Java’,’Feedly’,’UniversalFeedParser’,’ApacheBench’,’Swiftbot’,’ZmEu’,’Indy Library’,’oBot’,’jaunty’,’YandexBot’,’AhrefsBot’,’YisouSpider’,’jikeSpider’,’MJ12bot’,’WinHttp’,’EasouSpider’,’HttpClient’,’Microsoft URL Control’,’YYSpider’,’jaunty’,’Python-urllib’,’lightDeckReports Bot’);&#x2F;&#x2F;禁止空USER_AGENT，dedecms等主流采集程序都是空USER_AGENT，部分sql注入工具也是空USER_AGENTif(!$ua) {header(“Content-type: text&#x2F;html; charset&#x3D;utf-8”);wp_die(‘请勿采集本站！’);}else{ foreach($now_ua as $value )&#x2F;&#x2F;判断是否是数组中存在的UA if(eregi($value,$ua)) { header(“Content-type: text&#x2F;html; charset&#x3D;utf-8”); wp_die(‘请勿采集本站！’); }}} 函数调用方法：anticc(2)；根据你的需求修改时间值“2” 以上代码中function anticc($time_sep)的“$time_sep”是控制$time_sep秒中内允许用户访问一次，比如$time_sep&#x3D;3时，如果用户在3秒内访问超过一次，系统则会提示“警告：请求过于频繁”，并且只有等待三秒后才能访问本网站。具体效果你可以在王柏元的博客，狂按F5刷新，体验一下。 三、利用htaccess屏蔽机器人垃圾评论（推荐）这个方法还是屏蔽空UA的机器人，但是效率会比PHP高很多，这里是屏蔽机器人直接通过wp-comments-post.php发垃圾评论。 # BEGIN 屏蔽垃圾留言：屏蔽空referrer留言RewriteEngine OnRewriteCond %{REQUEST_METHOD} POSTRewriteCond %{REQUEST_URI} .wp-comments-post\\.php*RewriteCond %{HTTP_REFERER} !.*baiyuan.wang.* [OR]RewriteCond %{HTTP_USER_AGENT} ^$RewriteRule (.*) ^http:&#x2F;&#x2F;%{REMOTE_ADDR}&#x2F;$ [R&#x3D;301,L]# END 屏蔽垃圾留言：屏蔽空referrer留言 四、禁止垃圾评论IP直接将垃圾评论的IP加入黑名单，该IP访问时直接“403无权限访问”，还可以节约虚拟主机的流量。（但是一般垃圾评论的IP经常会变！） 由于文字较多，请参看我的一篇独立博文：虚拟主机怎样屏蔽指定IP或网段做详细了解，在此不赘述。 五、终极方法验证码，安装验证码插件。这个方法比上面的都有效，但是要安装插件。原理不解释。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"UA","slug":"UA","permalink":"https://baiyuan.wang/tags/UA/"},{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"}]},{"title":"提升流畅度 谷歌推全新安卓开发语言Sky","slug":"improve-fluency-google-push-brand-new-android-development-language-sky","date":"2015-05-04T05:17:16.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"improve-fluency-google-push-brand-new-android-development-language-sky.html","link":"","permalink":"https://baiyuan.wang/improve-fluency-google-push-brand-new-android-development-language-sky.html","excerpt":"","text":"转自 中关村在线 作者：张金梁 | 责编：魏景芳 据外媒报道，在日前举行Dart开发者峰会上，谷歌对外正式展示了Android最新的开发语言Sky。据悉，Sky本质上就是谷歌自主的网页开发语言Dart。 谷歌推全新安卓开发语言Sky（图片来自baidu） 谷歌表示，目前Sky只是一次开源的尝试。但相对于传统的Android应用开发方式，Sky有着多方面优势。Sky的最主要目的包括提高运行速度和响应速度。在大部分设备上，应用流畅的标准都是实现60FPS的帧率。不过，Dart团队希望实现高达120FPS的帧率。目前在Android平台上，许多应用连标准的60FPS帧率都难以达到，更不用说120FPS。 Dart团队展示了一款演示应用，每帧的绘制速度仅为1.2毫秒。尽管这只是一次简单的展示，但这意味着，对于开发流畅而复杂的应用来说，Sky有着很大的空间，这也使120FPS的帧率成为了可能。该团队表示，Sky的应用程序接口(API)不会影响界面的主线程，这意味着即使应用运行速度变慢，用户界面仍将保持流畅的响应速度。 Sky并不依赖于平台，其代码可以运行在Android、iOS，以及任何集成了Dart虚拟机的平台上。这类应用的运行类似于网站。应用的很大一部分基于HTTP，这意味着开发者可以进行持续的开发，并确保所有用户一直使用最新版本。这款演示应用的弱点在于无法离线运行，而启动应用则需要1到2秒钟时间，因为应用需要下载数据。不过，这两方面的问题可以通过缓存机制来解决。 基于HTTP的模式使开发变得很简单。开发者不必编辑代码、编译并打包，这些代码可以在HTTP服务器上编辑。而用户只需关闭并重新打开应用，即可完成应用的“升级”。这就像是一款网页浏览器。Android开发者可以使用Sky Framework，这提供了一整套Material Design小工具，帮助开发者方便地增加操作栏、触控效果、导航面板，以及Android应用中所需的一切元素。 与普通应用类似，Sky应用可以获得Android的全部权限和API，但结合来自网页服务器的自动升级功能，这将带来信息安全问题。不过目前，Sky仅仅只是一个试验项目。在Sky成为一种主流的Android应用解决方案之前，Sky团队需要解决这些问题。该团队的GitHub页面显示：“我们仍在对Sky进行频繁地迭代，这意味着框架和底层引擎有可能以不兼容的方式出现改变。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"}]},{"title":"安卓虚拟机加速—Intel HAXM加速媲美真机","slug":"android-virtual-machine-acceleration-intel-haxm-acceleration-comparable-to-real-machine","date":"2015-05-04T03:08:43.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"android-virtual-machine-acceleration-intel-haxm-acceleration-comparable-to-real-machine.html","link":"","permalink":"https://baiyuan.wang/android-virtual-machine-acceleration-intel-haxm-acceleration-comparable-to-real-machine.html","excerpt":"","text":"引语：安卓虚拟机天生就慢？安卓虚拟机的速度一直以慢“著称”，经常卡顿的安卓虚拟机对于开发者来说是一件十分痛苦的事情，这极大地影响到了开发者的效率和心情。下面我想大家介绍一种加速安卓虚拟机的方法，如果你的电脑有一颗支持Intel(R) Virtualization Technology (VT) 的intel CPU（你可以不管什么是VT技术，只要你是i5或以上的intelCPU，一般都有这项技术，如果是AMD的CPU应该就不能享受下面的“福利”了），你不妨试一下，极客人自从使用了安卓虚拟机加速，运行、调试应用的速度完全达到了真机速度。 一、下载CPU&#x2F;aBI为intel atom的安卓系统镜像 肯定考虑到兼容性问题和其他极客人也不知道的原因，网上下载的现成的安卓虚拟机往往是“armeabi-v7a”，这个架构的CPU系统镜像不Intel(R) Virtualization Technology (VT) 的硬件加速，这是导致安卓虚拟机卡慢的原因，可能大部分的朋友和极客人以前的想法一样，是java虚拟机拖慢了安卓虚拟机的速度。 打开SDK管理器 请按图中所述选择一项intel的系统镜像下载： Intel x86 Atom System Image Intel x86 Atom_64 System Image ARM EABI v7a System Image 二、下载并安装 Intel HAXM 扩展打开SDK管理器，如图勾选Intel HAXM 下载并安装 三、新建CPU&#x2F;ABI为Intel Atom的安卓虚拟机完成上面几步后新建CPU&#x2F;ABI为Intel Atom的安卓虚拟机，然后启动这一虚拟机就行了，你会发现安卓虚拟机天生就慢的想法是不对的！ 四、相关下载：安卓5.0、API21、CPU&#x2F;ABI为intel atpm的系统镜像的下载地址：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"}]},{"title":"officeWord为文档自动添加目录和页码","slug":"officeword-automatically-add-a-directory-for-the-document-and-page-number","date":"2015-05-03T09:50:20.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"officeword-automatically-add-a-directory-for-the-document-and-page-number.html","link":"","permalink":"https://baiyuan.wang/officeword-automatically-add-a-directory-for-the-document-and-page-number.html","excerpt":"","text":"五月一日时，数模比赛季。繁忙复悠闲的大学生生活，好不容易迎来了小时候曾魂牵梦绕的五一劳动节。然后西工大的五一，从来未曾悠闲过。通宵不灭的灯，即使在凌晨一二点依旧星星点点。工大人们日夜奋战，因为各种动机，几乎达到了满校数模的境地。洋洋洒洒的论文，动辄二十余页，不知道自己写的话自己懂不懂，但是手里拿着这一叠沉甸甸的“知识”，心里头还是有些小小激动与充实。在这群工大人中，自然也有极客人。 不知道什么时候后面来了个哥们，看了看我基本完成的论文，悻悻道：“题目这么难，论文这么长，还要加目录，真麻烦！”。听到这句话，我不禁为这位仁兄心生敬意：“你的目录是自己一个字一个字敲上去的？”。他答道：”要不呢？“。晕……，于是，我就如此这般、如此这般地和他一番话语，听罢，他不禁连声赞道：”妙哉妙哉！“。 如此这般所以，我就把和这位仁兄如此这般的话如实记录了下来，分享到王柏元的博客： officeWord为文档自动添加目录和页码在数模论文中，动辄20页的论文不足为奇，如果把本来就疲惫的身心花费在敲目录和页码上，实在是不值。如果20页的论文，可能大小目录也就20条不足为惧，那你想过没有几千页的书籍它的目录是怎么标注出来的、同时准确标明页码？ 一、为标题添加标题样式对于数模论文、书籍，一般结构性很强，在为章节标注标题时，我们尽量不要把文字简单加粗、加大字号来充当标题，而应该给标题文字严格地添加”标题一“、”标题二“等标题样式。添加标题样式，word不仅会帮你把标题文字加粗加字号，还会识别出内容间的层次关系：比如标题一是标题二的父级，标题二是标题三的父级。 至于添加严格的标题样式和标题间层级关系有什么作用？当然是为了下面的添加目录。 二、Word为文档自动添加目录和页码设置完标题样式后，以极客人使用的word2010为例， 打开”引用“选项卡——目录——添加目录，选择”自动“目录和你喜欢的样式，你就能看到自动添加的目录了： ![2JG2IU7F1NL2KJZE3]3QAE](http://baiyuan.wang/wp-content/uploads/2015/05/2JG2IU7F1NL2KJZE33QAE_thumb.png &quot;2JG2IU7F1NL2KJZE3]3QAE”) 如上图所示，word会根据标题间的层级关系为目录的标题设置段前缩进，如：一、问题的重述 二、问题的分析都是标题一样式；1.1问题背景 1.2问题提出都是标题二样式，所以看到1.1问题背景缩在一、问题的重述后面。添加目录后，如果你添加了新的内容或标题，导致目录应该相应变化时，请点击上面添加的目录，点击”更新目录“，目录内容和页码会自动更新；而且，当按”ctrl“和点击目录中对应的标题，word会自动跳到标题的位置。 附录：word必会：页脚加页码word文档的页码也不需要自己手动添加，选择”插入——页码“，选择页码即可，几种页码样式请自己选择。这样在建立一个新的word页面时，新页面的页码也会同步添加。 ![H)MZD6B3ME17$ZS&#96;1F]A_N2](http://baiyuan.wang/wp-content/uploads/2015/05/HMZD6B3ME17ZS1FA_N2.png)","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"officeWord","slug":"officeWord","permalink":"https://baiyuan.wang/tags/officeWord/"}]},{"title":"Android中资源详解（初级篇）","slug":"android-resources-detailed-in-primary-segment","date":"2015-05-01T10:20:08.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"android-resources-detailed-in-primary-segment.html","link":"","permalink":"https://baiyuan.wang/android-resources-detailed-in-primary-segment.html","excerpt":"","text":"一、Android中资源分类详解 1、Android资源分类Android中的资源分为两大类 : 可直接访问的资源, 无法直接访问的原生资源; – 直接访问资源 : 这些资源可以使用 R. 进行访问, 都保存在res目录下, 在编译的时候, 会自动生成R.java 资源索引文件; – 原生资源 : 这些资源存放在assets下, 不能使用 R类 进行访问, 只能通过 AssetManager 以二进制流形式读取资源; 2、Android资源详解 res目录下资源详解 : -- res&#x2F;animator : 属性动画的XML文件目录, 属性动画就是定义起始结束, 动做, 重复时间等参数齐全的动画; -- res&#x2F;anim : 补间动画的XML文件目录, 补间动画是只定义 起始 结束帧, 中间的动作由系统进行计算获取动作过程; -- res&#x2F;color : 颜色列表的XML文件目录; -- res&#x2F;drawable : 存放真实的位图文件, 也可以存放Drawable对象及子类对象的XML文件; -- res&#x2F;layout : 界面布局文件目录; -- res&#x2F;menu : 程序中使用的菜单文件目录, 该文件下的XML文件可以应用与 选项菜单, 子菜单, 上下文菜单等; -- res&#x2F;raw : 存放原生资源, 与assets目录作用相同, 可以通过调用openRawResource(int)方法获取二进制输入流, 与asstes相似, 使用AssetsManager访问这些资源; -- res&#x2F;value : 存放 字符串. 整数, 颜色, 数组 信息的 XML文件的目录, 这些XML文件资源的根元素是resource; -- res&#x2F;xml : 原生的XML文件, 可以使用 Resource.getXML()方法进行访问; res&#x2F;value目录XML文件子标签解析 : -- string标签 : 代表一个字符串; -- integer标签 : 代表一个整数值标签; -- bool标签 : 代表一个boolean值; -- color标签 : 代表一个颜色值; -- array标签 : 代表数组; -- string-array标签 : 代表字符串数组; -- int-array标签 : 代表int数组; -- style标签 : 代表样式; -- dimen标签 : 代表一个尺寸; 3、分类资源文件 :如果将所有的资源放到一个XML文件中, 会增加维护难度, 这里将不通类型的资源放到不同的XML文件下; -- arrays.xml : 存放数组资源; -- colors.xml : 存放颜色资源; -- dimens.xml : 存放尺寸值资源; -- strings.xml : 存放字符串资源; -- styles.xml : 存放样式资源; 二、Android中资源的使用 (1) Java代码访问清单资源在Java代码中通过R类获取资源语法 : [packageName.] R . resourceType . resourceName -- pakegeName : R类所在的包名, 即权限定类型, R类可能来自两个包, 一个是程序本身的清单文件, 一个是Android系统存在的清单文件; -- resourceType : R类中代表的资源类型的名称, R.string 字符串资源, R.integer 代表整数资源; -- resourceName : 资源名称, 这个资源名称是对应类型子标签的 name属性的值; (2) Java代码访问原生资源 Resource类 : Android资源访问控制类, 该类提供了大量方法获取实际资源, Resource通过 Context.getResource()方法获得; -- 获取清单资源 : resource.getString(id), 根据id获取实际资源; -- 获取原生资源 : resource.getassets(), 获取AssetManager对象; &#x2F;&#x2F;获取Resource资源, 这个方法在Activity中执行Resources resources &#x3D; getResources();&#x2F;&#x2F;获取字符串资源String hello &#x3D; resources.getString(R.string.hello_world);&#x2F;&#x2F;获取图片资源Drawable luncher &#x3D; resources.getDrawable(R.drawable.ic_launcher); (3) XML文件中使用资源 在XML文件中需要引用其它XML文件中的值, 语法格式为 : @ [packageName : ] resourceType &#x2F; resourceName -- packageName : 资源类型所在的包, 如果被引用资源 与 本XML文件在同一个包下, 可以省略包名; -- resourceType : 资源类型, 例如 layout, drawable, strings等; -- resourceName : 资源名称, 资源所在的XML文件中元素的 android:name 属性, 或者 是无后缀的文件名, 例如图片, 布局文件等; 三、字符串 颜色 尺寸 数组资源的使用情况(1) 几种资源的目录引用名称字符串资源 : -- 默认目录 : &#x2F;res&#x2F;values&#x2F;strings.xml ; -- 引用方式 : R.string.xxx ; 颜色资源 : -- 默认目录 : &#x2F;res&#x2F;values&#x2F;colors.xml ; -- 引用方式 : R.color.xxx ; 尺寸资源 : -- 默认目录 : &#x2F;res&#x2F;values&#x2F;dimens.xml ; -- 引用方式 : R.dimens.xxx ; 颜色定义方式: 1.三原色 : 白光 可以分解为 红, 绿, 蓝 三种颜色的光, 红绿蓝都是最大值的时候就是白色, 三种值相等, 但不是最大值是灰色, 如果其中一种或两种值比较大, 就会产生各种颜色的彩色; 2.颜色表示 : 颜色通过 红(red) 绿(green) 蓝(blue) 三种颜色, 以及 透明度(alpha) 来表示的; – 颜色开头 : 颜色值总是以 # 开头; – 无透明度 : 如果没有 alpha 值, 默认完全不透明; 颜色定义形式 : -- #RGB : 红 绿 蓝 三原色值, 每个值分16个等级, 最小为0, 最大为f; -- #ARGB : 透明度 红 绿 蓝 值, 每个值分16个等级, 最小为0, 最大为f; -- #RRGGBB : 红 绿 蓝 三原色值, 每个值分 256个等级, 最小为0, 最大为ff; -- #AARRGGBB : 透明度 红 绿 蓝 值, 每个值分 256个等级, 最小为0, 最大为ff; (2)字符串 颜色 尺寸 XML文件定义 1) 字符串资源文件 字符串资源文件信息 : -- 资源位置 : &#x2F;res&#x2F;values 目录下; -- 根元素 : 是根元素; -- 子元素 : ; -- name属性 : 指定变量名称; -- 标签文本 : 标签文本就是字符串信息; ResourceTestSettingsHello world! 2) 颜色资源文件颜色资源文件信息 : -- 位置 : &#x2F;res&#x2F;values目录; -- 根元素 : ; -- 子元素 : ; -- name属性 : 颜色资源名称; -- 标签文本 : 颜色值; #FF4000 #120A2A #00FF00 #FFFF00 3) 尺寸资源文件 尺寸资源信息 : -- 位置 : &#x2F;res&#x2F;values目录; -- 根元素 : ; -- 子元素 : ; -- name属性 : 尺寸名称; -- 标签文本 : 尺寸值; 16dp 16dp 4）数组资源资源数组文件 : 通常将数组定义在 &#x2F;res&#x2F;values&#x2F;arrays.xml文件中; -- 根标签 : ; -- 子标签 : , , ; 资源数组类型 : 数组的资源的跟标签都是 , 不同类型的数组的子元素不同; -- 普通类型数组 : 使用作为子元素标签; -- 字符串数组 : 使用作为子元素标签; -- 整数数组 : 使用作为子元素标签; XML文件中调用数组资源 : @ [packageName :] array&#x2F;arrayName ; Java文件中调用数组资源 : [packageName . ]R.array.arrayName ; -- 获取实际普通数组 : TypeArray obtainTypedArray(int id), 根据普通数组资源名称获取实际普通数组, TypeArray类提供了getXxx(int index)方法获取指定索引的元素; -- 获取字符串数组 : String[] getStringArray(int id), 根据字符串数组资源名称获取字符串数组; -- 获取整数数组 : int[] getIntArray(int id), 根据整数数组资源名称获取实际的整数数组;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"}]},{"title":"SSD7_EX2【SQL】","slug":"ssd7-ex2-sql","date":"2015-04-30T04:01:41.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd7-ex2-sql.html","link":"","permalink":"https://baiyuan.wang/ssd7-ex2-sql.html","excerpt":"","text":"这是SSD7练习的EX2，预计极客人将会写一个系列，更新频率会和NWPU数据库系统实验课2013级进度同步。点击标签或在本站搜索“SSD7”即可获取已更新的SSD7答案。上一练习：SSD7_EX1【关系型数据库】 运行给定的SQL脚本来创建一个图书馆的数据库。注意，Book表中的每一行指的是一本书的副本。 因此， 如果一个数据库有三本”DBMS”， 那么Book表中将会有三行，一行一个副本。 编写SQL语句来完成下列操作。（注意：对于每个操作，你必须用一条SQL语句来表达你的查询。 但是在一个语句中可以含有子查询）： 英语原文：Run the SQL script given to you to create a Library database. Note that each row in the Book table denotes a book copy. Thus, if the library carries three copies of the title “DBMS”, there will be three rows in the Book table, one for each copy. Write the SQL statements to do the following against the database (Note: You must express your query in a single SQL statement for each of the following. However, that statement could have sub-queries.): 作业还是自己做的好，以下是我做的结果，作交流学习之用，不要盲目抄袭，东西学会了才是自己的！如果答案有纰漏，欢迎指正，水平有限，仅供参考： 1. 列出”Churchill”写的所有的书的书名，以及它们的出版日期。select t1.name,t1.yearfrom title t1,author a1where t1.callnumber&#x3D;a1.callnumber and a1.lname&#x3D;’Churchill’; 2. 检索出名为”John” 或 “Susan” 的会员借出的所有书的书名。select namefrom titlewhere callnumber in(select callnumberfrom bookwhere borrowermemno in(select memnofrom memberwhere (fname&#x3D;’John’ or fname&#x3D;’Susan’))) 3. 列出那些已借了”Iliad”和”Odyssey”这两本书的所有会员的姓名和ID。&#x2F;第3题&#x2F;select fname, lname,memnofrom memberwhere memno in(select borrowermemnofrom bookwhere callnumber in(select callnumberfrom titlewhere name&#x3D;’Iliad’))and memno in(select borrowermemnofrom bookwhere callnumber in(select callnumberfrom titlewhere name&#x3D;’Odyssey’)); 4. 列出那些已借了”Collins”写的所有的书的所有会员的姓名和ID。假设，一名会员或许已经借了多本同样的书。&#x2F;第4题&#x2F;select m1.fname,m1.Lname,m1.MemNofrom author a1,book b1,member m1where a1.lname&#x3D;’Collins’and b1.callnumber&#x3D;a1.callnumber and m1.MemNo&#x3D;b1.BorrowerMemNoGROUP BY m1.MemNoHAVING COUNT(DISTINCT b1.callnumber)&#x3D;(SELECT COUNT(DISTINCT callnumber)FROM authorWHERE lname&#x3D;’Collins’); 5. 找出那些借了一本姓”Tanenbaum”的作者写的书的所有会员的电话号码&#x2F;第5题&#x2F;select m1.PhoneNumberfrom author a1,book b1,member m1where a1.lname&#x3D;’Tanenbaum’and b1.callnumber&#x3D;a1.callnumber and b1.BorrowerMemNo&#x3D;m1.MemNoGROUP BY b1.BorrowerMemNoHAVING COUNT(*)&#x3D;1; 6. 找出那些借了至少三本书的成员，并列出它们的姓名，ID 以及他们借出的书的数量。 按借出书的数量将序排列找到的结果。&#x2F;第6题&#x2F;select m1.Fname,m1.Lname,COUNT(b1.BorrowerMemNo) ‘借书总数’FROM book b1,member m1where m1.MemNo&#x3D;b1.BorrowerMemNoGROUP BY b1.BorrowerMemNoHAVING COUNT(*)&gt;&#x3D;3ORDER BY b1.BorrowerMemNo; 7. 列出没有借任何书的会员&#x2F;第7题&#x2F;select Fname,Lnamefrom memberwhere NOT EXISTS(SELECT *from bookwhere member.MemNo&#x3D;BorrowerMemNo); 8. 以字母序列出那些匹兹堡居民（电话号码以”412”开头）并且没有并且没有”Pitt Roads”这本书的会员的名。&#x2F;第8题&#x2F;select Lnamefrom memberwhere MemNo NOT IN(select b1.BorrowerMemNofrom title t1,book b1where t1.Name&#x3D;’Pitt Roads’ and t1.CallNumber&#x3D;b1.CallNumber)AND PhoneNumber like ‘412%’;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"SSD7","slug":"SSD7","permalink":"https://baiyuan.wang/tags/SSD7/"}]},{"title":"SSD7_EX1【关系型数据库】","slug":"ssd7-ex1-relational-database","date":"2015-04-28T12:34:12.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"ssd7-ex1-relational-database.html","link":"","permalink":"https://baiyuan.wang/ssd7-ex1-relational-database.html","excerpt":"","text":"第一部分（PART1）：1．按照以下要求标识出每个关系的关键字（主键、备用键、外键）。对于此练习，选择关键字的时候可以忽略性能因素。 1）标识出每个关系的主键，如果没有主键，做适当的论述证明你的答案。 2）标识出每个关系的备用键，如果没有备用键，做适当的论述证明你的答案。 3）标识出每个关系的外键和完整性约束，并做适当的论述证明你的答案。 2.列出每个关系的属性名，和每个属性的域（数据类型和格式），并做适当的论述证明你的答案。 在每一个HTML表格中，列出至少四行正确的数据（可自己假设，要求合理、符合实际即可），将你的答案书写在一个名为BookPublisher.html的HTML页面中提交： BookPublisher.html： BooksPrimary Author&lt;varchar(20)&gt; Title&lt;varchar(50)&gt; ISBN**(Primary Key)**&lt;char(12)&gt; PublisherID**(FOREIGN Key)** Edition&lt;varchar(10)&gt; Date of Publication Price&lt;float(4, 2)&gt; Book Description&lt;varchar(200)&gt; 赵静 数学建模与数学实验 9787040400038 1 第4版 2000.11 22.00 指导数学建模与数学实验 许建平 英汉互译实践与技巧 9787302146728 2 第4版 2012.8 38.00 本书是为非英语专业的大学生及研究生编写的英汉互译教程。 庄茁 基于ABAQUS的有限元分析和应用 9787302188162 2 第2版 2006.5 69.00 《基于ABAQUS的有限元分析和应用》是基于ABAQUS软件6.7版本进行有限元分析与应用的入门指南和工程分析与科学研究教程 王正林 精通MATLAB 9787121187315 3 第3版 2013.1 69.00 紧密结合实例，对MATLAB的使用进行了全面且详尽的阐述，并通过大量的实例讲述如何实现MATLAB的基本操作和实际使用。 路遥 平凡的世界(套装共3册) 9787530212004 4 第1版 2012.3 26.60 《平凡的世界(套装共3册)》是一部现实主义小说，也是小说化的家族史。 books论述：上面是Books表的数据，并在列名表明了数据类型及长度和主外键： **1.Primary Author &lt;varchar(20)&gt;**：可变字符串，最长20 完整性约束：PrimaryAuthor VARCHAR(20) NOT NULL DEFAULT “未知作者”, **2.Title &lt;varchar(50)&gt;**：可变字符串，最长50 Title VARCHAR(50) NOT NULL DEFAULT “默认标题”, 3.ISBN &lt;char(12)&gt;(Primary Key)：主键，因为ISBN对于每本书是唯一的，满足主键是唯一且不为空的条件，用以标识唯一一本书。 ISBN CHAR(13) NOT NULL DEFAULT “0000000000000” PRIMARY KEY, 4.PublisherID(FOREIGN Key)：int类型、外键， PublisherID INT(4) NOT NULL DEFAULT 0 , FOREIGN KEY (PublisherID) REFERENCES publisher(PublisherID) 因为Books和Publishers表拥有相同的属性PublisherID，并且PublisherID是Publishers表的主键，使用其作为外键，两个表就可以建立联系 ； 5.Edition&lt;varchar(10)&gt;：可变字符串，最长10 Edition VARCHAR(10) NOT NULL DEFAULT 0 , 6.Date of Publication ：日期类型 DateofPublication DATE NOT NULL DEFAULT ‘1970-01-01’ , 7.Price&lt;float(4, 2)&gt;：float类型，小数点两位 Price float(4, 2) NOT NULL DEFAULT 0 , 8.Book Description&lt;varchar(200)&gt;：可变字符串，最长200 BookDescription varchar(200) NOT NULL DEFAULT ‘描述为空’ , 主键(PK)： ISBN，因为ISBN对于每本书是唯一的，满足主键是唯一且不为空的条件，用以标识唯一一本书。 外键(FK)： PublisherID为Books和Publishers表拥有相同的属性PublisherID，并且PublisherID是Publishers表的主键，使用其作为外键，两个表就可以建立联系 ； 备用键(AK)：没有备用键，除主键ISBN外其他列都无法唯一标识一本书，存在相同标题、出版社、价格、出版时间等的书籍。 PublishersPublisherID (Primary Key) Name&lt;varchar(50)&gt; Address&lt;varchar(100)&gt; 04 高等教育出版社 北京市西城区德胜门外大街4号 302 清华大学出版社 北京市海淀区清华大学出版社 5053 电子工业出版社 北京市丰台区万寿路南口金家村288号华信大厦 5302 北京十月文艺出版社 北京市海淀区十月文艺出版社 1.PublisherID (Primary Key)：主键，因为PublisherID可以唯一标识出版社； 2.Name&lt;varchar(50)&gt;：可变字符串，最长50； 3.Address &lt;varchar(100)&gt;：可变字符串，最长100。 主键(PK)：PublisherID，因为PublisherID可以唯一标识出版社； 外键(FK)：显然没有； 备用键(AK)：Name，出版社名可以唯一标识出版社。 第二部分（part-2）按照要求书写SQL语句，将你的答案书写在一个名为createDB.Sql的文件中提交。 1）使用CREATE TABLE关键字创建两个关系，要求标识出每个关系的主键和备用键。 2）使用INSERT关键字向每个关系中插入四行数据（第一你部分列出的数据）。 3）书写SQL语句查询出某两个作者…… 4）书写SQL语句查询出某本书的出版社名字。 文件createDB.Sql：CREATE TABLE `publisher` ( `PublisherID` int(4) NOT NULL DEFAULT 0 PRIMARY KEY , `Name` varchar(50) not NULL DEFAULT “未知出版社”, `Address` varchar(100) NOT NULL DEFAULT “未知地址”);CREATE TABLE Books(PrimaryAuthor VARCHAR(20) NOT NULL DEFAULT “未知作者”,Title VARCHAR(50) NOT NULL DEFAULT “默认标题”,ISBN CHAR(13) NOT NULL DEFAULT “9780000000000” PRIMARY KEY,PublisherID INT(4) NOT NULL DEFAULT 1 ,Edition VARCHAR(10) NOT NULL DEFAULT 0 ,DateofPublication DATE NOT NULL DEFAULT ‘1970-01-01’ ,Price float(4, 2) NOT NULL DEFAULT 0 ,BookDescription varchar(200) NOT NULL DEFAULT “本书暂无描述”,FOREIGN KEY (PublisherID) REFERENCES publisher(PublisherID));INSERT INTO `publisher` (`PublisherID`, `Name`, `Address`) VALUES (‘1’, ‘高等教育出版社’, ‘北京市西城区德胜门外大街4号’);INSERT INTO `publisher` (`PublisherID`, `Name`, `Address`) VALUES (‘2’, ‘ 清华大学出版社 ‘, ‘北京市海淀区清华大学出版社 ‘);INSERT INTO `publisher` (`PublisherID`, `Name`, `Address`) VALUES (‘3’, ‘电子工业出版社’, ‘北京市丰台区万寿路南口金家村288号华信大厦 ‘);INSERT INTO `publisher` (`PublisherID`, `Name`, `Address`) VALUES (‘4’, ‘北京十月文艺出版社’, ‘北京市海淀区十月文艺出版社’); INSERT INTO Books(PrimaryAuthor,Title,ISBN,PublisherID,Edition,DateofPublication,Price,BookDescription) VALUE(‘赵静’,’数学建模与数学实验’,’9787040400038’,1,’第4版’,’2000-11-01’,22.00,‘指导数学建模与数学实验’);INSERT INTO Books(PrimaryAuthor,Title,ISBN,PublisherID,Edition,DateofPublication,Price,BookDescription) VALUE(‘许建平’, ‘英汉互译实践与技巧’,’9787302146728’,2,’第4版’,’2012-08-01’,38.00,‘本书是为非英语专业的大学生及研究生编写的英汉互译教程.’);INSERT INTO Books(PrimaryAuthor,Title,ISBN,PublisherID,Edition,DateofPublication,Price,BookDescription) VALUE(‘庄茁’,’基于ABAQUS的有限元分析和应用’,’9787302188162’,2,’第2版’,’2006-05-01’,69.00,‘基于ABAQUS软件6.7版本进行有限元分析与应用的入门指南和工程分析与科学研究教程’);INSERT INTO Books(PrimaryAuthor,Title,ISBN,PublisherID,Edition,DateofPublication,Price,BookDescription) VALUE(‘王正林’,’精通MATLAB’,’9787121187315’,3,’第3版’,’2013-01-01’,69.00,‘ 紧密结合实例，对MATLAB的使用进行了全面且详尽的阐述，并通过大量的实例讲述如何实现MATLAB的基本操作和实际使用。 ‘);INSERT INTO Books(PrimaryAuthor,Title,ISBN,PublisherID,Edition,DateofPublication,Price,BookDescription) VALUE(‘路遥’,’ 平凡的世界(套装共3册) ‘,’9787530212004’,4,’第1版’,’2012-03-01’,26.60,‘ 《平凡的世界(套装共3册)》是一部现实主义小说，也是小说化的家族史。 ‘); SELECT Title,PriceFROM bookswhere PrimaryAuthor&#x3D;’路遥’ OR PrimaryAuthor&#x3D;’许建平’;SELECT p1.NameFROM publisher p1,books b1where p1.PublisherID&#x3D;b1.PublisherID AND b1.Title&#x3D;’精通MATLAB’; ** 文件Rel-ops.txt：** [infobg class&#x3D;”tips” closebtn&#x3D;”” color&#x3D;”” bgcolor&#x3D;””] SELECT Title,Price FROM books where PrimaryAuthor&#x3D;’路遥’ OR PrimaryAuthor&#x3D;’许建平’; 此语句完成查询出某两个作者（例如”路遥” 、 “许建平”）出版的所有书的标题和价格； 解释：从books表中选择Title,Price两列，约束条件为作者是”路遥”或”许建平”。 SELECT p1.Name FROM publisher p1,books b1 where p1.PublisherID&#x3D;b1.PublisherID AND b1.Title&#x3D;’精通MATLAB’; 使用连接查询，p1、b1分别是publisher和books中的对象，使用PublisherID连接两者，令b1.Title&#x3D;’精通MATLAB’，选择p1.Name得出查询结果 [&#x2F;infobg]","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"SSD7","slug":"SSD7","permalink":"https://baiyuan.wang/tags/SSD7/"}]},{"title":"MySQL数据库的数据类型","slug":"mysql-database-data-types","date":"2015-04-28T04:54:40.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"mysql-database-data-types.html","link":"","permalink":"https://baiyuan.wang/mysql-database-data-types.html","excerpt":"","text":"数据类型是定义列中可以存储什么数据以及该数据实际怎么存储的基本规则。Mysql的常用数据类型主要有： 一、串数据类型最常用的数据类型，有两种基本的串类型：分别为定长串和不定长串。定长串结束长度固定的字符，其长度是创建表是指定的，不允许多于指定的字符数据，它们分配的存储空间与指定的一样多，CHAR属于定长串类型。变长串存储长度可变的文本，有些变长数据类型具有最大的定长，而有些则是完全变长的，不管哪种只有指定的数据得到保存（不会添加额外的空格保存），TEXT属于变长串类型。变长数据类型灵活，定长数据类型高效，Mysql处理定长数据类型比变长列快很多，Mysql不允许对变长列（或一个列的可变部分）进行索引，这会极大影响性能。具体类型描述如下表： 数据类型 说明 CHAR 1~255个字符的定长串，它的长度必须在创建时指定，否则MySQL假定为CHAR（1） VARCHAR 可变长度，最多不超过255字节，如在创建时指定VARCHAR（n），则可存储0~n个字符的变长串 TINYTEXT 同TEXT，最大长度为255字节 MEDUIMTEXT 同TEXT，最大长度为16K TEXT 最大长度为64K的变长文本 LONGTEXT 同Text，最大长度为4GB（纯文本，一般不会到4G） ENUM 接受最多64K个串组成的预定义集合的某个串 SET 接受最多64K个串组成的预定义集合的零个或多个串 注意：不管任何形式的串数据类型，串值都必须在引号内（通常单引号更好）；如果数值是计算中使用的数值，则应存储在数值数据类型列中，如果作为字符串使用（如电话号码、邮政编码）则应保存在串数据类型列中。 二、数值数据类型：存储数值，每种类型具有不同的存储范围，支持取值范围越大，所需存储空间越多。所有数值类型（除BIT和Boolean外）都可以有符号或无符号，有符号数据列可存储正或负的数值，默认情况为有符号。 类型说明 存储需求 取值范围 tinyint[(m)] 1字节 有符号值：-128 到127（- 2^7 到2^7 – 1）无符号值：0到255（0 到2^8 – 1） smallint[(m)] 2字节 有符号值：-32768 到32767（- 2^15 到2^15 – 1）无符号值：0到65535（0 到21 6 – 1） mediumint[(m)] 3字节 有符号值：-8388608 到8388607（- 2^23 到2^23 – 1 ）无符号值：0到16777215（0 到2^24 – 1） int[(m)] 4字节 有符号值：-2147683648 到2147683647（- 2^31 到2^31- 1）无符号值：0到4294967295（0 到2^32 – 1） bigint[(m)] 8字节 有符号值：-9223372036854775808 到9223373036854775807（- 2^63到2^63-1）无符号值：0到18446744073709551615（0到2^64 – 1） float[(m, d)] 4字节 最小非零值：±1.175494351e – 38 double[(m, d)] 8字节 最小非零值：±2.2250738585072014e – 308 decimal (m, d) m字节（mysql &lt; 3.23），m+2字节（mysql &gt; 3.23 ） 可变；其值的范围依赖于m 和d mysql提供了5种整型： tinyint、smallint、mediumint、int和bigint(字节数1、2、3、4、8)，这些类型在可表示的取值范围上是不同的。整数列可定义为unsigned从而禁用负值；这使列的取值范围为0以上。 mysql 提供三种浮点类型： float、double和decimal。与整型不同，浮点类型不能是unsigned的，其取值范围也与整型不同，这种不同不仅在于这些类型有最大值，而且还有最小非零值。最小值提供了相应类型精度的一种度量，这对于记录科学数据来说是非常重要的（当然，也有负的最大和最小值）。 在选择了某种数值类型时，应该考虑所要表示的值的范围，只需选择能覆盖要取值的范围的最小类型即可。选择较大类型会对空间造成浪费，使表不必要地增大，处理起来没有选择较小类型那样有效。对于整型值，如果数据取值范围较小，如人员年龄或兄弟姐妹数，则tinyint最合适。mediumint能够表示数百万的值并且可用于更多类型的值，但存储代价较大。bigint在全部整型中取值范围最大，而且需要的存储空间是表示范围次大的整型int类型的两倍，因此只在确实需要时才用。对于浮点值，double占用float的两倍空间。除非特别需要高精度或范围极大的值，一般应使用只用一半存储代价的float型来表示数据。 在定义整型列时，可以指定可选的显示尺寸m。如果这样，m应该是一个1 到255的整数。它表示用来显示列中值的字符数。例如，mediumint(4)指定了一个具有4个字符显示宽度的mediumint列。如果定义了一个没有明确宽度的整数列，将会自动分配给它一个缺省的宽度。缺省值为每种类型的”最长”值的长度。如果某个特定值的可打印表示需要不止m个字符，则显示完全的值；不会将值截断以适合m个字符。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。 对每种浮点类型，可指定一个最大的显示尺寸m 和小数位数d。m 的值应该取1 到255。d的值可为0 到3 0，但是不应大于m – 2（如果熟悉odbc 术语，就会知道m 和d 对应于odbc 概念的”精度”和”小数点位数”）。m和d对float和double 都是可选的，但对于decimal是必须的。在选项m 和d时，如果省略了它们，则使用缺省值。 三、日期和时间数据类型：MySQl中有多种表示日期和时间的数据类型。其中YEAR表示年份，DATE表示日期，TIME表示时间，DATETIME和TIMESTAMP表示日期和实践。具体如下表： 数据类型 存储字节数 取值范围 DATE 4 1000-01-01——9999-12-31 TIME 3 -838:59:59——838:59:59 DATETIME 8 1000-01-01 00:00:00——9999-12-31 23:59:59 TIMESTAMP 4 19700101080001——20380119111407 YEAR 1 1901——2155 当插入值超出有效取值范围时，系统会报错，并将零值插入到数据库中。 1.MySQL是以YYYY-MM-DD格式来显示DATE类型的值，插入数据时，数据可以保持这种格式。另外，MySQL还支持一些不严格的语法格式，分隔符”-“可以用”@”、”.”等符号来替代。 在插入数据时，也可以使用”YY-MM-DD”格式，YY转化成对应的年份的规则与YEAR类型类似。如果我们想插入当前系统的时间，则可以插入CURRENT_DATE或者NOW()。 2.TIME类型表示为”时：分：秒”，尽管小时范围一般是023，但是为了表示某些特殊时间间隔，MySQL将TIME的小时范围扩发了，而且支持负值。对TIME类型赋值，标准格式是’HH：MM：SS’，但不一定非要是这种格式。 如果插入的是’D HH：MM：SS’格式，则类似插入了’（D*24+HH）：MM：SS’。比如插入’2 23:50:50’，相当于插入了’71:50:50’。如果插入的是’HH：MM’或’SS’格式，则效果是其他未被表示位的值赋为零值。比如插入’30’，相当于插入了’00:00:30’；如果插入’11:25’，相当于插入了’11:25:00’。在MySQl中，对于’HHMMSS’格式，系统能够自动转化为标准格式。如果我们想插入当前系统的时间，则可以插入CURRENT_TIME或者NOW()。 3.DATETIME类型准格式为”YYYY-MM-DD HH：MM：SS”，具体赋值方法与上面的方法相似。 4.TIMESTAMP的取值范围比较小，没有DATETIME的取值范围大，因此输入值时一定要保证在TIMESTAMP的范围之内。它的插入也与插入其他日期和时间数据类型类似。那么TIMESTAMP类型如何插入当前时间？第一，可以使用CURRENT_TIMESTAMP；第二，输入NULL，系统自动输入当前的TIMESTAMP；第三，无任何输入，系统自动输入当前的TIMESTAMP。 另外有很特殊的一点：TIMESTAMP的数值是与时区相关。 5.给YEAR类型复制可以有三种方法： 第一种是直接插入4位字符串或者4位数字； 第二种是插入2位字符串，这种情况下如果插入’00’‘69’，则相当于插入20002069；如果插入’70’‘99’，则相当于插入1970~1999。第二种情况下插入的如果是’0’，则与插入’00’效果相同，都是表示2000年； 第三种是插入2位数字，它与第二种（插入两位字符串）不同之处仅在于：如果插入的是一位数字0，则表示的是0000，而不是2000年。所以在给YEAR类型赋值时，一定要分清0和’0’，虽然两者相差个引号，但实际效果确实相差了2000年。 四、枚举和集合类型枚举(ENUM)类型：最多可以定义65535种不同的字符串从中做出选择，只能并且必须选择其中一种，占用存储空间是一个或两个字节，由枚举值的数目决定； 集合(SET)类型：最多可以有64个成员，可以选择其中的零个到不限定的多个，占用存储空间是一个到八个字节，由集合可能的成员数目决定。 举个例子来说，在sql server(WINDOWS平台上强大的数据库平台)中，你可以节约到用一个BIT类型来表示性别(男&#x2F;女)，但MySQL(和PHP搭配之最佳组合)没有BIT，用TINTINT吗?不，可以用ENUM(’帅哥’,’美眉’)，只有两种选择，所以只需一个字节——跟TINYINT一样大，但却可以直接用字符串’帅哥’和’美眉’来存取。 五、二进制数据类型：二进制类型可存储任何数据，如文字、图像、多媒体等。具体类型描述如下： 数据类型 说明 TITYBLOB 最大长度为255字节 BLOB 最大长度为64KB MEDIUMBLOB 最大长度为16MB LONGBLOB 最大长度为4GB","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"安卓开发之Intent(Filter)用法详解","slug":"intent-of-the-android-development-filter-usage-details","date":"2015-04-27T03:43:44.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"intent-of-the-android-development-filter-usage-details.html","link":"","permalink":"https://baiyuan.wang/intent-of-the-android-development-filter-usage-details.html","excerpt":"","text":"一、Intent是什么,作用是什么?Android的应用程序包括三大组件：Activity、Service、BroadcastReceiver,为了方便不同组件之间的交流通信，应用程序就采用了一种统一的方式启动组件及传递数据，即使用Intent。 Intent封装了Android应用程序需要启动某个组件的”意图”，Intent类的对象是组件间的通信载体，一个Intent对象就是一组信息，其包含接收Intent组件所关心的信息（如action 和 Data）和Android 系统关心的信息(如Category等)。也就是说，发送”意图”的组件通过Intent对象所包含的内容，来启动指定的(即Component属性)或通过筛选(即Action&amp;Category属性)的某(些)组件，然后实施相应的动作（即Action属性）并传递相应的数据(即Data属性)以便完成相应的动作。 二、Intent的Component属性Component需要指定包名和类名唯一确定一个组件类，代码如下： intent&#x3D;new Intent();ComponentName com_name&#x3D;new ComponentName(MainActivity.this,Component.class);intent.setComponent(com_name); 展示结果的代码： super.onCreate(savedInstanceState);setContentView(R.layout.activity_component);ComponentName com_name&#x3D;getIntent().getComponent();TextView text&#x3D;(TextView)findViewById(R.id.textView1);text.setText(“组件包名：”+com_name.getPackageName()+”\\n组件类名：”+com_name.getClassName()); 运行截图： 点击第一个按钮显示运行结果： 三、Intent的Action、category属性使用Action和Category需要在程序清单文件androidMinifest.xml文件中进行配置，代码如下: 使用Action、category启动这个Activity的代码为： intent&#x3D;new Intent();intent.setAction(“cn.wangbaiyuan.task5.action”);intent.addCategory(“cn.wangbaiyuan.category_action”); 展示结果的代码： setContentView(R.layout.activity_component);TextView text&#x3D;(TextView)findViewById(R.id.textView1);text.setText(“此activity由含有action和category的intent启动\\nAction：”+getIntent().getAction()+”\\ncategory：”+getIntent().getCategories()); 截图： 四、Intent的Data、Type属性Data属性通常用于向Action属性提供操作的数据，Data属性接受一个Uri对象，一个Uri对象通过如下形式的字符串来表示： content:&#x2F;&#x2F;cn.wangbaiyuan.contacts&#x2F;contacts&#x2F;1 tel:1880000000 冒号前面指定了数据的类型，后面的是数据部分。 Type属性则用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。 一旦为Intent同时指定了Action和Data属性，那么Android将可根据指定的数据类型来启动特定的应用程序，并对指定的数据执行相应的操作。 在我的代码文件中我分别测试了5个用Activity和Data组合的情况，为五个按钮分别设置一下监听器： public OnClickListener scheme&#x3D;new OnClickListener() {@Overridepublic void onClick(View v) {&#x2F;&#x2F; TODO Auto-generated method stubIntent intent &#x3D; new Intent();&#x2F;&#x2F; 只设置Intent的Data属性intent.setData(Uri.parse(“lee:&#x2F;&#x2F;www.baidu.com:1234/test“));startActivity(intent);}};public OnClickListener schemeHostPort&#x3D;new OnClickListener() {@Overridepublic void onClick(View v) {&#x2F;&#x2F; TODO Auto-generated method stubIntent intent &#x3D; new Intent();&#x2F;&#x2F; 只设置Intent的Data属性intent.setData(Uri.parse(“lee:&#x2F;&#x2F;baiyuan.wang:8888&#x2F;test”));startActivity(intent);}};public OnClickListener schemeHostPath&#x3D;new OnClickListener() {@Overridepublic void onClick(View v) {&#x2F;&#x2F; TODO Auto-generated method stubIntent intent &#x3D; new Intent();&#x2F;&#x2F; 只设置Intent的Data属性intent.setData(Uri.parse(“lee:&#x2F;&#x2F;baiyuan.wang:1234&#x2F;android”));startActivity(intent);}};public OnClickListener schemeHostPortPath&#x3D;new OnClickListener() {@Overridepublic void onClick(View v) {&#x2F;&#x2F; TODO Auto-generated method stubIntent intent &#x3D; new Intent();&#x2F;&#x2F; 只设置Intent的Data属性intent.setData(Uri.parse(“lee:&#x2F;&#x2F;baiyuan.wang:8888&#x2F;android”));startActivity(intent);}};public OnClickListener schemeHostPortPathType&#x3D;new OnClickListener() {@Overridepublic void onClick(View v) {&#x2F;&#x2F; TODO Auto-generated method stubIntent intent &#x3D; new Intent();&#x2F;&#x2F; 同时设置Intent的Data、Type属性intent.setDataAndType(Uri.parse(“lee:&#x2F;&#x2F;baiyuan.wang:8888&#x2F;android”), “abc&#x2F;xyz”);startActivity(intent);}};public OnClickListener systemActivity&#x3D;new OnClickListener() {@Overridepublic void onClick(View v) {&#x2F;&#x2F; TODO Auto-generated method stubIntent intent &#x3D; new Intent();&#x2F;&#x2F; 同时设置Intent的Data、Type属性intent.setData(Uri.parse(“http://baiyuan.wang“));startActivity(intent);}}; 运行截图： 五、Intent创建tab页面：代码： @Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.tab);TabHost tabhost&#x3D;getTabHost();tabhost.addTab(tabhost.newTabSpec(“tab1”).setIndicator(“IT业界”,getResources().getDrawable(R.drawable.ic_launcher)).setContent(new Intent(this,webview.class).putExtra(“url”, “http://baiyuan.wang/itindustry“))); tabhost.addTab(tabhost.newTabSpec(“tab2”).setIndicator(“程序算法”).setContent(new Intent(this,webview.class).putExtra(“url”, “http://baiyuan.wang/code“))); tabhost.addTab(tabhost.newTabSpec(“tab3”).setIndicator(“电脑技巧”).setContent(new Intent(this,webview.class).putExtra(“url”, “http://baiyuan.wang/computer-experience“)));tabhost.addTab(tabhost.newTabSpec(“tab3”).setIndicator(“关于我”).setContent(new Intent(this,webview.class).putExtra(“url”, “http://baiyuan.wang/leave-message/about“)));} 运行结果： 代码下载","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"}]},{"title":"看了prezi你才会知道PPT有多弱","slug":"prezi-that-youll-know-how-much-ppt-weak","date":"2015-04-24T13:10:54.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"prezi-that-youll-know-how-much-ppt-weak.html","link":"","permalink":"https://baiyuan.wang/prezi-that-youll-know-how-much-ppt-weak.html","excerpt":"","text":"概括的来说，prezi是一款在线的演讲文稿生成软件。最大的优点可以用几个词概括：缩放，旋转，无边界，在线编辑，实时保存，简单易用，当然还有免费。 除了做演示文稿之外，还可以用来做笔记及思维导图（辅助记忆的工具）等等。缩放可以用来使观众的注意力集中到整体到局部，并且做出电影镜头的效果。旋转可以让观众感受画面的跳跃感，使演讲生动有趣。无边界是相较Powerpoint而言的，所以输入内容的时候再也不必担心会超出边框。在线编辑使多个用户可以在同一个prezi上进行创作（和现在其他的云端软件相似）。在线的实时保存让你不必担心资料丢失。简单易用，相对于Powerpoint来说，Prezi更加简单，大部分人都可以在一小时内学会基本的操作。拖拽移动物体方便，不需要借助文本框（当然输入的时候还是需要的） 今天极客人下载了prezi并使用了一下，被prezi强大的演示功能所震撼。使用prezi做的演示文稿，如同进入一幅画，欣赏它如同身临一个场景，在立体的空间中展示自己的内容，上面是我的演示效果。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PPT","slug":"PPT","permalink":"https://baiyuan.wang/tags/PPT/"}]},{"title":"依托虚拟主机为APP提供软件更新服务（二）","slug":"virtual-hosts-provide-app-update-services-b","date":"2015-04-22T07:11:08.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"virtual-hosts-provide-app-update-services-b.html","link":"","permalink":"https://baiyuan.wang/virtual-hosts-provide-app-update-services-b.html","excerpt":"","text":"在上一篇博文中，我向大家介绍了依托虚拟主机为自制APP提供软件更新服务的第一节，向大家介绍了用PHP做软件更新信息API的具体过程，在上节我成功利用自己的虚拟主机建立了自己的API，通过URL传入ID值，获取了软件信息的JSON字符如下： [callout class&#x3D;”info” title&#x3D;”使用PHP制作的API”]{“sw_id”:”1”,”sw_name”:”BY通讯录”,”sw_version”:”1.2”,”sw_url”:”http://baiyuan.wang/api/software/Contactss\\_1\\_2.apk&quot;,&quot;sw_description“:” 1.BY通讯录，是王柏元自主开发的APP，作安卓开发入门试验之用；\\n 2.调用在自己虚拟主机上的数据库搭建的API，实现了版本更新功能；\\n 3.使用一些新的安卓技术。”}[&#x2F;callout] 接下来，我以安卓为例向大家介绍在安卓开发中调用API并实现软件的检测更新、更新提示、下载更新、安装更新的系列过程。 依托虚拟主机为自制APP提供软件更新服务（二）——安卓解析JSON、实现软件更新、自动安装 一、获取网络JSON数据的工具类下面是结合网上代码实现的一个联网获取JSON数据的工具类，类名为：HttpUtils，下面的代码我将在文章后面提供下载链接。 package cn.wangbaiyuan.http;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL; import android.util.Log;import android.widget.Toast; &#x2F;*** @author 王柏元**&#x2F; public class HttpUtils { public HttpUtils() {&#x2F;&#x2F; TODO Auto-generated constructor stub} &#x2F;*** @param url_path json的URL* @return*&#x2F;public static String getJsonContent(String url_path){ String jsonString &#x3D; “”;try {URL url &#x3D; new URL(url_path);HttpURLConnection connection &#x3D; (HttpURLConnection)url.openConnection();connection.setRequestMethod(“GET”);connection.setConnectTimeout(3000);connection.setDoInput(true); &#x2F;&#x2F;从服务器获得数据connection.connect();int responseCode &#x3D; connection.getResponseCode();Log.d(“log_tag”,responseCode+””);if (200 &#x3D;&#x3D; responseCode) {jsonString &#x3D; changeInputStream(connection.getInputStream()); }&#x2F;&#x2F; else{&#x2F;&#x2F; jsonString &#x3D; responseCode+””;&#x2F;&#x2F; } } catch (Exception e) {Log.d(“log_tag”,e.toString());jsonString &#x3D;”获取服务器信息出错”;&#x2F;&#x2F; TODO: handle exception} &#x2F;&#x2F;return jsonString;} private static String changeInputStream(InputStream inputStream){&#x2F;&#x2F; TODO Auto-generated method stubString jsonString &#x3D;””; ByteArrayOutputStream outputStream &#x3D; new ByteArrayOutputStream();byte[] data &#x3D; new byte[1024];int len &#x3D; 0;try {while((len&#x3D;inputStream.read(data))!&#x3D;-1){outputStream.write(data, 0, len);}} catch (IOException e) {&#x2F;&#x2F; TODO Auto-generated catch blocke.printStackTrace();} jsonString &#x3D; new String(outputStream.toByteArray());return jsonString;} } 在上面的代码中，getJsonContent函数的参数为url_path，返回值为String，实现了连接网络、并获取对应URL的JSON数据的功能。getJsonContent函数是HttpUtils类的一个静态方法，你只需要在任意项目引入这个文件，使用HttpUtils.getJsonContent(API的网址)来获取网络上API的数据。 二、在安卓代码中使用getJsonContent(API的网址)获取数据并解析在任意项目引入上述文件HttpUtils.java，使用HttpUtils.getJsonContent(API的网址)来获取网络上API的数据，这个过程需要新建一个线程，不然程序会在联网时受到阻塞，停止运行，线程里面的代码如下： Runnable checkupdate &#x3D; new Runnable(){ @Overridepublic void run() {String url_path &#x3D; “http://baiyuan.wang/api/update.php?id=1“; String jsonString &#x3D; HttpUtils.getJsonContent(url_path); try {JSONObject Json&#x3D;new JSONObject(jsonString);&#x2F;&#x2F;根据API内容实例化一个JSONObject 对象sw_version&#x3D;Json.getString(“sw_version”);&#x2F;&#x2F;获取JSONObject 的键“sw_version”对应的值；version_des&#x3D;Json.getString(“sw_description”);&#x2F;&#x2F;获取JSONObject 的键“sw_description”对应的值； download_url&#x3D;Json.getString(“sw_url”);&#x2F;&#x2F;获取JSONObject 的键“sw_url”对应的值； } catch (JSONException e) {&#x2F;&#x2F; TODO Auto-generated catch blocke.printStackTrace();Log.e(“log_tag”,e.toString());}hander.sendEmptyMessage(0x123);} }; 通过上述代码我获取了软件的版本号、版本描述、版本下载地址。 三、安卓开发获取软件版本号要想实现版本更新，肯定要把网络上发布的最新版本和正在使用的版本号进行比较，所以需要获取当前软件的版本号，实现代码如下： PackageManager packageManager &#x3D; getPackageManager();&#x2F;&#x2F; getPackageName()是你当前类的包名，0代表是获取版本信息PackageInfo packInfo &#x3D; packageManager.getPackageInfo(getPackageName(),0);ApplicationInfo applicationInfo &#x3D; packageManager.getApplicationInfo(getPackageName(), 0);current_version &#x3D; packInfo.versionName;&#x2F;&#x2F;获取当前版本String applicationName &#x3D; (String) packageManager.getApplicationLabel(applicationInfo);version_label.setText(applicationName+current_version);&#x2F;&#x2F;让界面上一个textview显示版本号 四、比较版本号判断是否选择更新；获取当前使用的版本号后，需要对最新版本和正在使用的版本号进行比较，比较代码如下： Double latest_Version&#x3D;Double.parseDouble(sw_version);if(Double.parseDouble(current_version)&lt;latest_Version){ &#x2F;&#x2F;如果版本有更新怎么办？添加版本有更新时的代码}elseToast.makeText(about.this, “当前是最新版本”, 5).show(); 五、版本有更新时弹出版本更新提示框AlertDialog.Builder builder&#x3D;new AlertDialog.Builder(about.this).setTitle(“版本更新”).setMessage(version_des);&#x2F;&#x2F;版本更新说明builder.setPositiveButton(“下载更新”, download_listener);&#x2F;&#x2F;设置按钮“下载更新”点击的监听器builder.setNegativeButton(“以后再说”, null);builder.create();builder.show(); 六、处理下载更新：下载软件并自动执行安装&#x2F;&#x2F;打开到url的连接 OnClickListener download_listener &#x3D;new OnClickListener() { @Overridepublic void onClick(DialogInterface dialog, int which) {new Thread(download).start();Toast.makeText(about.this, “开始下载……”, Toast.LENGTH_LONG).show();}};Runnable download &#x3D; new Runnable(){ @Overridepublic void run() {String sdcard&#x3D;Environment.getExternalStorageDirectory()+”&#x2F;“;String filepath&#x3D;sdcard+”BYContacts&#x2F;“;&#x2F;&#x2F;新安装包会下载到 “内存卡\\BYContacts”文件夹下 download_url&#x3D;(download_url.startsWith(“http:&#x2F;&#x2F;“))?download_url:”http:&#x2F;&#x2F;“+download_url;try {URL url &#x3D; new URL(download_url);&#x2F;&#x2F;打开到url的连接HttpURLConnection connection &#x3D; (HttpURLConnection)url.openConnection();&#x2F;&#x2F;以下为java IO部分，大体来说就是先检查文件夹是否存在，不存在则创建,然后的文件名重复问题，没有考虑InputStream istream&#x3D;connection.getInputStream();String filename&#x3D;download_url.substring(download_url.lastIndexOf(“&#x2F;“)+1); File dir&#x3D;new File(filepath);if (!dir.exists()) {dir.mkdir();}File file&#x3D;new File(filepath+filename);file.createNewFile(); OutputStream output&#x3D;new FileOutputStream(file);byte[] buff &#x3D; new byte[1024];int hasRead &#x3D; 0;&#x2F;&#x2F; 将URL对应的资源下载到本地while((hasRead &#x3D; istream.read(buff)) &gt; 0){output.write(buff, 0 , hasRead);}output.flush();output.close();istream.close();hander.sendEmptyMessage(012);Log.e(“log_tag”,file.toString()); openFile(file);&#x2F;&#x2F;打开安装包} catch (Exception e) {Log.e(“log_tag”,”下载错误”+e.toString());e.printStackTrace();}}}; 七、下载完毕执行自动安装函数openFile(File file)的代码private void openFile(File file) {Log.e(“OpenFile”, file.getName());Intent intent &#x3D; new Intent();intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setAction(android.content.Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(file),“application&#x2F;vnd.android.package-archive”);startActivity(intent);} 此函数的作用打开下载好的安装包，进入安装过程。 八、源码下载","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"json","slug":"json","permalink":"https://baiyuan.wang/tags/json/"},{"name":"虚拟主机","slug":"虚拟主机","permalink":"https://baiyuan.wang/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"}]},{"title":"依托虚拟主机为自制APP提供软件更新服务（一）","slug":"virtual-hosts-provide-app-update-services-a","date":"2015-04-21T15:09:47.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"virtual-hosts-provide-app-update-services-a.html","link":"","permalink":"https://baiyuan.wang/virtual-hosts-provide-app-update-services-a.html","excerpt":"","text":"学了一个月的安卓，写了几个小程序，总是觉得缺少点什么。看到一般市场上的软件都提供软件更新服务，极客人想自己也有个虚拟主机，是不是可以自己搭建一个软件更新服务器呢？百度了一下“依托虚拟主机为自制APP提供软件更新服务”，可惜找遍整个百度也没找到解决方案，所以一穷二白，自己干。 要想实现软件更新，肯定有个服务器端发布的最新软件版本号与用户端当前使用的版本进行比对。如果版本号相同，则提示用户“当前为最新版本”；如果服务器上发布的最新版本高于用户使用的，则提示“版本更新”，并提供下载功能，下载完毕之后自动执行安装。要想获取最新版本号，必须读取数据库，如果直接用用户加密码的方式直接连接数据库的话，这无疑不安全，因为如果反编译或者破解了你的软件，你的数据库将会任人宰割。所以，我想到的解决方案是，自己在服务器端利用PHP做一个API，使用API请求的方法获取最新版本号和版本描述及下载地址。在奋斗几个星期后，下面是我的具体实现步骤： 依托虚拟主机为自制APP提供软件更新服务（一）——使用PHP制作API1.新建软件数据库表，添加软件ID、版本号、下载地址、版本描述等列；SQL语句如下： CREATE TABLE `my_software` ( `sw_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `sw_name` varchar(255) CHARACTER SET gbk NOT NULL DEFAULT ‘’, `sw_version` varchar(20) CHARACTER SET gbk NOT NULL DEFAULT ‘’, `sw_url` varchar(255) CHARACTER SET gbk NOT NULL DEFAULT ‘’, `sw_description` varchar(255) CHARACTER SET gbk NOT NULL DEFAULT ‘’, PRIMARY KEY (`sw_id`), KEY `sw_version` (`sw_version`)) ENGINE&#x3D;MyISAM AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8; 建立的数据库表名为：mysoftware,结构如图： 2.PHP调用数据库返回JSON格式字符串我在自己的虚拟主机根目录新建了命名为“api”文件夹，在“api”文件夹下建立两个php文件：update.php和db_connect.php。 其中db_connect.php是连接数据库的PHP文件，里面记录了连接数据库的数据库名、用户名、主机、密码、编码格式，代码如下： 你可以访问该PHP的URL测试改文件是否正确。 update.php是返回JSON字符串的PHP文件。它的作用是调取软件数据库表内的内容，并通过GET方法返回数据。 其代码如下： $value){ $array\\[$key\\]=urlencode($value); } //用urldecode将值反解 return urldecode(json_encode($array)); } ?> 在这个文件里，通过”http://baiyuan.wang/api/update.php?id=1”GET方式接受传值，然后调用了db_connect.php文件连接的数据库，执行$string &#x3D; “select * from my_software where sw_id&#x3D;”.$id;语句，然后对结果进行解析返回标准的JSON格式字符串。其中jsons_encode函数你可以参考我之前的一篇文章：PHP用json_encode转换数组中文乱码进行理解； 下面我制作成功后访问http://baiyuan.wang/api/update.php?id=1的网页内容： [callout class&#x3D;”info” title&#x3D;”使用PHP制作的API”]{“sw_id”:”1”,”sw_name”:”BY通讯录”,”sw_version”:”1.2”,”sw_url”:”http://baiyuan.wang/api/software/Contactss\\_1\\_2.apk&quot;,&quot;sw_description“:” 1.BY通讯录，是王柏元自主开发的APP，作安卓开发入门试验之用；\\n 2.调用在自己虚拟主机上的数据库搭建的API，实现了版本更新功能；\\n 3.使用一些新的安卓技术。”}[&#x2F;callout] 看到这段字符串你可能大脑就会兴奋了，你可能能想到下面就是根据不同平台对JSON数据进行解析的工作了 依托虚拟主机为自制APP提供软件更新服务（二）——安卓解析API数据在下一节我将通过安卓示例，向大家讲解对JSON数据进行解析为自制APP提供软件更新服务，查看下一节。 代码下载","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"虚拟主机","slug":"虚拟主机","permalink":"https://baiyuan.wang/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"}]},{"title":"0.5M安装包，最小浏览器颠覆你的IT观","slug":"0-5m-install-package-the-smallest-browser-to-change-your-view-of-it","date":"2015-04-19T12:02:34.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"0-5m-install-package-the-smallest-browser-to-change-your-view-of-it.html","link":"","permalink":"https://baiyuan.wang/0-5m-install-package-the-smallest-browser-to-change-your-view-of-it.html","excerpt":"","text":"”浏览器，一点就够了“ 这是我使用一点浏览器发自内心的感叹（回头想一想，我觉得这句话可以投稿给一点浏览器做绝佳广告词了）。 一点浏览器是搜狗于2015年3月23日推出全新产品，其安装包仅有约0.5M(相当于一张图片)大小，号称全球最小的浏览器软件，并且独家推出“右键快速关闭网页”功能。 其实一点浏览器在上月23号发布的时候我就在新闻上有耳闻，当时还不以为意，想想0.5M的安装包，它的功能必定有限，可能只是搜狗的噱头罢了。最近使用了一下QQ浏览器，它是IE内核的，安装包4M多，这样的大小已足以令人惊讶了。后来由于在QQ中链接总是会在QQ浏览器打开，而QQ浏览器我是不常用的，也不是默认的浏览器，所以每打开一个QQ中链接，QQ浏览器都跑出来。后来，腻了，烦了，于是就放手了。这时想起来之前听说的一点浏览器，于是就下载试用一下。不用则已，用了彻底颠覆了自己的IT观。 虽然安装包大小只有565KB，还不到一张普通手机照片一半的大小，但是一点浏览器的浏览器功能一应俱全：浏览网页、观看视频、下载管理、历史记录、网页收藏；该有的都有。 一点浏览器UI 一点浏览UI-历史记录 一点浏览器UI-关于 一点浏览器的内核也是IE，但是它的启动速度和网页打开流畅度远远超过了我电脑上装的IE11浏览器，而且UI清新简洁、窗口动效做得也相当棒。虽说IE浏览器的流畅度广受诟病，但是有时候考虑到网页兼容性问题我们不得不把它当做备用浏览器。所以，我们不妨用一点浏览器将IE替换掉。（替换掉不等于卸掉，极客人认为一点浏览器应该是调用了IE的内核，而非原生集成，卸载请谨慎） 我为什么要写这篇文章写这篇文章的目的，绝不是我拿了搜狗的好处，给它写软文的。而是想抒发一下我对当今互联网产品模式的一种思索。 无疑，互联网产品现在做的是越来越复杂、越来越功能强大、越来越精美，QQ、微信、超级课程表等等，它们一个个更新频繁，一方面是为了提升自己产品的品质，一方面越是想加入更多的广告。以QQ为例，以前的QQ仅仅可以聊天，现在却加入各种吃喝玩乐、个性装扮、网上营业厅，QQ空间还经常强制加广告，当然同时QQ新增了许多如手机下载文件、匿名、语音、群组电话等很有必要的功能。 更明显的是人人，这款主打校园社交的APP，一度风靡全国大学校园，现在也沦为广告泛滥的重灾区，极客人因为这果断把人人放手。 现在我们使用的软件大部分是免费的，毋庸置疑，在免费的互联网产品中植入广告是很有必要，我也很讨厌广告，但是我却也在自己的博客中加入广告弄点外快，这是个矛盾的共同体。我想QQ、人人也是如此。因为广告，我把人人抛弃，我想很多人和我一样，这必定会导致人人市场失守。 用户体验，产品利润，在互联网市场纠结斗争。水火不容的两者，是否真的找不到统一的存在呢？ 为了用户粘度，QQ推出了轻聊版，人人推出了人人mini版，这些良心的产品没有广告、功能简洁，这无疑会挽回不少用户。在百度手机助手中显示， 截止到我发文章这个时候，QQ轻聊版拥有4180万的下载量，人人mini版的下载量甚至高达到1亿！ 互联网产品免费，但是互联网公司也并不是慈善公司，在竞争激烈、用户量为王的互联网时代，谁抓住了客户，就拥有了一切。在广告与用户的抉择中，互联网公司迫于无奈，推出了一系列QQ轻聊版版、人人mini、一点浏览器等看似良心的产品。而背后，是竞争激烈的互联网界角逐之战！","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"UA","slug":"UA","permalink":"https://baiyuan.wang/tags/UA/"},{"name":"浏览器","slug":"浏览器","permalink":"https://baiyuan.wang/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"0.5M installation package, minimal browser subvert your IT view","slug":"en/0-5m-install-package-the-smallest-browser-to-change-your-view-of-it-2","date":"2015-04-19T12:02:34.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"en/0-5m-install-package-the-smallest-browser-to-change-your-view-of-it-2.html","link":"","permalink":"https://baiyuan.wang/en/0-5m-install-package-the-smallest-browser-to-change-your-view-of-it-2.html","excerpt":"","text":"“Browser, one point is enough” This is my heartfelt sigh with a bit of a browser (I think this sentence can be submitted to a bit of a browser as a great advertisement). A bit of a browser is Sogou launched a new product on March 23, 2015. Its installation package is only about 0.5M (equivalent to a picture) in size, known as the world’s smallest browser software, and the exclusive launch of “right-click to close the webpage quickly.” Features. In fact, when the browser was released on the 23rd of last month, I heard about it in the news. At that time, I didn’t think about it. I thought about the 0.5M installation package. Its function is bound to be limited, and it may just be Sogou’s gimmick.Recently used QQ browser, it is IE kernel, more than 4M installation package, this size is enough to be amazing.Later, because in the QQ link will always open in the QQ browser, and QQ browser I is not commonly used, nor is it the default browser, so each open a QQ link, QQ browser are out.Later, tired, tired, and then let go.At this point I remembered a bit of the browser I heard before, so I downloaded it and tried it out.No need to use it, completely subverted their own view of IT. Although the size of the installation package is only 565KB, which is less than half the size of an ordinary mobile phone photo, the browser functionality of a bit of browser is readily available: browsing the web, watching videos, download management, historical records, and webpage collections; Have. Bit Browser UI A bit of browsing UI-history [&#x2F; Caption] [caption id&#x3D;”” align&#x3D;”aligncenter” width&#x3D;”644”] Bit Browser UI - About A bit of the browser’s kernel is also IE, but its startup speed and web page fluency far exceeds The IE11 browser installed on my computer, and the UI is clean and simple, the window animation is also very good.Although the IE browser’s fluency is widely criticized, sometimes we have to consider it as a backup browser in consideration of web compatibility issues.So, we might as well use a bit of browser to replace IE.(Replacement is not equal to uninstall. Extreme visitors think that a bit of the browser should be called the IE kernel, rather than native integration, uninstall carefully.) Why do I write this articleThe purpose of writing this article is by no means taking the benefit of Sogou and writing soft papers for it.Instead, I want to express my thoughts on today’s Internet product model. Undoubtedly, Internet products are now becoming more and more complex, more and more powerful, more and more exquisite, QQ, WeChat, super curriculum, etc. They are frequently updated one by one, on the one hand, in order to enhance the quality of their products, On the one hand, he wants to add more advertisements.Taking QQ as an example, the former QQ can only chat, but now it has joined various kinds of food and drink, personalized dress, online business, QQ space is often mandatory to add advertising, of course, while QQ has added many files such as mobile phone download, anonymous, voice , group calls, and other necessary functions. What is more obvious is everyone. This APP, which focuses on campus social networking, once swept the university campus of the nation, and it is now becoming a heavily-disastered area for advertising. Extreme guests have decided to let everyone down. Most of the software we use today is free. Undoubtedly, it is necessary to place ads in free internet products. I also hate advertising, but I also add ads to my blog to get extra money. It is a contradictory community.I think QQ, everyone is the same.Because of advertising, I have abandoned everyone. I think many people are just like me. This will certainly lead to a fall in the market for everyone. User experience, product profits, struggles in the Internet market.Is it really impossible to find a unified existence between the two? For the user’s viscosity, QQ launched a light chat version, everyone launched a mini version of everyone, these conscience products do not have advertising, features simple, which will undoubtedly restore many users.In the Baidu mobile assistant’s display, as of the time when I made an article, the QQ chat version has a download volume of 41.8 million, and the download volume of everyone’s mini version has even reached 100 million! Internet products are free, but Internet companies are not charitable companies. In the Internet era where competition is fierce and users are king, whoever seizes customers has everything.In the choice of advertising and users, Internet companies are forced to launch a series of products that seem to be conscience such as the QQ version, everyone’s mini, and browsers.Behind it is the fierce competition in the Internet world!","categories":[{"name":"Geek Viewpoint","slug":"Geek-Viewpoint","permalink":"https://baiyuan.wang/categories/Geek-Viewpoint/"}],"tags":[]},{"title":"wordpress怎样写robots.txt利于SEO优化","slug":"wordpress-how-to-write-a-robots-txt-to-seo-optimization","date":"2015-04-19T03:26:05.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"wordpress-how-to-write-a-robots-txt-to-seo-optimization.html","link":"","permalink":"https://baiyuan.wang/wordpress-how-to-write-a-robots-txt-to-seo-optimization.html","excerpt":"","text":"一般来说,我们希望搜索蜘蛛光顾我们的网站越多越好,我相信每个新手站长都会是站长工具的常客,一大早起来就是关注自己网站的收录量.收录量的增长是一张晴雨表,升则忧、降则喜，我想告诉广大的站长朋友这完全没有必要，收录量不是目的，我觉得我们关注的重点应该是怎样让自己的网站拥有更多的百度搜索流量。 robots.txt是搜索引擎爬行网站的控制文件，按照一定的语法告诉搜索引擎哪些网页能爬，哪些不能爬，对于robots.txtd的介绍和书写语法，你可以参考这篇博文：网络蜘蛛访问控制文件robot.txt的写法 。 可能你想说，收录量不是越多越好吗？ 其实不然，网站的网页不是收录越多越好，大家都知道搜索引擎比较网络上的网页相似度（相似度太高的两个页面会分散权重）的时候，不仅仅会进行不同网站间的纵向比较，而且会进行同一网站不同页面间的比较，所以，比如对于个人博客的作者归档和首页，页面内容差不多一样，我们完全可以屏蔽蜘蛛访问作者归档的页面。下面我来详细地介绍一下wordpress怎样写robots.txt利于SEO优化。 wordpress怎样写robots.txt利于SEO优化 一、屏蔽没有必要收录的一些链接1、屏蔽捉取站内搜索结果Disallow： ?s&#x3D;* 这个就不用解释了，屏蔽捉取站内搜索结果。站内没出现这些链接不代表站外没有，如果收录了会造成和TAG等页面的内容相近。 2、屏蔽spider捉取程序文件Disallow： &#x2F;wp-*&#x2F; 屏蔽spider捉取程序文件，wp-*表示wp-admin,wp-include等文件夹都不让搜索蜘蛛爬行，这节约了搜索引擎蜘蛛资源。 3、屏蔽feedDisallow: &#x2F;feed&#x2F;* Disallow: &#x2F;&#x2F;&#x2F;feed&#x2F;* Disallow: &#x2F;&#x2F;&#x2F;&#x2F;feed&#x2F; 头部代码里的feed链接主要是提示浏览器用户可以订阅本站，而一般的站点都有RSS输出和网站地图，故屏蔽搜索引擎抓取这些链接，相当有必要，应为feed里面的内容基本就是你文章内容的重复，相同内容会让百度降低单页面权重，同时这也节约蜘蛛资源和服务器的压力。 4、屏蔽捉取留言信息链接Disallow:&#x2F;?replytocom Disallow: &#x2F;comments&#x2F; Disallow: &#x2F;*&#x2F;comments&#x2F; 屏蔽留言信息链接。需要指出的是，屏蔽留言信息链接不是说不让蜘蛛收录你文章的评论页面，而是这样的链接打开后，整个页面就只有一个评论，完全没有被收录的必要，同时也节约蜘蛛资源，故屏蔽之。 5、屏蔽其他的一些链接，避免造成重复内容和隐私问题Disallow： &#x2F;date&#x2F; Disallow： &#x2F;author&#x2F; Disallow： &#x2F;category&#x2F; Disallow： &#x2F;?p&#x3D;&amp;preview&#x3D;true Disallow： &#x2F;?page_id&#x3D;&amp;preview&#x3D;true Disallow： &#x2F;wp-login.php 这些屏蔽规则你可以根据自己的需求决定是否创建，屏蔽data、author、category等页面都是为了避免太多重复内容， 6、Disallow： &#x2F;?p&#x3D;*屏蔽捉取短链接。默认头部里的短链接，百度等搜索引擎蜘蛛会试图捉取，虽然最终短链接会301重定向到固定链接，但这样依然造成蜘蛛资源的浪费。 7.屏蔽特定格式Disallow: &#x2F;.js$ Disallow: &#x2F;.css$ 屏蔽对js、css格式文件的抓取，节约蜘蛛资源，降低服务器压力，你可以根据实际要求是否屏蔽你的图片被抓取。 8.其它不想被抓取的页面Disallow: &#x2F;?connect&#x3D; Disallow: &#x2F;kod&#x2F;* Disallow: &#x2F;api&#x2F;* &#x2F;*?connect&#x3D;*：我的博客登录链接 &#x2F;kod&#x2F;*：在线文件管理链接 &#x2F;api&#x2F;*：我自制的API链接 二、使用robots.txt需要注意的几点地方： 1、有独立User-agent的规则，会排除在通配“*”User agent的规则之外; 2、指令区分大小写，忽略未知指令，下图是本博客的robots.txt文件在Google管理员工具里的测试结果; 3、“#”号后的字符参数会被忽略; 4、可以写入sitemap文件的链接，方便搜索引擎蜘蛛爬行整站内容。 5、每一行代表一个指令，空白和隔行会被忽略; 6、尽量少用Allow指令，因为不同的搜索引擎对不同位置的Allow指令会有不同看待。 上面的这些Disallow指令都不是强制要求的，可以按需写入。也建议站点开通百度站长工具，检查站点的robots.txt是否规范。 三、百度站长工具robots.txt工具的使用方法百度站长工具robots.txt工具网址：http://zhanzhang.baidu.com/robots/index 百度站长工具robots.txt工具的使用方法 检测并更新：在文本框里输入网站点击检测并更新，百度将抓取你的robots.txt文件，如果你近期robots.txt最近有更新，这将马上通知百度搜索蜘蛛更新它的爬行规则，使你修改后的robots.txt马上生效。 规则校验：你可以提取自己的robots.txt，然后验证一下你的robots.txt语法是否正确，检验你想要禁止蜘蛛爬行的网址是否能有效屏蔽； 创建生成：根据你的需求，傻瓜式地生成robots.txt，对于站长小白不妨一试。 附录王柏元的博客robots.txt分享如下： User-agent: *Disallow: &#x2F;wp-&#x2F;Disallow: &#x2F;?connect&#x3D;*Disallow: &#x2F;date&#x2F;*Disallow: &#x2F;kod&#x2F;*Disallow: &#x2F;api&#x2F;*Disallow: &#x2F;&#x2F;trackbackDisallow: &#x2F;.js$Disallow: &#x2F;.css$Disallow:&#x2F;?replytocom*Disallow: &#x2F;comments&#x2F;Disallow: &#x2F;&#x2F;comments&#x2F;Disallow: &#x2F;feed&#x2F;Disallow: &#x2F;&#x2F;&#x2F;feed&#x2F;*Disallow: &#x2F;&#x2F;&#x2F;&#x2F;feed&#x2F;Disallow:&#x2F;articles&#x2F;*Disallow:&#x2F;shuoshuo&#x2F;*Sitemap: http://baiyuan.wang/sitemap_index.xml","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"robots.txt","slug":"robots-txt","permalink":"https://baiyuan.wang/tags/robots-txt/"}]},{"title":"怎样在手机中管理、收发公众号消息","slug":"how-to-manage-send-and-receive-in-the-phone-number-of-the-public-news","date":"2015-04-17T13:24:25.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-manage-send-and-receive-in-the-phone-number-of-the-public-news.html","link":"","permalink":"https://baiyuan.wang/how-to-manage-send-and-receive-in-the-phone-number-of-the-public-news.html","excerpt":"","text":"极客人最近为王柏元的博客制作了自己的微信公众号，这个公众号旨在将移动终端用户在手机上的所有操作，化繁为简，集中在一个微信公众号里，免去用户安装过多移动APP，比如天气查询、查询单词、百科、图片搜索、火车飞机票的查询，这里极客人就不赘述了，感兴趣的朋友可以访问：http://weixin.baiyuan.wang扫码关注一下我的公众号——“极客中心”；虽然微信一直专注于移动终端上（比如电脑上登录必须手机扫码，移动端登录必须手机短信验证，都可以看出腾讯把微信的终端定位是放在移动终端上的）,但是目前腾讯却不能为公众号管理者提供能在手机上管理公众号的平台。在手机浏览器访问电脑网页，然后在网页上管理图文消息、收发粉丝信息，这的确有点鸡肋。 相信很多公众号管理者都和我有同样的苦恼，在此，我向大家介绍一下怎样在手机上管理、收发公众号消息： 手机端管理公众号、收发粉丝私信微信虽然没有为用户提供良好移动端管理环境，但是第三方的微信管理平台早已坐不住了。所以官方没有，我们不妨使用第三方平台管理。在此向大家介绍一款手机管理公众号APP：公众平台助手。大家可以在各大移动商店搜索下载。 这款APP是第三方开发，虽然有安全认证，但是不是腾讯的亲儿子，有没有后门不得而知，大家可酌而后行之。 这是消息列表： 这是用户管理： 怎样在手机中管理、收发公众号消息 当然还可以修改备注、发消息，这里极客人就不做赘述了，大家一用便知； 不过公众平台助手不提供群发图文的功能，所以接下来的经验就是解决这一问题的。 微信关注“公众号安全助手”，手机随时随地群发公众号消息怎么关注公众号就不用我多说了，公众号安全助手是微信官方的公众号，使用起来安全也很方便，你需要为自己的公众号绑定管理员微信号，然后这个管理员微信号给“公众号安全助手”的所有消息，都会方便地群发给订阅用户。 怎样在手机中管理、收发公众号消息 更多IT经验、公众号运营经验，请访问：http://weixin.baiyuan.wang扫码关注一下我的公众号——“极客中心”。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"eclipse安卓使用activity模板快速新建activity","slug":"eclipse-android-using-the-activity-template-to-quickly-create-a-new-activity","date":"2015-04-14T06:42:00.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"eclipse-android-using-the-activity-template-to-quickly-create-a-new-activity.html","link":"","permalink":"https://baiyuan.wang/eclipse-android-using-the-activity-template-to-quickly-create-a-new-activity.html","excerpt":"","text":"使用android studio的安卓开发者可能发现它和eclipse+ADT大同小异,个人用完android studio之后发现android studio 除了界面比较炫酷以外,并没有多少优点.而且最被广大使用者诟病的内存占用大问题也没有解决:笔者发现,android studio比eclipse在开发安卓的时候更加占用内存,卡得不行. 不过,android studio在文件—新建的菜单中，可以快速新建Activity的功能相当实用，如图： android studio的新建activity功能就不用每次让我们很麻烦地建一个java类然后继承Activity了，Activity的几个必要的方法自动为我们声明了。 实际上，eclipse也有这样的功能： eclipse安卓使用activity模板快速新建activityeclipse的新建菜单里面其实也有快速新建Activity的功能，只是没有放在醒目的位置： 快速新建activity几种方法： ①分别打开菜单FILE——NEW——other——Android——Activity； ②Ctrl+N——Android——Activity； 用新建activity的方法也可以快速新建安卓图片资源文件","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"eclipse","slug":"eclipse","permalink":"https://baiyuan.wang/tags/eclipse/"}]},{"title":"activity生命周期及其周期方法详解","slug":"activity-life-cycle-and-cycle-methods-details","date":"2015-04-13T07:27:20.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"activity-life-cycle-and-cycle-methods-details.html","link":"","permalink":"https://baiyuan.wang/activity-life-cycle-and-cycle-methods-details.html","excerpt":"","text":"当Activity处于应用中运行时，它的活动状态是由安卓操作系统通过栈的方式进行管理的，当前正在进行的Activity位于栈顶。随着不同应用的进行，每一个Activity都可以从活动状态转入非活动状态。下面是android的ACTIVITY生命周期的图示： 安卓ACTIVITY生命周期的的四个阶段 开始Activity：在这个阶段依次执行3个生命周期方法：onCreate()、onStart()和onResume()。 Activity失去焦点：如果在Activity获得焦点的情况下进入其他的Activity，这时当前的Activity会失去焦点。在这一阶段，会依次执行onPause()和onStop()方法。 ** Activity重新获得焦点：**如果Activity重新获得焦点，会依次执行 3个生命周期方法：onRestart()、onStart()和onResume()。 关闭Activity：当Activity被关闭时系统会依次执行3个生命周期方法：onPause()、onStop()和onDestroy()。 现在通过一个例子来了解它的生命周方法在四个阶段的用法： 七个生命周期方法： protected void onCreate(Bundle savedInstanceState)：当Activity第一次被创建时调用,我们可以在这进行初始化操作 ** protected void onStart()：**onStart()方法在Activity开始被执行时调用，它紧随onCreate()方法之后调用 protected void onResume()：onResume()方法在Activity即将与用户交互时调用 ** protected void onPause()：**在一个Activity启动另一个Activity时调用，它通常被用来持久化数据、停止动画或其他耗费资源的动作，下一个Activity必须等待这个方法返回后在启动，所以在这里做过多的操作 protected void onStop()：onStop()方法在一个新的Activity启动、其他的Activity切换到前台、当前Activity被销毁时都会被调用 protected void onRestart()：当Activity从stopped状态启动时会调用onRestart(),后面总是调用onStart()方法 ** protected void onDestroy() ：**Activity被销毁时调用 示例代码： package cn.wangbaiyuan.activity; import android.app.Activity; import android.os.Bundle; import android.util.Log; public class MyActivity extends Activity { private static final String lifeTag &#x3D; “Activity生命周期”; &#x2F;&#x2F;当Activity第一次被创建时调用,我们可以在这进行初始化操作public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Log.d(lifeTag,”—-&gt;oncreate()被执行”); } &#x2F;&#x2F;onStart()方法在Activity开始被执行时调用，它紧随onCreate()方法之后调用protected void onStart() { super.onStart(); Log.d(lifeTag,”—-&gt;onStart()被执行”); } &#x2F;&#x2F;onResume()方法在Activity即将与用户交互时调用protected void onResume() { super.onResume(); Log.d(lifeTag,”—-&gt;onResume()被执行”); } &#x2F;&#x2F;当Activity从stopped状态启动时会调用onRestart(),后面总是调用onStart()方法protected void onRestart() { super.onRestart(); Log.d(lifeTag,”—-&gt;onRestart()被执行”); } &#x2F;&#x2F;在一个Activity启动另一个Activity时调用，它通常被用来持久化数据、停止动画或其他耗费资源的动作，&#x2F;&#x2F;下一个Activity必须等待这个方法返回后在启动，所以在这里做过多的操作protected void onPause() { super.onPause(); Log.d(lifeTag,”—-&gt;onPause()被执行”); } &#x2F;&#x2F;onStop()方法在一个新的Activity启动、其他的Activity切换到前台、当天Activity被销毁时都会被调用 protected void onStop() { super.onStop(); Log.d(lifeTag,”—-&gt;onStop()被执行”); } &#x2F;&#x2F;Activitybe被销毁时调用protected void onDestroy() { super.onDestroy(); Log.d(lifeTag,”—-&gt;onDestroy()被执行”); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"}]},{"title":"安卓响应触摸屏事件","slug":"android-responds-to-touch-screen-events","date":"2015-04-13T03:37:05.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"android-responds-to-touch-screen-events.html","link":"","permalink":"https://baiyuan.wang/android-responds-to-touch-screen-events.html","excerpt":"","text":"响应触摸屏事件话不多说先上代码： public boolean onTouchEvent(MotionEvent event) { &#x2F;&#x2F;获得触摸的坐标float x &#x3D; event.getX();float y &#x3D; event.getY(); switch (event.getAction()) {&#x2F;&#x2F;触摸屏幕时刻case MotionEvent.ACTION_DOWN: break;&#x2F;&#x2F;触摸并移动时刻case MotionEvent.ACTION_MOVE: break;&#x2F;&#x2F;终止触摸时刻case MotionEvent.ACTION_UP:break;}return true;} 关于public boolean onTouchEvent (MotionEvent event)方法：参数event：参数event为手机屏幕触摸事件封装类的对象，其中封装了该事件的所有信息，例如触摸的位置、触摸的类型以及触摸的时间等。该对象会在用户触摸手机屏幕时被创建。 返回值：该方法的返回值机理与键盘响应事件的相同，同样是当已经完整地处理了该事件且不希望其他回调方法再次处理时返回true，否则返回false。 该方法并不像之前介绍过的方法只处理一种事件，一般情况下以下三种情况的事件全部由onTouchEvent方法处理，只是三种情况中的动作值不同。 屏幕被按下：当屏幕被按下时，会自动调用该方法来处理事件，此时MotionEvent.getAction()的值为MotionEvent.ACTION_DOWN，如果在应用程序中需要处理屏幕被按下的事件，只需重新该回调方法，然后在方法中进行动作的判断即可。 屏幕被抬起：当触控笔离开屏幕时触发的事件，该事件同样需要onTouchEvent方法来捕捉，然后在方法中进行动作判断。当MotionEvent.getAction()的值为MotionEvent.ACTION_UP时，表示是屏幕被抬起的事件。 在屏幕中拖动：该方法还负责处理触控笔在屏幕上滑动的事件，同样是调用MotionEvent.getAction()方法来判断动作值是否为MotionEvent.ACTION_MOVE再进行处理。 控制飞机跟随手指移动： public boolean onTouchEvent(MotionEvent event){ plane.setX(event.getX()); plane.setY(event.getY()); invalidate(); return true; }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"}]},{"title":"安卓按钮的监听事件的两种方式","slug":"android-buttons-two-ways-listen-events","date":"2015-04-13T03:35:25.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-buttons-two-ways-listen-events.html","link":"","permalink":"https://baiyuan.wang/android-buttons-two-ways-listen-events.html","excerpt":"","text":"按钮的监听事件在上面的应用截图中我们看到游戏开始界面使用了”开始游戏”和”退出游戏”的两个按钮。两个按钮分别触发正式游戏和关闭游戏程序的两个行为。所以要为两个按钮的点击事件（OnClickListener）绑定监听器。 安卓中为按钮绑定监听器的方式有两种：①布局文件中声明②代码中新建监听器并绑定； 在实现”BY战机”中，我采用了第二种，即在代码中建立监听器。 为了以后复习学习和网友交流，在此我同时介绍一下第一种绑定按钮监听器的方法。 布局文件中声明绑定按钮监听器 布局文件中声明就像为布局声明属性一样，只需要在按钮的属性字段中添加： android:onClick&#x3D;”Button_Click” 然后在java代码中定义Button_Click方法，定义按钮点击触发事件的内容 public void Button_Click (View source) { &#x2F;&#x2F;补充代码：点击按钮后的动作 } 代码中新建监听器并绑定按钮监听器 话不多说，先上代码： button\\_begin=(Button)findViewById(R.id.button\\_begin); button\\_exit=(Button)findViewById(R.id.button\\_exit); Button.OnClickListener control=new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.button_begin: Intent game=new Intent(MainActivity.this,game_main.class); startActivity(game); break; case R.id.button_exit: System.exit(0); break; &#125; &#125; &#125;; button_begin.setOnClickListener(control); button_exit.setOnClickListener(control); 这是”BY战机”项目中我为”开始游戏”和”结束游戏”绑定监听器及其动作代码。 先通过findViewById获取两个按钮，通过代码：button_begin.setOnClickListener(control); 为两个按钮设置它们的监听器为control，在上面的代码中我定义control的内容，为了让两个按钮共用一个监听器，我使用view.getId()获取点击的按钮的来源ID，然后通过switch选择语句区分两个按钮的执行动作：startActivity(game) 【进入游戏activity】和System.exit(0)【退出当前安卓程序】。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"MySql数据库创建、删除与显示版本","slug":"creates-deletes-and-displays-the-mysql-database-version","date":"2015-04-08T03:49:13.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"creates-deletes-and-displays-the-mysql-database-version.html","link":"","permalink":"https://baiyuan.wang/creates-deletes-and-displays-the-mysql-database-version.html","excerpt":"","text":"4.1 创建数据库注意：创建数据库之前要先连接Mysql服务器命令：create database &lt;数据库名&gt; 例1：建立一个名为xhkdb的数据库 mysql&gt; create database xhkdb; 例2：创建数据库并分配用户①CREATE DATABASE 数据库名;②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’;③SET PASSWORD FOR ‘数据库名‘@’localhost’ &#x3D; OLD_PASSWORD(‘密码’);依次执行3个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。 4.2 显示数据库命令：show databases （注意：最后有个s）mysql&gt; show databases;注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以GBK编码页面为例进行说明： 1、修改MYSQL的配置文件：my.ini里面修改default-character-set&#x3D;gbk 2、代码运行时修改： ①Java代码：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;gbk ②PHP代码：header(“Content-Type:text&#x2F;html;charset&#x3D;gb2312”); ③C语言代码：int mysql_set_character_set( MYSQL * mysql, char * csname)；该函数用于为当前连接设置默认的字符集。字符串csname指定了1个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与SET NAMES语句类似，但它还能设置mysql- &gt; charset的值，从而影响了由mysql_real_escape_string() 设置的字符集。 4.3 删除数据库命令：drop database &lt;数据库名&gt; 例如：删除名为 xhkdb的数据库mysql&gt; drop database xhkdb; 例子1：删除一个已经确定存在的数据库 mysql&gt; drop database drop_database; Query OK, 0 rows affected (0.00 sec) 例子2：删除一个不确定存在的数据库 mysql&gt; drop database drop_database; ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist &#x2F;&#x2F;发生错误，不能删除’drop_database’数据库，该数据库不存在。 mysql&gt; drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)&#x2F;&#x2F;产生一个警告说明此数据库不存在 mysql&gt; create database drop_database; Query OK, 1 row affected (0.00 sec) mysql&gt; drop database if exists drop_database;&#x2F;&#x2F;if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec) 4.4 连接数据库命令： use &lt;数据库名&gt;例如：如果xhkdb数据库存在，尝试存取它： mysql&gt; use xhkdb;屏幕提示：Database changeduse 语句可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句： mysql&gt; USE db1; mysql&gt; SELECT COUNT() FROM mytable; # selects from db1.mytable mysql&gt; USE db2; mysql&gt; SELECT COUNT() FROM mytable; # selects from db2.mytable使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从db1数据库访问作者表，并从db2数据库访问编辑表： mysql&gt; USE db1; mysql&gt; SELECT author_name,editor_name FROM author,db2.editor -&gt; WHERE author.editor_id &#x3D; db2.editor.editor_id;USE语句被设立出来，用于与Sybase相兼容。有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用show databases就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。 4.5 当前选择的数据库命令：mysql&gt; select database();MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？ 1.显示MYSQL的版本mysql&gt; select version();+———————–+| version() |+———————–+| 6.0.4-alpha-community |+———————–+1 row in set (0.02 sec) 2. 显示当前时间mysql&gt; select now();+———————+| now() |+———————+| 2009-09-15 22:35:32 |+———————+1 row in set (0.04 sec) 3. 显示年月日SELECT DAYOFMONTH(CURRENT_DATE);+————————–+| DAYOFMONTH(CURRENT_DATE) |+————————–+| 15 |+————————–+1 row in set (0.01 sec)SELECT MONTH(CURRENT_DATE);+———————+| MONTH(CURRENT_DATE) |+———————+| 9 |+———————+1 row in set (0.00 sec)SELECT YEAR(CURRENT_DATE);+——————–+| YEAR(CURRENT_DATE) |+——————–+| 2009 |+——————–+1 row in set (0.00 sec) 4. 显示字符串mysql&gt; SELECT “welecome to my blog!”;+———————-+| welecome to my blog! |+———————-+| welecome to my blog! |+———————-+1 row in set (0.00 sec) 5. 当计算器用select ((4 * 4) &#x2F; 10 ) + 25;+———————-+| ((4 * 4) &#x2F; 10 ) + 25 |+———————-+| 26.60 |+———————-+1 row in set (0.00 sec) 6. 串接字符串select CONCAT(f_name, “ “, l_name)AS Namefrom employee_datawhere title &#x3D; ‘Marketing Executive’;+—————+| Name |+—————+| Monica Sehgal || Hal Simlai || Joseph Irvine |+—————+3 rows in set (0.00 sec)注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列’CONCAT(f_name, “ “, l_name)’起了个假名。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"mySQL数据库连接、修改密码、新建用户操作命令","slug":"mysql-database-connections-change-password-create-a-new-user-command","date":"2015-04-08T03:45:07.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"mysql-database-connections-change-password-create-a-new-user-command.html","link":"","permalink":"https://baiyuan.wang/mysql-database-connections-change-password-create-a-new-user-command.html","excerpt":"","text":"1、连接Mysql格式： mysql -h主机地址 -u用户名 －p用户密码 连接到本机上的MYSQL。首先打开DOS窗口，然后进入目录mysql\\bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码。如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt;2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： mysql -h110.110.110.110 -u root -p 123;（注:u与root之间可以不用加空格，其它也一样）3、退出MYSQL命令： exit （回车） 2、修改密码格式：mysqladmin -u用户名 -p旧密码 password 新密码 1、给root加个密码ab12。首先在DOS下进入目录mysql\\bin，然后键入以下命令 mysqladmin -u root -password ab12注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、再将root的密码改为djg345。 mysqladmin -u root -p ab12 password djg345 3、增加新用户注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令： grant select,insert,update,delete on . to [email&#x3D;test1@”%]test1@”%[&#x2F;email]” Identified by “abc”;但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。 grant select,insert,update,delete on mydb.* to [email&#x3D;test2@localhost]test2@localhost[&#x2F;email] identified by “abc”;如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to [email&#x3D;test2@localhost]test2@localhost[&#x2F;email] identified by “”;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Android开发解析JSON数据","slug":"parsing-json-data-android-development","date":"2015-04-07T05:30:17.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"parsing-json-data-android-development.html","link":"","permalink":"https://baiyuan.wang/parsing-json-data-android-development.html","excerpt":"","text":"对于服务器端来说，返回给客户端的数据格式一般分为html、xml和json这三种格式，那么本篇随笔将讲解一下json这个知识点，包括如何通过json-lib和gson这两个json解析库来对解析我们的json数据，以及如何在我们的Android客户端解析来自服务器端的json数据，并更新到UI当中。 一、什么是jsonjson(Javascript Object Notation)是一种轻量级的数据交换格式，相比于xml这种数据交换格式来说，因为解析xml比较的复杂，而且需要编写大段的代码，所以客户端和服务器的数据交换格式往往通过json来进行交换。尤其是对于web开发来说，json数据格式在客户端直接可以通过javascript来进行解析。 json一共有两种数据结构，一种是以 (key&#x2F;value)对形式存在的无序的jsonObject对象，一个对象以“{”（左花括号）开始，“}”（右花括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称&#x2F;值’ 对”之间使用“,”（逗号）分隔。 例如：{“name”: “xiaoluo”}， 这就是一个最简单的json对象，对于这种数据格式，key值必须要是string类型，而对于value，则可以是string、number、object、array等数据类型： 另一种数据格式就是有序的value的集合，这种形式被称为是jsonArray，数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。 更多的有关json数据格式可以参加json的官网，http://www.json.org/json-zh.html 二、解析json数据格式这里将使用两种json的解析库来对我们的json数据格式进行解析以及生成我们的json数据格式。 1.json-lib(http://json-lib.sourceforge.net/) 使用json-lib来进行解析，我们需要引入第三方的包，因为json-lib分为了两个版本，一个版本是针对于jdk1.3的，一个版本是针对于jdk1.5的，这里我们下载jdk1.5的这个json-lib包，其中还需要引入其他的几个jar包： 下载好这几个jar包后，加入到classpath中即可。我们来看看json-lib给我们提供的API。 我们最常用的两个类就是 JSONObject和JSONArray这两个类，分别代表了json对象和json数组，这两个类都实现了 JSON 这个接口，下面我们通过几个小例子来看看如何将我们常见的几种数据格式转换成我们的json对象(我们一般称之为JSON数据的序列化)以及再将json对象在转换成我们的数据格式(称之为反序列化)。 ①简单的javabean的序列化和反序列化 public class Person{ private int id; private String name; private String address; public Person() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Person(int id, String name, String address) &#123; super(); this.id = id; this.name = name; this.address = address; &#125; @Override public String toString() &#123; return &quot;Person \\[id=&quot; + id + &quot;, name=&quot; + name + &quot;, address=&quot; + address \\+ &quot;\\]&quot;; &#125; } 首先我们定义一个简单的javabean对象，然后将一个Person对象转换成json对象，然后再将这个json对象反序列化成我们的Person对象。 我们先定义一个JsonTools类，这个类有两个静态方法，我们可以通过这两个方法来得到一个JSON类型的字符串对象，以及一个JSON对象 public class JsonTools{ &#x2F;** * 得到一个json类型的字符串对象 * @param key * @param value * @return *&#x2F; public static String getJsonString(String key, Object value) { JSONObject jsonObject &#x3D; new JSONObject(); &#x2F;&#x2F;put和element都是往JSONObject对象中放入 key&#x2F;value 对&#x2F;&#x2F; jsonObject.put(key, value); jsonObject.element(key, value); return jsonObject.toString(); } /\\*\\* \\* 得到一个json对象 \\* @param key \\* @param value \\* @return */ public static JSONObject getJsonObject(String key, Object value) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put(key, value); return jsonObject; &#125; } 我们可以直接通过 JSONObject jsonObject &#x3D; new JSONObject(); 这个方法就可以得到一个json对象，然后通过element()或者是put()方法来给我们的json对象添加key&#x2F;value对。我们先来看看第一个例子，实现一个简单的Person对象和json对象的转换 Person person &#x3D; new Person(1, “xiaoluo”, “广州”); &#x2F;&#x2F; 将Person对象转换成一个json类型的字符串对象 String personString &#x3D; JsonTools.getJsonString(“person”, person); System.out.println(personString.toString()); 我们看看控制台的输出： {“person”:{“address”:”广州”,”id”:1,”name”:”xiaoluo”}} 整个外面的大括号是一个json对象，里面有一对key&#x2F;value，其中里面的{“address”:”广州”,”id”:1,”name”:”xiaoluo”}就是我们转换成的json字符串对象 再来看看如何将json对象转换成我们的bean对象 JSONObject jsonObject &#x3D; JsonTools.getJsonObject(“person”, person); &#x2F;&#x2F; 通过JSONObject的toBean方法可以将json对象转换成一个javabean JSONObject personObject &#x3D; jsonObject.getJSONObject(“person”); Person person2 &#x3D; (Person) JSONObject.toBean(personObject, Person.class); System.out.println(person2); Person [id&#x3D;1, name&#x3D;xiaoluo, address&#x3D;广州] ②转换List类型的对象 @Test public void testPersonsJson() { List persons &#x3D; new ArrayList(); Person person &#x3D; new Person(1, “xiaoluo”, “广州”); Person person2 &#x3D; new Person(2, “android”, “上海”); persons.add(person); persons.add(person2); String personsString &#x3D; JsonTools.getJsonString(“persons”, persons); System.out.println(personsString); JSONObject jsonObject = JsonTools.getJsonObject(&quot;persons&quot;, persons); // List&lt;Person&gt;相当于一个JSONArray对象 JSONArray personsArray = (JSONArray)jsonObject.getJSONArray(&quot;persons&quot;); List&lt;Person&gt; persons2 = (List&lt;Person&gt;) personsArray.toCollection(personsArray, Person.class); System.out.println(persons2); &#125; {“persons”:[{“address”:”广州”,”id”:1,”name”:”xiaoluo”},{“address”:”上海”,”id”:2,”name”:”android”}]}[Person [id&#x3D;1, name&#x3D;xiaoluo, address&#x3D;广州], Person [id&#x3D;2, name&#x3D;android, address&#x3D;上海]] ③List&lt;Map&lt;String, String&gt;&gt;类型的json对象转换 @Test public void testMapJson() { List&lt;Map&lt;String, String&gt;&gt; list &#x3D; new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Map&lt;String, String&gt; map1 &#x3D; new HashMap&lt;String, String&gt;(); map1.put(“id”, “001”); map1.put(“name”, “xiaoluo”); map1.put(“age”, “20”); Map&lt;String, String&gt; map2 &#x3D; new HashMap&lt;String, String&gt;(); map2.put(“id”, “002”); map2.put(“name”, “android”); map2.put(“age”, “33”); list.add(map1); list.add(map2); String listString &#x3D; JsonTools.getJsonString(“list”, list); System.out.println(listString); JSONObject jsonObject = JsonTools.getJsonObject(&quot;list&quot;, list); JSONArray listArray = jsonObject.getJSONArray(&quot;list&quot;); List&lt;Map&lt;String, String&gt;&gt; list2 = (List&lt;Map&lt;String, String&gt;&gt;) listArray.toCollection(listArray, Map.class); System.out.println(list2); &#125; {“list”:[{“id”:”001”,”age”:”20”,”name”:”xiaoluo”},{“id”:”002”,”age”:”33”,”name”:”android”}]}[{id&#x3D;001, name&#x3D;xiaoluo, age&#x3D;20}, {id&#x3D;002, name&#x3D;android, age&#x3D;33}] 通过上面的例子，我们可以了解了如何通过json-lib这个解析库来实现javabean、List、Map等数据和json数据的互相转换 2.gson(http://code.google.com/p/google-gson/) 下面我们来看看Google提供的gson这个json解析库，同样我们需要去下载gson这个jar包，导入到我们的项目中 使用gson，我们可以非常轻松的实现数据对象和json对象的相互转化，其中我们最常用的就是两个方法，一个是fromJSON()，将json对象转换成我们需要的数据对象，另一个是toJSON()，这个就是将我们的数据对象转换成json对象。下面我们也通过一个综合的例子来看看gson的使用方法： public class JsonService{ public Person getPerson() { Person person &#x3D; new Person(1, “xiaoluo”, “广州”); return person; } public List&lt;Person&gt; getPersons() &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); Person person = new Person(1, &quot;xiaoluo&quot;, &quot;广州&quot;); Person person2 = new Person(2, &quot;android&quot;, &quot;上海&quot;); persons.add(person); persons.add(person2); return persons; &#125; public List&lt;String&gt; getString() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;广州&quot;); list.add(&quot;上海&quot;); list.add(&quot;北京&quot;); return list; &#125; public List&lt;Map&lt;String, String&gt;&gt; getMapList() &#123; List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Map&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;(); map1.put(&quot;id&quot;, &quot;001&quot;); map1.put(&quot;name&quot;, &quot;xiaoluo&quot;); map1.put(&quot;age&quot;, &quot;20&quot;); Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;(); map2.put(&quot;id&quot;, &quot;002&quot;); map2.put(&quot;name&quot;, &quot;android&quot;); map2.put(&quot;age&quot;, &quot;33&quot;); list.add(map1); list.add(map2); return list; &#125; } public static void main(String[] args) { Gson gson &#x3D; new Gson(); JsonService jsonService &#x3D; new JsonService(); Person person &#x3D; jsonService.getPerson(); System.out.println(“person: “ + gson.toJson(person)); &#x2F;&#x2F; 对于Object类型，使用 fromJson(String, Class)方法来将Json对象转换成Java对象 Person person2 &#x3D; gson.fromJson(gson.toJson(person), Person.class); System.out.println(person2); System.out.println(“————————————————“); List&lt;Person&gt; persons = jsonService.getPersons(); System.out.println(&quot;persons: &quot; + gson.toJson(persons)); /\\* \\* 对于泛型对象，使用fromJson(String, Type)方法来将Json对象转换成对应的泛型对象 \\* new TypeToken&lt;&gt;()&#123;&#125;.getType()方法 */ List&lt;Person&gt; persons2 = gson.fromJson(gson.toJson(persons), new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType()); System.out.println(persons2); System.out.println(&quot;------------------------------------------------&quot;); List&lt;String&gt; list = jsonService.getString(); System.out.println(&quot;String----&gt;&quot; + gson.toJson(list)); List&lt;String&gt; list2 = gson.fromJson(gson.toJson(list), new TypeToken&lt;List&lt;String&gt;&gt;()&#123;&#125;.getType()); System.out.println(&quot;list2----&gt;&quot; + list2); System.out.println(&quot;------------------------------------------------&quot;); List&lt;Map&lt;String, String&gt;&gt; listMap = jsonService.getMapList(); System.out.println(&quot;Map----&gt;&quot; + gson.toJson(listMap)); List&lt;Map&lt;String, String&gt;&gt; listMap2 = gson.fromJson(gson.toJson(listMap), new TypeToken&lt;List&lt;Map&lt;String, String&gt;&gt;&gt;()&#123;&#125;.getType()); System.out.println(&quot;listMap2----&gt;&quot; + listMap2); System.out.println(&quot;------------------------------------------------&quot;); &#125; 看看控制台的输出： person: {“id”:1,”name”:”xiaoluo”,”address”:”广州”}Person [id&#x3D;1, name&#x3D;xiaoluo, address&#x3D;广州]------------------------------------------------persons: [{“id”:1,”name”:”xiaoluo”,”address”:”广州”},{“id”:2,”name”:”android”,”address”:”上海”}][Person [id&#x3D;1, name&#x3D;xiaoluo, address&#x3D;广州], Person [id&#x3D;2, name&#x3D;android, address&#x3D;上海]]------------------------------------------------String—-&gt;[“广州”,”上海”,”北京”]list2—-&gt;[广州, 上海, 北京]------------------------------------------------Map—-&gt;[{“id”:”001”,”age”:”20”,”name”:”xiaoluo”},{“id”:”002”,”age”:”33”,”name”:”android”}]listMap2—-&gt;[{id&#x3D;001, age&#x3D;20, name&#x3D;xiaoluo}, {id&#x3D;002, age&#x3D;33, name&#x3D;android}]------------------------------------------------ 三、在Android客户端解析服务器端的json数据下面我们来完成一个综合的例子，Android客户端通过一个AsyncTask异步任务请求服务器端的某些数据，然后在解析完这些数据后，将得到的数据内容更新到我们的Spinner这个UI控件当中。 我们首先来看下服务器端的代码： @WebServlet(“&#x2F;CityServlet”)public class CityServlet extends HttpServlet{ private static final long serialVersionUID &#x3D; 1L; public CityServlet() &#123; super(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter writer = response.getWriter(); String type = request.getParameter(&quot;type&quot;); if(&quot;json&quot;.equals(type)) &#123; List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); cities.add(&quot;广州&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;北京&quot;); cities.add(&quot;湖南&quot;); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); map.put(&quot;cities&quot;, cities); String citiesString = JSON.toJSONString(map); writer.println(citiesString); &#125; writer.flush(); writer.close(); &#125; } 如果客户端请求的参数是type&#x3D;json，则响应给客户端一个json数据格式 接着来看看客户端的代码，首先看看客户端的布局文件，其实就是一个按钮和一个Spinner控件，当点击按钮后，通过http协议请求服务器端的数据，然后在接收到后再更新我们的Spinner控件的数据 &lt;RelativeLayout xmlns:android&#x3D;”http://schemas.android.com/apk/res/android“ xmlns:tools&#x3D;”http://schemas.android.com/tools“ android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”match_parent” &gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout\\_width=&quot;wrap\\_content&quot; android:layout\\_height=&quot;wrap\\_content&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_marginLeft=&quot;64dp&quot; android:layout_marginTop=&quot;64dp&quot; android:textSize=&quot;20sp&quot; android:text=&quot;城市&quot; /&gt; &lt;Spinner android:id=&quot;@+id/spinner&quot; android:layout\\_width=&quot;wrap\\_content&quot; android:layout\\_height=&quot;wrap\\_content&quot; android:layout_alignTop=&quot;@id/textView1&quot; android:layout_toRightOf=&quot;@id/textView1&quot;/&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout\\_width=&quot;wrap\\_content&quot; android:layout\\_height=&quot;wrap\\_content&quot; android:layout_alignLeft=&quot;@+id/textView1&quot; android:layout_below=&quot;@+id/spinner&quot; android:layout_marginLeft=&quot;22dp&quot; android:layout_marginTop=&quot;130dp&quot; android:text=&quot;加载数据&quot; /&gt; 在Android客户端写一个解析json数据格式的类： public class JsonUtils{ &#x2F;** * @param citiesString 从服务器端得到的JSON字符串数据 * @return 解析JSON字符串数据，放入List当中 *&#x2F; public static List parseCities(String citiesString) { List cities &#x3D; new ArrayList(); try &#123; JSONObject jsonObject = new JSONObject(citiesString); JSONArray jsonArray = jsonObject.getJSONArray(&quot;cities&quot;); for(int i = 0; i &lt; jsonArray.length(); i++) &#123; cities.add(jsonArray.getString(i)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return cities; &#125; } 当然我们的HttpUtils类也不可少： public class HttpUtils{ &#x2F;** * @param path 请求的服务器URL地址 * @param encode 编码格式 * @return 将服务器端返回的数据转换成String *&#x2F; public static String sendPostMessage(String path, String encode) { String result &#x3D; “”; HttpClient httpClient &#x3D; new DefaultHttpClient(); try { HttpPost httpPost &#x3D; new HttpPost(path); HttpResponse httpResponse &#x3D; httpClient.execute(httpPost); if(httpResponse.getStatusLine().getStatusCode() &#x3D;&#x3D; HttpStatus.SC_OK) { HttpEntity httpEntity &#x3D; httpResponse.getEntity(); if(httpEntity !&#x3D; null) { result &#x3D; EntityUtils.toString(httpEntity, encode); } } } catch (Exception e) { e.printStackTrace(); } finally { httpClient.getConnectionManager().shutdown(); } return result; &#125; } 最后来看看我们的MainActivity类： public class MainActivity extends Activity{ private Spinner spinner; private Button button; private ArrayAdapter adapter; private ProgressDialog dialog; private final String CITY_PATH_JSON &#x3D; “http://172.25.152.34:8080/httptest/CityServlet?type=json“; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); spinner = (Spinner)findViewById(R.id.spinner); button = (Button)findViewById(R.id.button); dialog = new ProgressDialog(MainActivity.this); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; dialog.setTitle(&quot;提示信息&quot;); dialog.setMessage(&quot;loading......&quot;); dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); dialog.setCancelable(false); new MyAsyncTask().execute(CITY\\_PATH\\_JSON); &#125; &#125;); &#125; public class MyAsyncTask extends AsyncTask&lt;String, Void, List&lt;String&gt;&gt; &#123; @Override protected void onPreExecute() &#123; dialog.show(); &#125; @Override protected List&lt;String&gt; doInBackground(String... params) &#123; List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); String citiesString = HttpUtils.sendPostMessage(params\\[0\\], &quot;utf-8&quot;); // 解析服务器端的json数据 cities = JsonUtils.parseCities(citiesString);return cities; &#125; @Override protected void onPostExecute(List&lt;String&gt; result) &#123; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple\\_spinner\\_item, result); adapter.setDropDownViewResource(android.R.layout.simple\\_spinner\\_dropdown_item); spinner.setAdapter(adapter); dialog.dismiss(); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; } 当然别往了开启我们的网络授权 最后我们来看看效果图： 这样我们就完成了客户端与服务器端通过json来进行数据的交换 总结：本篇随笔主要讲解了JSON这种轻量级的数据交换格式的概念，以及讲解了两种解析json数据的解析类(json-lib以及gson)，最后通过一个小例子实现了在Android客户端和服务器端使用json这种数据格式来进行数据的交换。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"json","slug":"json","permalink":"https://baiyuan.wang/tags/json/"}]},{"title":"PHP用json_encode转换数组中文乱码","slug":"php-using-json-encode-an-array-of-chinese-characters","date":"2015-04-05T02:45:14.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"php-using-json-encode-an-array-of-chinese-characters.html","link":"","permalink":"https://baiyuan.wang/php-using-json-encode-an-array-of-chinese-characters.html","excerpt":"","text":"由于在安卓软件开发实践中，笔者想给软件加上软件更新服务，于是决定依托自己的虚拟主机，用php制作一个自己的API。再通过json标准格式输出数据库的查询结果。 一、实例展示API制作代码的简单形式是： 通过jsons_encode函数把数组转换成json格式时，会发现形如这样的中文乱码： \\u901a\\u8baf\\u5f55\\uff0c\\u662f\\u738b\\u67cf\\u5143\\u81ea\\u4e3b\\u5f00\\ 在反复检查PHP使用编码和数据库编码后，笔者才发现这是jsons_encode函数的问题，造成的原因如下： 二、原因分析:在存储到数据库时!MySQL 不会存储 unicode 字符：MySQL 仅支持从基本的多语种平面字符 (0×0000-0xFFFF)。请尝试存储一个同义词相反:) 更新： MySQL 5.5.3 上 (其中尚未 GA), 支持补充字符如果您使用 UTF8MB4 编码。 json_encode中文的时候，会把每个中文字符encode成“uxxxx”,而存进数据库的时候，“”被屏蔽了，直接变成”uxxxx” 三、 解决问题：1. 避免json_encode将中文转换unicode编码.PHP5.4版本，已经给Json新增了一个选项: JSON_UNESCAPED_UNICODE。加上这个选项后，就不会自动把中文编码了。 $json&#x3D; json_encode(“王柏元的博客”, JSON_UNESCAPED_UNICODE); 2. 先将中文字段urlencode，json_encode后，再用urldecode，也可以保证中文不会被转成unicode。$json&#x3D;urldecode(json_encode(array(‘brief’&#x3D;&gt;urlencode(‘王柏元的博客),’title’&#x3D;&gt;urlencode(王柏元的博客))); 四、解决问题的代码上面分析了问题出现的原因，如果你的PHP版本在5.4或以上，你可以使用上面的解决方案一。 第二种方案是个通解，下面我来提供自己的代码给大家参考： $value){ $array\\[$key\\]=urlencode($value); } //用urldecode将值反解 return urldecode(json_encode($array)); } /**注意：中间省略了数组获取的代码， 你可以使用上面的jsons_encode函数对你的数组进行转换 */ $json=jsons_encode($array); echo $json; ?>","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"Eclipse环境下的Java编程常见问题","slug":"java-program-in-eclipse-environment-faq","date":"2015-04-02T10:29:54.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"java-program-in-eclipse-environment-faq.html","link":"","permalink":"https://baiyuan.wang/java-program-in-eclipse-environment-faq.html","excerpt":"","text":"一、怎样可以修改eclipse新建工程的默认路径（Use default location ）？你发现你的工程只能在放一个固定的文件夹（Workspace）里，改变默认的存储路径会导致工程创建失败，下面的方法可以改变默认路径。选择File–&gt;Switch Workspace–&gt;Other…，然后点Browse就可以改变默认路径了。 二、如何运行applet程序？如果你第一次运行的是application程序，那再点击Run时，它只会出现前一次的工程名。选择DebugConfiguration，然后在Name、Project、Applet三个 编辑框里填上相应的名称。再点击Run旁边的三角形时就会出现你之前在Name框里写上的对应的名称，点击它，就可运行了。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"eclipse","slug":"eclipse","permalink":"https://baiyuan.wang/tags/eclipse/"}]},{"title":"安卓开发建立多个activity","slug":"android-development-to-establish-multiple-activity","date":"2015-04-01T12:50:57.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"android-development-to-establish-multiple-activity.html","link":"","permalink":"https://baiyuan.wang/android-development-to-establish-multiple-activity.html","excerpt":"","text":"作为一个安卓APP，建立多个activity是必须的，就像windows软件有多窗口一样； 安卓开发建立多个activity在建立多个activity是尤其需要注意的是：每个activity都要在清单文件AndroidManifest.xml中注册。如果你在AndroidManifest.xml清单文件中没有注册相关的activity，虽然有时程序可以编译通过，但是在使用软件调用了这个activity时，APP就会出现“很抱歉，程序已停止运行”的情况，对于android新手来说，这是导致“程序已停止运行”的常见原因。 建立多个activity在AndroidManifest.xml中注册方法如下： 上面是我为APP新建立的三个activity，它们分别对应src文件夹下liebiao.java、about.java、bohao.java.，在这些java文件里定义了当前activity的布局文件。 以bohao.java为例，在此文件public void onCreate(Bundle savedInstanceState)中有下面一段代码： super.onCreate(savedInstanceState); setContentView(R.layout.bohao_layout); 这定义了bohao Activity的布局为layout文件夹下bohao_layout。 怎样启动activity要启动一个新的Activity，我们可以通过调用Context中的startActivity来启动。像这样： Intent intent &#x3D; new Intent(this, ActivityDemo.class);startActivity(intent); &#x2F;&#x2F; ActivityDemo是需要启动的Activity类","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"}]},{"title":"Tabhost选项卡组件的使用方法","slug":"tabhost-tab-component-usage","date":"2015-04-01T12:20:34.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"tabhost-tab-component-usage.html","link":"","permalink":"https://baiyuan.wang/tabhost-tab-component-usage.html","excerpt":"","text":"Tabhost选项卡组件的使用方法Tabhost选项卡组件个人认为是安卓APP中比较常见的，比如QQ，应用商店等都采用了选项卡。下面是QQ的选项卡： QQ相信是国人必用，如图采用了消息、联系人、动态三个选项卡，并且为每个选项卡编写了不同的界面，这个我写的“联系人”相似，下面讲讲我是怎样实现选项卡并为每个选项制作不同交互界面的。 Tabhost选项卡使用布局代码： &lt;TabHost xmlns:android&#x3D;”http://schemas.android.com/apk/res/android“ android:id&#x3D;”@android:id&#x2F;tabhost” android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”match_parent” android:layout_weight&#x3D;”1”&gt; &lt;RelativeLayout android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”match_parent” android:orientation&#x3D;”vertical”&gt; &lt;TabWidget android:id&#x3D;”@android:id&#x2F;tabs” android:layout_width&#x3D;”fill_parent” android:layout_height&#x3D;”wrap_content” android:layout_alignParentBottom&#x3D;”true” &#x2F;&gt; &lt;FrameLayout android:id&#x3D;”@android:id&#x2F;tabcontent” android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”fill_parent” android:layout_above&#x3D;”@android:id&#x2F;tabs” &gt; &lt;!-- 定义第一个标签页的内容 –&gt; &lt;LinearLayout android:id&#x3D;”@+id&#x2F;tab01” android:layout_width&#x3D;”fill_parent” android:layout_height&#x3D;”match_parent” android:layout_gravity&#x3D;”fill_vertical” android:orientation&#x3D;”vertical” &gt; &lt;!-- 定义第二个标签页的内容 –&gt; &lt;LinearLayout android:id&#x3D;”@+id&#x2F;tab02” android:orientation&#x3D;”vertical” android:layout_width&#x3D;”fill_parent” android:layout_height&#x3D;”fill_parent”&gt; &lt;!-- 定义第三个标签页的内容 –&gt; &lt;LinearLayout android:id&#x3D;”@+id&#x2F;tab03” android:orientation&#x3D;”vertical” android:layout_width&#x3D;”fill_parent” android:layout_height&#x3D;”fill_parent” android:textSize&#x3D;”11pt”&gt; 怎样将TabWidget移到下面1. 首先使用RelativeLayout包裹tabwidget和FrameLayout，同时在tabwidget添加属性： android:layout_alignParentBottom&#x3D;”true” 2. 到上面一步会出现的问题是，选项卡的tabwidget会浮在最下面，但是tabcontent的内容也会挤满整个屏幕，而不是在tabwidget上面。解决这一问题，需要给FrameLayout添加如下属性： android:layout_above&#x3D;”@android:id&#x2F;tabs 怎样为tabHost添加内容（Activity）实现的代码如下： public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#x2F;&#x2F; 获取该Activity里面的TabHost组件 TabHost tabHost &#x3D; getTabHost(); &#x2F;&#x2F; 创建第一个Tab页 TabSpec tab1 &#x3D; tabHost.newTabSpec(“tab1”) .setIndicator(“拨号”) &#x2F;&#x2F; 设置标题 .setContent(new Intent(this,bohao.class)); &#x2F;&#x2F;设置内容 &#x2F;&#x2F; 添加第一个标签页 tabHost.addTab(tab1); TabSpec tab2 &#x3D; tabHost.newTabSpec(“tab2”) &#x2F;&#x2F; 在标签标题上放置图标 .setIndicator(“联系人”, getResources() .getDrawable(R.drawable.ic_launcher)) .setContent(new Intent(this,liebiao.class)); &#x2F;&#x2F;设置内容 &#x2F;&#x2F; 添加第二个标签页 tabHost.addTab(tab2); TabSpec tab3 &#x3D; tabHost.newTabSpec(“tab3”) .setIndicator(“关于”) .setContent(new Intent(this,about.class)); &#x2F;&#x2F;设置内容 &#x2F;&#x2F; 添加第三个标签页 tabHost.addTab(tab3); } 其中为选项卡添加内容的函数为： TabSpec tab3 &#x3D; tabHost.newTabSpec(“tab3”) .setIndicator(“关于”) .setContent(new Intent(this,about.class)); &#x2F;&#x2F;设置内容 &#x2F;&#x2F; 添加第三个标签页 tabHost.addTab(tab3); [callout class&#x3D;”danger” title&#x3D;””]new Intent(this,about.class)表示tab3里面的内容是about.Java.[&#x2F;callout]","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android控件","slug":"android控件","permalink":"https://baiyuan.wang/tags/android%E6%8E%A7%E4%BB%B6/"}]},{"title":"模拟UA实现访问只能在微信上打开的网页","slug":"analog-ua-implementation-access-to-open-only-on-the-app-page","date":"2015-03-29T03:15:45.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"analog-ua-implementation-access-to-open-only-on-the-app-page.html","link":"","permalink":"https://baiyuan.wang/analog-ua-implementation-access-to-open-only-on-the-app-page.html","excerpt":"","text":"今天，笔者打开学校的“小瓜工大助手”查跑操的页面，对它的网页源代码非常感兴趣。无奈网页的设计者只让用户在微信的自带浏览器中打开网页，而手机微信自带浏览器是没有审查元素、查看源代码之类的功能。我的第一感觉就是写代码的人肯定是采取UA匹配以限制其它终端访问的机制。所以，解决办法很简单，在电脑模拟一个微信浏览器，实现方法就是修改浏览器的UA（userAgent）。 试验结果很顺利： 通过微信右上角的菜单“复制链接”获取当前页面的链接：http://npuxiaogua.mgschool.cn/wx/apps/paocao 在电脑浏览器上打开时： 通过修改浏览器UA后的结果： 下面讲讲操作方法： 一.“谷歌浏览器”审查元素使用右键—“审查元素” 点击审查元素手机小图标的按钮（element选项卡左边），进入模拟手机、平板电脑等其他终端的视图，下面在截图上做详解： 现在只需要在上图的UA里填写一下微信的UA就行了。那么微信的UA是什么呢？ 二、怎样获取访问者的UA信息其实获取设备的UA很简单，任何一个网站的网站日志里面都会显示访问设备的UA信息： 下面是一段标准的网站日志：61.*.43.34 - - [25&#x2F;Mar&#x2F;2015:23:38:15 +0800] “GET &#x2F;how_to_write_robts-txt.html HTTP&#x2F;1.1” 200 15071 “http://baiyuan.wang/javascript-implementation-article-copy-plus-copyright-information.html“ “Mozilla&#x2F;5.0 (Linux; U; Android 4.4.2; zh-CN; Lenovo A808t Build&#x2F;KOT49H) AppleWebKit&#x2F;534.30 (KHTML, like Gecko) Version&#x2F;4.0 UCBrowser&#x2F;10.2.1.550 U3&#x2F;0.8.0 Mobile Safari&#x2F;534.30” qxu1098410053.my3w.com text&#x2F;html “&#x2F;usr&#x2F;home&#x2F;qxu1098410053&#x2F;htdocs&#x2F;index.php” 858930 其中“61.*.43.34 ”是访问者的IP， [25&#x2F;Mar&#x2F;2015:23:38:15 +0800]——访问日期 http://baiyuan.wang/javascript-implementation-article-copy-plus-copyright-information.html—访问网址 网址后面的就是UA信息了：Mozilla&#x2F;5.0 (Linux; U; Android 4.4.2; zh-CN; Lenovo A808t Build&#x2F;KOT49H) AppleWebKit&#x2F;534.30 (KHTML, like Gecko) Version&#x2F;4.0 UCBrowser&#x2F;10.2.1.550 U3&#x2F;0.8.0 Mobile Safari&#x2F;534.30 通过上面的方法，笔者获取了微信自带浏览器的UA字段如下： Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit&#x2F;600.1.4 (KHTML, like Gecko) Mobile&#x2F;12A365 MicroMessenger&#x2F;5.4.1 NetType&#x2F;WIFI 三、在谷歌浏览器终端模拟界面填写UAMozilla&#x2F;5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit&#x2F;600.1.4 (KHTML, like Gecko) Mobile&#x2F;12A365 MicroMessenger&#x2F;5.4.1 NetType&#x2F;WIFI 刷新你要访问的微信网页，就再也不会出现“本网页只能在微信自带浏览器中打开”了。 四、拓展与总结：1.可以通过上述方法模拟iPhone、ipad、安卓手机，从而在网页开发时用一台电脑即可知晓自己的网页在不同设备终端上的界面状况； 2.微信的UA为：Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit&#x2F;600.1.4 (KHTML, like Gecko) Mobile&#x2F;12A365 MicroMessenger&#x2F;5.4.1 NetType&#x2F;WIFI","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"UA","slug":"UA","permalink":"https://baiyuan.wang/tags/UA/"},{"name":"微信","slug":"微信","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1/"}]},{"title":"虚拟主机怎样屏蔽指定IP或网段","slug":"web-hosting-how-to-block-specified-ip-or-network-segments","date":"2015-03-26T04:47:38.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"web-hosting-how-to-block-specified-ip-or-network-segments.html","link":"","permalink":"https://baiyuan.wang/web-hosting-how-to-block-specified-ip-or-network-segments.html","excerpt":"","text":"自王柏元的博客开通以来，笔者就不止一次地受到恶意注册、机器人发广告评论的骚扰。昨天收到一个广告评论，发现评论用户填写的网站IP和用户IP相同的，无疑，这说明这是网络机器人刷的评论。于是我就有一个想法，直接屏蔽掉这个IP访问我的博客。下面介绍我的解决方法。 虚拟主机怎样屏蔽指定IP或网段一般，虚拟主机商都没有在主机管理里提供屏蔽IP访问的功能，当然，如果有你就方便很多。其实，即使虚拟主机商没有提供屏蔽指定IP访问的功能，我们也可以很简单地实现它。 方法很简单：在htaccess文件中加入屏蔽IP的字段。（htaccess文件的写法与作用在我前面的一篇文章有相当详细的讲解，如果你对防盗链、301重定向、自定义错误页面等有浓厚的研究兴趣，不妨看看这篇文章：21 个非常有用的 .htaccess 提示和技巧。 禁止指定用户IP访问如果要屏蔽某一特定IP可以使用： order allow,denydeny from 10.16.0.1allow from all 如果想要屏蔽多个IP地址，只需多加几个deny from 即可 order allow,denydeny from 10.16.0.2deny from 10.16.0.3deny from 10.16.0.4allow from all 如果需要屏蔽整个IP段，可以使用 order allow,denydeny from 10.16.0allow from all 如果只想屏蔽IP网段段中的一部分IP，则 order allow,denydeny from 10.16.0.100&#x2F;200allow from all 仅允许指定IP访问方法很简单，把上面的 deny from 换成 allow from、deny from 换成 allow from 即可，比如： order allow,denyallow from 10.16.0.100&#x2F;200denyfrom all 允许IP段10.16.0.100至10.16.0.200的用户访问，其他IP一律无法访问。 定制403错误页面在限制访问的IP在访问网站的时候会响应403错误，但有时禁止的IP可能误判，你可以定制自己的403错误页面，提示访问者没有访问权限或者IP被屏蔽，并可以在网页中提供申诉途径。 如图： 实现方法：在htaccess中添加下述代码： ErrorDocument 403 error&#x2F;403.html error&#x2F;403.html根据实际情况填写路径，地址指向自己写的403页面。","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"},{"name":"IP","slug":"IP","permalink":"https://baiyuan.wang/tags/IP/"}]},{"title":"wordpress时间函数the_time()和data()的区别","slug":"the-wordpress-time-function-time-and-the-data-difference","date":"2015-03-25T00:30:54.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"the-wordpress-time-function-time-and-the-data-difference.html","link":"","permalink":"https://baiyuan.wang/the-wordpress-time-function-time-and-the-data-difference.html","excerpt":"","text":"昨天笔者在完善个人的wordpress插件作品“BY超级扩展”时为自己的主题量身定制了获取邮件订阅用户和退订用户记录的功能。在生成退订记录时需要附加退订时间信息。笔者本能地使用the_time()函数输出时间信息，但是无论不管我怎么修改，退订记录的时间信息总是无法写进数据库。最后发现时间直接在网页中输出打印出来，这才意识到the_time()是时间输出函数，它的返回值并不是时间。最后成功使用date(‘’)函数实现功能。 the_time()和data()区别是返回类型不停，前者是void，后者是string。两者的使用方法基本相同。下面为大家总结一下the_time()和data()的使用方法。 wordpress the_time()的使用方法代码示例1：&#x2F;&#x2F;wordpress the_time()函数 输出效果：2015年3月25日 the_time()函数的传入值里除了几个字母有讲究， 其它的内容可以完全自定义，下面是为大家总结的wordpress the_time()函数各参数的表示意义，请注意字母的大小写往往代表不同的含义： 参数z： 描述：天数 示例：365 参数Y： 描述：年份 示例：2015 参数y： 描述：年份 示例：15 参数W： 描述：周数 示例：22 参数w： 描述：星期 示例：2 参数T： 描述：时区 示例：CST 参数S： 描述：序列型数字的后缀 示例：st&#x2F;th 参数r： 描述：完整的日期时间 示例：Wed,25 Mar 2015 20:30:10 +0800 参数O： 描述：时区 示例：+0800 参数n： 描述：月份 示例：6 参数M： 描述：月份 示例：Jan 参数m： 描述：月份 示例：01 参数l： 描述：星期 示例：星期一 参数A： 描述：上下午 示例：AM&#x2F;PM 参数a： 描述：上下午 示例：am&#x2F;pm 参数H： 描述：分钟 示例：06 参数h： 描述：分钟 示例：6 参数G： 描述：小时 示例：06 参数g： 描述：小时 示例：6 参数F： 描述：月份 示例：一月 参数D： 描述：星期 示例：一 参数j： 描述：日期 示例：6 参数d： 描述：日期 示例：06 为了大家对以上参数的用法有个比较直观深入的了解，下面提供几个实例供大家参考： 1.怎样用wordpress输出时间：年 月 日，如：2015年3月25日： &#x2F;&#x2F;怎样用wordpress输出时间：年 月 日 2.怎样用wordpress输出时分秒时间：，如：12:00:00： &#x2F;&#x2F;怎样用wordpress输出时分秒时间： 3.怎样用wordpress输出星期几：如：2015年3月25日星期三： &#x2F;&#x2F;怎样用wordpress输出星期几： 注意在最后还要强调一个问题，就是当你使用中文版的wordpress时，它会很智能的将你的某些时间参数转换成中文的输出方式，比如月份。有时我们可能并不需要这样智能的转换，而只是希望利用阿拉伯数字进行输出，那么应该怎么去解决这个问题呢？ 其实解决问题的办法也不难，只是要求我们将时间函数的参数进行一些修改即可： 比如说我们原来输出月份的代码如下： &#x2F;&#x2F;这个输出结果时会自动将月份转换成中文 我们只需要将以上代码替换成下面这样就行了： &#x2F;&#x2F;修改后的代码 wordpress时间函数 data()上面介绍了wordpress data()函数的使用方法，data函数的参数和the time相同，在此不一一赘述。需要提醒的还是：如果你要在网页中直接输出时间请用the_time(),如果需要调用时间，比如把它传给一个变量，写进数据库等等，就要使用data()了。 一句话： [callout class&#x3D;”warning” title&#x3D;””]**等价于**[&#x2F;callout]","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"安卓项目的文件结构","slug":"android-project-file-structure","date":"2015-03-23T07:07:54.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"android-project-file-structure.html","link":"","permalink":"https://baiyuan.wang/android-project-file-structure.html","excerpt":"","text":"android开发环境搭建完成后，新建一个android项目，可以看到如下的目录结构： src：存放源代码 gen：edu.xidian 是在新建android项目时输入的包名，R.java是开发工具自动生成的一个类，它会根据res文件中内容自动修改，不需要我们编辑 assets：是存放应用需要的资源文件的地方（比如图片，动画等） res：也是存放应用资源文件的地方，和assets不同的是存放在这个文件夹中的所有资源文件都会在R.java文件中自动生成以个ID，当我们在程序中使用它们时，不用写路径，只需调用R.java中变量就行。这应该是ADT提供的一种规范的开发方法。 res&#x2F;drawable-hdpi res&#x2F;drawable-ldpi res&#x2F;drawable-mdpi 这三个文件夹是存放图片的，不同之处在于分辨率，是为了适应不同手机屏幕分辨率不同的情况。 res&#x2F;layout 存放Activity的布局文件 res&#x2F;values 存放Activity中显示的文本，可以在R.java中调用，方便开发多语言版本应用 AndroidManifest.xml 下面是没有经过任何修改的文件内容： [html] view plaincopy &lt;manifest xmlns:android&#x3D;”http://schemas.android.com/apk/res/android“ package&#x3D;”edu.xidian” android:versionCode&#x3D;”1” android:versionName&#x3D;”1.0”&gt; &lt;activity android:name&#x3D;”.MainActivity” android:label&#x3D;”@string&#x2F;app_name”&gt; 是整个应用的设置文件，详细内容后面再说。 标签 设置应用启动时显示的第一个Activity default.properties 属性文件","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"eclipse","slug":"eclipse","permalink":"https://baiyuan.wang/tags/eclipse/"}]},{"title":"在网页页面右上方加上百度是否收录的印章","slug":"at-the-top-right-of-the-page-the-page-baidu-included-seal","date":"2015-03-22T06:04:50.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"at-the-top-right-of-the-page-the-page-baidu-included-seal.html","link":"","permalink":"https://baiyuan.wang/at-the-top-right-of-the-page-the-page-baidu-included-seal.html","excerpt":"","text":"前面王柏元的博客里有一篇文章介绍用PHP实现判断文章是否被百度收录的方法，可能尝试的朋友看到自己的显示的效果和我的个人博客的效果不太一样。接下来向大家介绍通过PHP自动判断网站网页是否被百度收录，并通过印章悬浮的方式提示站长当前页面是否被百度收录，并为站长提供快速提交当前页面给百度收录的入口，每次在网页发表时可手动向百度提交新文章。 在我的博客文章右上方我加入了一个类似“百度图标”一样的水印，具有透明的悬浮效果，和论坛的加“精华”的印章效果相似。这种效果不仅更炫酷，更能引起访问者的注意，不知不觉中可能就为你点击向百度提交未被收录的网页。下面为大家介绍一下这究竟是怎样实现的。 一、添加PHP实现判断文章是否被百度收录的代码请参考我前面的文章《PHP实现判断文章是否被百度收录》 二、在引用“baidu_record()”函数的地方添加CSS代码其中:“百度”图标css：style&#x3D;”right: 20px;&#x2F;&#x2F;图标离父容器右边20px; position: absolute;&#x2F;&#x2F;定位元素为absolute，实现图标悬浮 color:red;&#x2F;&#x2F;收录时使用color:#2565D8; “百度”图标父容器”span“的CSS：float:right;&#x2F;&#x2F;使图标悬浮在右方 font-size: 7em; z-index: 99;&#x2F;&#x2F;是图标悬浮在其他标签上方，这个需要根据实际调整 opacity: 0.8;&#x2F;&#x2F;实现图标透明效果 position: relative; 三、拓展为了节省网站的带宽，王柏元的博客图标尽量采用Font Awesome图标字体，如果你觉得这不够美观，可以PS一个印章图片.上面的css同样适用。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://baiyuan.wang/tags/CSS/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"error LNK2001:unresolved external symbol ;public: __thiscall 类名::函数","slug":"error-lnk2001-unresolved-external-symbol-quot-public-thiscall","date":"2015-03-21T16:07:54.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"error-lnk2001-unresolved-external-symbol-quot-public-thiscall.html","link":"","permalink":"https://baiyuan.wang/error-lnk2001-unresolved-external-symbol-quot-public-thiscall.html","excerpt":"","text":"解决办法：把该函数从.cpp文件中移动到.h文件中，根本原因函数引进不成功. 学习VC＋＋时经常会遇到链接错误LNK2001，该错误非常讨厌，因为对于编程者来说，最好改的错误莫过于编译错误，而一般说来发生连接错误时，编译都已通过。产生连接错误的原因非常多，尤其LNK2001错误，常常使人不明其所以然。如果不深入地学习和理解VC＋＋，要想改正连接错误LNK2001非常困难。初学者在学习VC＋＋过程中，遇到的LNK2001错误的错误消息主要为： unresolved external symbol “symbol”（不确定的外部“符号”）。 如果连接程序不能在所有的库和目标文件内找到所引用的函数、变量或标签，将产生此错误消息。一般来说，发生错误的原因有两个：一是所引用的函数、变量不存在、拼写不正确或者使用错误；其次可能使用了不同版本的连接库。 以下是可能产生LNK2001错误的原因： 一．由于编码错误导致的LNK2001。 1．不相匹配的程序代码或模块定义(.DEF)文件能导致LNK2001。例如, 如果在C＋＋ 源文件内声明了一变量“var1”，却试图在另一文件内以变量“VAR1”访问该变量,将发生该错误。 2．如果使用的内联函数是在.CPP文件内定义的，而不是在头文件内定义将导致LNK2001错误。 3．调用函数时如果所用的参数类型同函数声明时的类型不符将会产生LNK2001。限制。当试图从文件外部访问任何没有在该文件内声明的静态变量时将导致编译错误或LN 4．试图从基类的构造函数或析构函数中调用虚拟函数时将会导致LNK2001。 5．要注意函数和变量的可公用性，只有全局变量、函数是可公用的。 静态函数和静态变量具有相同的使用范 围K2001。 函数内声明的变量(局部变量) 只能在该函数的范围内使用。 用全局变量也会产生LNK2001错误。一种解决的方法是需要时在头文件中加入该常量的初始化代码，并在.CPP文件中包含该头文件；另一种方法是使用时给该变量赋以常数。 二．由于编译和链接的设置而造成的LNK2001 1．如果编译时使用的是&#x2F;NC＋＋ 的全局常量只有静态连接性能。这不同于C，如果试图在C＋＋的多个文件内使OD(&#x2F;NODEFAULTLIB)选项，程序所需要的运行库和MFC库在连接时由编译器写入目标文件模块， 但除非在文件中明确包含这些库名，否则这些库不会被链接进工程文件。在这种情况下使用&#x2F;NOD将导致错误LNK2001。用&#x2F;MD选项编译时,既然所有的运行库都被保留在动态链接库之内，源文件中对“func”的引用，在目标文件里即对“__imp__func” 的引用。如果试图使用静态库LIBC.LIB或LIBCMT.LIB进行连接，将 2．如果没有为wWinMainCRTStartup设定程序入口，在使用Unicode和MFC时将得到“unresolved external on _WinMain@16”的LNK2001错误信息。 3．使在__imp__func上发生LNK2001；如果不使用&#x2F;MD选项编译，在使用MSVCxx.LIB连接时也会发生LNK2001。 4．使用&#x2F;ML选项编译时，如用LIBCMT.LIB链接会在_errno上发生LNK2001。 5．当编译调试版的应用程序时，如果采用发行版模态库进行连接也会产生LNK2001；同样，使用调试版模态库连接发行版应用程序时也会产生相同的问题。字标志内联函数。 6．不同版本的库和编译器的混合使用也能产生问题，因为新版的库里可能包含早先的版本没有的符号和说明。 7．在不同的模块使用内联和非内联的编译选项能够导致LNK2001。如果创建C＋＋库时打开了函数内联（&#x2F;Ob1或&#x2F;Ob2)，但是在描述该函数的相应头文件里却关闭了函数内联（没有inline关键字），这时将得到该错误信息。为避免该问题的发生，应该在相应的头文件中用inline关键 。其实，产生LNK2001的原因还有很多，以上的原因只是一部分而已，对初学者来说这些就够理解一阵子了。但是，分析错误原因的目的是为了避免错误的发生。LNK2001错误虽然比较困难，但是只要注意到了上述问题，还是能够避免和予以解决的。 8．不正确的&#x2F;SUBSYSTEM或&#x2F;ENTRY设置也能导致LNK2001。 例如： class Shape&#x2F;&#x2F;虚基类{public:Shape();~Shape();virtual float GetArea() &#x3D;0 ;virtual float GetPerim () &#x3D;0 ;}; 这错误在编译的时候没有任何提示，当你Buid的时候通不过。 Linking…ccc.obj : error LNK2001: unresolved external symbol “public: __thiscall Shape::Shape(void)” (??0Shape@@QAE@XZ)ccc.obj : error LNK2001: unresolved external symbol “public: __thiscall Shape::~Shape(void)” (??1Shape@@QAE@XZ) 这种错误的原因是没有个类Shape给出构造函数和析构函数的函数体。 正确的写法如下: class Shape{public:Shape(){}&#x2F;&#x2F; 此处添加函数体~Shape(){}&#x2F;&#x2F; 此处添加函数体virtual float GetArea() &#x3D;0 ;virtual float GetPerim () &#x3D;0 ;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"}]},{"title":"wordpress插件开发add_menu_page()函数详解","slug":"function-add-menu-page","date":"2015-03-20T03:01:56.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"function-add-menu-page.html","link":"","permalink":"https://baiyuan.wang/function-add-menu-page.html","excerpt":"","text":"add_menu_page()函数是在wordpress的管理后台添加一个管理菜单页面。用法： 参数说明：1.$page_title (string) (required) 文本是网页的标题标签显示在菜单中选择Default: None 2.$menu_title (string) (required) 该菜单屏幕名称的文本Default: None 3.$capability (string) (required) 这个菜单被显示到用户所需的能力。用户级别是过时的和不应该被用在这里！Default: None 4.$menu_slug (string) (required) 段塞流的名字来引用这个菜单（应为该菜单独特）。在3版本之前这被称为文件（或处理）参数。如果函数的参数被省略，这menu_slug应该是PHP文件处理菜单页面内容显示。 Default: None 5.$function (string) (optional) 显示菜单页面的页面内容的功能。Default: None. 从技术上讲，函数的参数是可选的，但是如果它没有提供，那么WordPress将假设包括PHP文件将生成管理屏幕，而不调用一个函数。大多数插件作者选择将页面生成代码在函数内主要的插件文件。如果函数的参数是指定的，可以用于文件参数的任何字符串。这允许使用的页面等 ?page&#x3D;my_super_plugin_page instead of ?page&#x3D;my-super-plugin&#x2F;admin-options.php. 该函数必须在两种方式中的一种参考: 如果函数是一个类成员内部的插件应该参考阵列（$this, ‘function_name’ ）在所有其他情况下，使用函数的名字本身就足够了 6.$icon_url (string) (optional)URL图标可用于此菜单。此参数是可选的。图标应该是相当小的，约16×16像素的最好的结果。你可以使用plugin_dir_url（__file__）功能得到你的插件目录的URL然后添加图像文件给它。你可以设置$icon_url to “div” to have wordpress generate tag instead of .这可以用于更先进的形成通过CSS，如改变图标悬停。 Default: 7.$position (integer) (optional) 位置在菜单命令菜单应该出现。默认情况下，如果这个参数被省略，菜单将出现在菜单的底部结构。数值越高，较低的位置，在菜单。警告：如果两个菜单项使用相同的位置属性，一个项目可能被覆盖，所以只有一项显示！冲突的风险，可以通过使用十进制而不是整数的值减少，例如63.3而不是63（注：使用引号中的代码，即“63.3′）。 Default: 底部的菜单结构 例子","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"wordpress插件制作","slug":"wordpress插件制作","permalink":"https://baiyuan.wang/tags/wordpress%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/"}]},{"title":"插件在启用的过程中产生了594个字符的异常输出","slug":"new-to-wp-plugins-encountered-exception-that-is-n-characters-output","date":"2015-03-19T15:14:36.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"new-to-wp-plugins-encountered-exception-that-is-n-characters-output.html","link":"","permalink":"https://baiyuan.wang/new-to-wp-plugins-encountered-exception-that-is-n-characters-output.html","excerpt":"","text":"今天尝试着做WP插件，这个插件在启用的过程中产生了 594 个字符的异常输出。如果您遇到了“headers already sent”错误、联合 feed（如 RSS）出错等问题，请尝试禁用或移除本插件。 百度上查了查，说是冲突了，额……我真没找到和哪个冲突了，只好卸了重装，但结果还是一样，我想肯定是哪儿块写错了吧？我就一行行的删代码，就剩下插件头部信息了，还是一样报错，貌似不是代码的关系，作为程序员的我，想不是代码的问题，就是编码的问题，呵，一试，果然，下面就给大家分享一下吧： 解决方法：保存文件时要选用UTF-8 with BOM，貌似只要按BOM存就行，存成什么要看你插件都使用了哪些编码的内容。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"wordpress允许使用邮箱和密码登录的方法","slug":"wordpress-allows-you-to-use-email-and-password-to-log-in","date":"2015-03-19T05:38:43.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"wordpress-allows-you-to-use-email-and-password-to-log-in.html","link":"","permalink":"https://baiyuan.wang/wordpress-allows-you-to-use-email-and-password-to-log-in.html","excerpt":"","text":"对于博客来说，一般用户量不会太大，有时候注册的用户不一定会记得自己的注册用户名，但往往知道注册邮箱。其实现在主流的登录系统，一般都同时支持用户名和邮箱登录，这降低了用户忘记用户名的概率，无奈wordpress不支持邮箱登录。为了方便大家的注册访问，王柏元的博客支持QQ登录，但是其实QQ登录的用户名是个长长的看起来没有规律的字符串，用户不可能记住。为了解决这个问题，我向大家介绍实现wordpress允许使用邮箱和密码登录的方法。将下述代码加入主题模板函数文件“functions.php”文件即可。 wordpress允许使用邮箱和密码登录的方法&#x2F;&#x2F;替换“用户名”为“用户名 &#x2F; 邮箱”function username_or_email_login() { if ( ‘wp-login.php’ !&#x3D; basename( $_SERVER[‘SCRIPT_NAME’] ) ) return; ?&gt; // Form Label if ( document.getElementById('loginform') ) document.getElementById('loginform').childNodes[1].childNodes[1].childNodes[0].nodeValue = '< ?php echo esc_js( __( '用户名/邮箱', 'email-login' ) ); ?>'; // Error Messages if ( document.getElementById('login_error') ) document.getElementById('login_error').innerHTML = document.getElementById('login_error').innerHTML.replace( '< ?php echo esc_js( __( '用户名' ) ); ?>', '< ?php echo esc_js( __( '用户名/邮箱' , 'email-login' ) ); ?>' ); &lt;?php}add_action( ‘login_form’, ‘username_or_email_login’ ); 使用邮箱登录wordpress的相关插件有WP Email Login，但是个人觉得使用纯代码完全可以替代。使用过多的插件对网站速度有负面影响。 附录了解更多纯代码实现插件功能的方法，你可以参考wordpress无插件实现六个经典功能","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"}]},{"title":"PHP实现判断文章是否被百度收录","slug":"php-judge-whether-baidu","date":"2015-03-18T15:23:10.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"php-judge-whether-baidu.html","link":"","permalink":"https://baiyuan.wang/php-judge-whether-baidu.html","excerpt":"","text":"一般判断一个页面是否被百度收录都采用“site+网址”搜索命令进行检查，在这里向大家分享一下用php自动判断文章是否被百度收录的方法，并在页面没有被百度的情况下一键点击直接提交网址给百度。 将下面的代码加进主题模板文件functions.php里，然后在输出是否收录的结果信息处加入“”即可； PHP实现判断文章是否被百度收录function baidu_check($url){ global $wpdb; $post_id &#x3D; ( null &#x3D;&#x3D;&#x3D; $post_id ) ? get_the_ID() : $post_id; $baidu_record &#x3D; get_post_meta($post_id,’baidu_record’,true); if( $baidu_record !&#x3D; 1){ $url&#x3D;’http://www.baidu.com/s?wd=&#39;.$url; $curl&#x3D;curl_init(); curl_setopt($curl,CURLOPT_URL,$url); curl_setopt($curl,CURLOPT_RETURNTRANSFER,1); $rs&#x3D;curl_exec($curl); curl_close($curl); if(!strpos($rs,’没有找到’)){ if( $baidu_record &#x3D;&#x3D; 0){ update_post_meta($post_id, ‘baidu_record’, 1); } else { add_post_meta($post_id, ‘baidu_record’, 1, true); } return 1; } else { if( $baidu_record &#x3D;&#x3D; false){ add_post_meta($post_id, ‘baidu_record’, 0, true); } return 0; } } else { return 1; }}function baidu_record() { if(baidu_check(get_permalink()) &#x3D;&#x3D; 1) { echo ‘ 已被百度收录‘; } else { echo ‘未收录,点击提交‘; }}","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"强烈推荐的国内外知名IT科技博客","slug":"itblogs-list","date":"2015-03-15T02:23:06.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"itblogs-list.html","link":"","permalink":"https://baiyuan.wang/itblogs-list.html","excerpt":"","text":"王柏元的博客在本篇文章向大家推荐一些国内外知名的IT博客，为大家学习IT提供国际化视野，也可以参考国外的IT文章将它翻译引入国内，同时学习最新的国外IT知识，使你在IT业界紧跟时代步伐。 国内篇1、36氪（www.36kr.com）： 目前国内做的最风生水起的科技博客，以介绍国内外互联网创业新闻为主的博客网站，自己建立有36Tree互联网创业融投资社区。36氪的名字源于元素周期 表的第36号元素“氪”，化学符号为Kr。传说中的氪星是超人的故乡。除了为创业者免费提供新闻报道，他们主办的“36氪开放日”为早期互联网创业公司初创产品发布，提供了非常不错的平台，每月在全国各大城市举办。 2、Tech2IPO（www.tech2ipo.com）： tech2ipo 自己定位于“科技创新创业媒体”，Tech2IPO是Technology to IPO的缩写，旨在报道早期创业型公司，寻找创新性创业企业，在关注创 业企业、创业信息、创业经验的同时，还为创业者提供找人、找钱、找宣传的一条龙服务。 3、互联网那点事（www.alibuybuy.com）： 聚焦互联网前沿资讯，网络精华内容，交流产品心得！这就是互联网那点事网站的主题，这个定位还是比较宽的，不像前两个定位在创业公司新闻报道，互联网那点 事，定位在关注IT行业，互联网行业发生的新闻，关注互联网产品的设计、用户体验、营销、模式等更加实用的东西，让互联网从业人员在这里都能找到自己想要 的东西。 4、分享网络2.0（www.showeb20.com)： 关注最具有Web2.0气质的早期创业项目，同样也是关注创业项目的科技博客，但聚焦在分享网络2.0博客上的项目，基本上都具有Web2.0气质，即更注重用户创造价值。但整个博客网站和前面几个比起来，略显单薄。 5、ｉ黑马（www.iheima.com)： 2012 年2月6日上线刚刚上线的一个网站平台，他一出生就有着《创业家》杂志的背景，更有着黑马基金雄厚实力作为背景，从项目发现到项目创新，再到项目报道、项 目诊断、经验分享一应俱全，最后也是最直接的，他可以向合适的团队融资，含着金钥匙出生的ｉ黑马注定要成为科技博客界的黑马，他不需要被收购，他只需要认 准了去收购其他人就可以了。 6、动点科技（cn.technode.com）： 主要报道中国和亚洲的最 新科技新闻，创业公司、投资动态以及行业趋势发展，同时动点科技也非常关注也旨在引领前沿技术和商业模式，如社会化媒体，移动互联网，电子商务和增强现实 等等，动点科技不仅仅是报道，还是个很实在的招人的平台，分享的平台、不定期举行的各种会议更是创业企业不可多得的现场沟通的平台。 7、商业不靠谱（www.bukop.com）： 虽说起名叫不靠谱，但是内容还是比较靠谱的，它所报道的所有的创新性应用，都是具体分配到每个应用场景类别中去的，从政府应用到环保应用，再到零售行业， 分门别类一目了然，商业不靠谱相比较其他的关注创业的科技博客，他们更加注重创业的点子，每个报道都是点子，而对于创业公司管理、产品设计等很少问津，对 于寻找创意还是很有帮助的。 8、科技娲母（www.techwom.com）: 这个名字比较有特点，娲母：女娲，人类女神，科技娲母，意指孕育科技的女神。科技娲母主要关注移动互联网，从移动互联网的内容、模式、运营到产品开发管理，一应俱全，关注移动互联网的童鞋可以去看看。 9、雷锋网（leiphone.com）：由一群移动互联网的信徒建立，他们中有投资人，有观察者，有产品经理，有资深玩家，还有创业者。我们将客观敏锐地记录移动互联网的每一天。他的“专题”栏目，是相当有看头，用了相当的心思的。 10、爱范儿（www.ifanr.com）： 爱范儿创建比较早，08年10月就上线了，09年就拿了搜狐优秀独立博客奖，目前关注移动互联网、集中报道创业团队，最潮的智能手持及最酷的互联网应用， 对业界生态、智能产品及移动应用有着深刻的理解。有一个比较有特色的栏目就是“现场”，报道各种各样发布会，现场会的动向。 11、月光博客（www.williamlong.info）： 月光这个典型性科技博客一定不能漏掉的，个人建博客赚到第一桶金的典范，是一个以讨论电脑技术和互联网科技为主的个人IT评论博客，专注于互联网络和搜索引擎行业的原创IT评论博客。 12、分享网络（shareweb.me）： 又一个关注互联网创业的科技博客。关注最好看，最好玩，最好用，最好听，最新奇的网站和免费信息！最大的特点是，他们只报道应用和产品，每篇文章只介绍一个网站产品，也是一个截取创意和业内动态的好去处。 13、网站分析在中国（www.chinawebanalytics.cn）： 关注点很有特色也很具体，是一个只关注网站分析的科技博客，网站分析的经验、工具、方法、培训一应俱全，想要了解网站分析方面的内容，可以去他们博客看看。 14、天涯海阁（Web20share.com）： 是一个关注国内外创新互联网、移动互联网初创企业的博客。致力于提供一个展示优秀互联网、移动互联网初创企业的平台。以报道新新应用为特点，唯一美中不足的是，关注２.０，但自己的博客网站设计的不那么的2.0。 15、小众软件（www.appinn.com）： 聚焦于分享免费、小巧、实用、有趣、绿色的软件，很实用的一个小站点，为大家找实惠的，不用搞创业那么厚重，也不用创新那么辛苦，就是发现好用的软件，大家拿来直接用就好了。 16、善用佳软（xbeta.info）： 善用佳软&#x3D;(善意+善于)应用优秀软件。目标是分享“替代盗版，提升效率”的经验，整个博客页面看起来不像是博客网站，更像是字典网站，阅读体验不是很好，但是分类确实很细，能很快找到自己想要的软件。 17、Mobile 2.0（www.mobile20.com.cn）： 创建于2008年6月，是国内一批最早关注移动互联网的科技博客。从建立之初的以Mobile Web 2.0为中心逐步转向更全面的Mobile 2.0领域。手机应用的题材均有涉及。 18、软件街（www.softjie.cn）： 软件街-最新最全软件资讯共享平台。每天专注发布软件的最新版本更新信息，以及收录新出品软件，分享、推荐优秀软件、常用软件等。 19、谷奥(www.guao.hk)： 谷奥是一个报道Google及其相关产品的资讯，提供Google产品技巧，以及Google周边新闻的专题网站，网站内90%的内容为谷奥原创编译。 20、黑番茄（www.blacktomato.cn）： 黑番茄专注于移动互联网创业前沿资讯，是互联网行业发展的风向标，是创业者寻找灵感的港湾，是草根创业者展示创业成果的舞台，是投资人寻觅创业项目的平台。 21、同步控（www.syncoo.com）： 同步控是一个关注同步（Sync）技术的主题网站，专注范围涵盖：PC端同步移动设备、本地同步网络、多系统同步、多人协作、移动办公、社交网络同步等。 22、我爱水煮鱼（fairyfish.net）： 我爱水煮鱼是一个关注WordPress开源博客平台应用和互联网的IT博客。 23、IT生活笔记网(www.55ln.com)： IT生活笔记网主要致力于分享互联网相关技术，主要涉及网站建设、网站推广、网络营销及网络安全相关内容。 国外篇1、TechCrunch http://www.techcrunch.com/ 由大名鼎鼎的迈克尔-阿灵顿（MichaelArrington）主办，主要关注高科技，尤其是Web2.0领域的创业企业。TechCrunch本质上是一家为创业企业服务的网站。有评论认为，阿灵顿的一篇文章能够成就一家企业，或是毁掉一家企业。另一方面，阿灵顿也一直在向大公司兜售TechCrunch，曾有传言称AOL和MySpace希望收购该博客，市场对该博客的估值也达到上千万美元。从博客价值来看，TechCrunch已成为独立博客的典范，其知名撰稿人还包括ErickSchonfeld等人。 2、Read Write Web http://www.readwriteweb.com/ 由另一名知名技术博客理查德-迈克马努斯（RichardMacManus）主办。该博客通常刊登深度分析类文章，而较少消息类文章。文章范围包括互联网技术、产品、趋势及大公司动态等。相对于其他美国科技博客，该博客近来对中国互联网的关注力度明显较大。例如，该博客在较早的时候就已经提出校内、海内和开心等中国SNS网站与Facebook之间可能的冲突。 3、Silicon Alley Insider http://www.alleyinsider.com/ 相对TechCrunch和Read Write Web，Silicon AlleyInsider的创办时间较晚，为2007年7月上线。不过，既然号称“硅谷内幕者”，该博客必有自己的独到之处，即内幕和独家新闻。该博客网站上的爆料类消息明显多于同类博客，在微软收购雅虎风波等一系列大型事件中都曾有“语不惊人死不休”的表现。该博客的创办者为Kevin Ryan、DwightMerriman和Henry Blodget等三人。 4、O’Reilly Radar http://radar.oreilly.com/ 由“Web2.0之父”蒂姆-奥莱利（Tim O’Reilly）主办。奥莱利本人目前是O’Reilly Media公司首席执行官，近年来全力推动开源技术的发展。该博客文章并不太关注大型IT公司或产品，而是主要关注IT领域的新趋势。 5、GigaOm http://gigaom.com/ 博客主为知名知名科技行业记者和“企业2.0”专家Om Malik。该博客主要关注新技术的发展，企业如何使用Web2.0，以及技术对经济的影响。该博客目前需代理才可访问。 6、ValleyWag http://valleywag.com/ 为Gawker媒体网络旗下博客，关注有关硅谷企业和知名人物的流言和新闻。该博客的文章风格也备受争议，其中一些不实的传言或过于尖刻的评论给企业或硅谷高管带来困扰。例如，该博客近期连续刊登文章，猛烈抨击Facebook首席运营官谢丽尔-桑德伯格。 7、VentureBeat http://venturebeat.com/ 创办者为《圣何塞信使报》前记者MattMarshall。该博客主要跟踪全球风险投资，尤其是互联网创业企业获得风险投资的情况。该博客对中国风投市场也多有涉猎。由于《圣何塞信使报》本身就具有浓厚的硅谷气息，因此Marshall在建立VentureBeat的过程中占得先机。此外，Marshall的记者经历使该博客的文章十分类似新闻。 大网站旗下博客1、BoomTown http://kara.allthingsd.com/ 《华尔街日报》记者KaraSwisher的博客（也是其个人专栏）。Swisher从1997年开始就为《华尔街日报》旧金山分部工作，并与WaltMossberg一起主办了在IT业界影响力广泛的“D: All ThingsDigita”大会。Swisher与许多硅谷高管关系良好，有人将其称作Facebook首席运营官桑德伯格的“闺中密友”。Swisher的博客主要关注微软、Google、雅虎、亚马逊、eBay等大公司动态，她在微软雅虎并购战中发布了大量内幕消息，不过Swisher本人明显厌恶雅虎首席执行官杨致远。 2、Bits http://bits.blogs.nytimes.com/ 《纽约时报》旗下博客。较为关注IT企业在数字时代中的发展、盈利情况。报道范围包括创业企业、大型企业、政府政策，以及技术在全球市场的应用。 3、The Tech Beat http://www.businessweek.com/the_thread&#x2F;techbeat&#x2F; 《商业周刊》旗下博客，由多名《商业周刊》记者联合撰稿。关注科技新闻事件背后的真相，以及对新闻事件的分析。该博客是主流的媒体技术博客之一，报道范围包括苹果、Google、英特尔等市场领头羊动态，以及Facebook等新兴领袖。 4、Between the Lines http://blogs.zdnet.com/BTL/ ZDNet旗下博客，主要关注大公司的动态，例如微软、英特尔、苹果等。三名撰稿人分别是Larry Dignan、Sam Diaz和TomSteinert-Threlkeld。其中，Dignan是ZDNet总编辑，Diaz是ZDNet高级编辑，而Steinert-Threlkeld是拥有20多年经验的IT行业记者。这也使得该博客文章拥有相当的权威性。 5、The Social http://news.cnet.com/the-social/ CNET旗下博客，博客主为纽约人Caroline McCarthy。McCarthy认为网络应当能够帮助人们的日常生活，因此Twitter、Facebook等社区网站是该博客的关注重点。她同样关注纽约当地独特的互联网文化。 6、Beyond Binary http://news.cnet.com/beyond-binary/ 同样为CNET旗下博客，博客主为CNET编辑Ina Fried。在CNET任职期间，Fried曾做过变性手术。该博客主要关注技术如何改变生活，并且尤其关注微软的动态。 半新闻网站半博客1、ArsTechnica http://arstechnica.com/index.ars 该网站名是一个拉丁文词组，意味“科技的艺术”。该网站致力于原创性的IT新闻和评论，以及对科技趋势的深度分析。ArsTechnica创立于1998年，创始人为Ken Fisher。该网站于今年5月被媒体公司Condé Nast Publications收购。 2、The Register http://www.theregister.co.uk/ 一家英国的科技新闻网站，其新闻类似于博客。该网站于1994年由John Lettice 和Mike Magee两人创建，最初通过电子邮件提供科技新闻通讯。该网站的文章充满英国式的讽刺色彩，例如经常将Google称为“全球最大的文字广告代理商”。 3、WebProNews http://www.webpronews.com/ WebProNews是一家主要关注互联网商务和搜索引擎的网站，内容包括搜索引擎优化、搜索引擎营销、社会媒体营销、广告和网络品牌等。值得一提的是，该网站常常会援引来自各个研究机构的互联网市场发展报告，并对报告进行分析。不过，该网站在许多日常新闻的报道方面时效性较差。 4、Techdirt http://www.techdirt.com/ 该网站创建于1997年。据Techdirt自己的介绍，该网站雇佣了一批来自科技、通信和媒体等行业的分析师，提供信息时代一切有用的资讯。作为互联网泡沫的幸存者，Techdirt还保留着Web1.0时代的许多特征。实际上，该网站更像是一个IT论坛，其上的文章通常不会太长，感情色彩明显。其文章主题范围很广。 5、Search Engine Land http://searchengineland.com/ 致力于报道搜索引擎领域发展的博客，博客主为拥有11年搜索引擎报道经验的记者Danny Sullivan。该博客内容包括搜索引擎营销、搜索相关问题及搜索引擎产业等。","categories":[{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"IT博客","slug":"IT博客","permalink":"https://baiyuan.wang/tags/IT%E5%8D%9A%E5%AE%A2/"}]},{"title":"JavaScript实现文章复制加版权信息","slug":"javascript-implementation-article-copy-plus-copyright-information","date":"2015-03-14T09:27:03.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"javascript-implementation-article-copy-plus-copyright-information.html","link":"","permalink":"https://baiyuan.wang/javascript-implementation-article-copy-plus-copyright-information.html","excerpt":"","text":"俗话说“天下网站一般抄”，网上的博客文章常常被转载了无数次，虽然写博客没收入，我想写文章也应该是有版权的。尽管博客文章下面常常加了“转载请申请来源”的版权信息，比如我的是“除特别注明外，本站所有文章均为王柏元的博客原创，为了尊重作者的劳动成果，转载请注明出处http://baiyuan.wang”；但是有些拿来主义者就是“懒得抽筋”，直接复制粘贴不加版权申明。 下面的代码是针对懒得抽筋的人设计的，是使用JavaScript实现文章复制时，在复制内容里自动添加版权信息的功能，如果这样还有人把版权信息有意删除，我就无语了。 JavaScript实现文章复制加版权信息1.后台主题选项加入自定义代码 function addLink() { var body_element = document.getElementsByTagName('body')\\[0\\]; var selection; if(window.getSelection){//DOM,FF,Webkit,Chrome,IE10 selection = window.getSelection(); alert(\"文字复制成功！若有文字残缺请用右键复制\\\\n转载请注明出处：\"+document.location.href); }else if(document.getSelection){//IE10 selection= document.getSelection(); alert(\"文字复制成功！若有文字残缺请用右键复制\\\\n转载请注明出处：\"+document.location.href); }else if(document.selection){//IE6+10- selection= document.selection.createRange().text; alert(\"文字复制成功！若有文字残缺请用右键复制\\\\n转载请注明出处：\"+document.location.href); }else{ selection= \"\"; alert(\"浏览器兼容问题导致复制失败！\"); } var pagelink = \" 转载请注明来源: \"+document.location.href+\"\"; var copy_text = selection + pagelink; var new_div = document.createElement('div'); new_div.style.left='-99999px'; new_div.style.position='absolute'; body\\_element.appendChild(new\\_div ); new\\_div.innerHTML = copy\\_text ; selection.selectAllChildren(new_div ); window.setTimeout(function() { body\\_element.removeChild(new\\_div ); },0); } document.body.oncopy = addLink; 你可以将上述代码加进网页尾部,如果你的主题没有加入自定义代码的功能，你也可以这样参考下面的方法： 2.functions.php中加入js脚本函数将以下代码放到模板函数文件中(最后一个“?&gt;”之前)：默认在页脚加载代码。 function add_copyright_text() { ?&gt; &#x2F;&#x2F;把方法1的js代码复制粘贴到此处 &lt;;?php } add_action( ‘wp_footer’, ‘add_copyright_text’);","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"},{"name":"文章版权保护","slug":"文章版权保护","permalink":"https://baiyuan.wang/tags/%E6%96%87%E7%AB%A0%E7%89%88%E6%9D%83%E4%BF%9D%E6%8A%A4/"}]},{"title":"网络蜘蛛访问控制文件robot.txt的写法","slug":"how-to-write-robts-txt","date":"2015-03-14T07:48:06.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"how-to-write-robts-txt.html","link":"","permalink":"https://baiyuan.wang/how-to-write-robts-txt.html","excerpt":"","text":"虽然说对于广大站长来说，我们可能希望搜索引擎收录我们的网页越多越好，但是有的时候我们并不希望搜索引擎收录我们的一些网页，比如后台登陆页面，密码保护页面，私密页面。搜索引擎网络爬虫，我们常常把它称为搜索“蜘蛛”，因为这些“蜘蛛”沿着网络上的链接爬行可谓无网不入，曾经笔者甚至无语的发现，谷歌图片的搜索蜘蛛连我的个人用户头像都收录，这种殷勤令我哭笑不得。 所以网站的根目录常常有一个叫“robot.txt”的文件，robot是英语“机器人”的意思，你可以理解为网络机器人，也就是搜索蜘蛛，通过这个文件中的文本来告诉搜索引擎，哪个目录，哪个页面或者什么格式的图片不想被收录。 先给大家讲几个例子： #禁止admin页面user-agent:*Disallow:&#x2F;admin&#x2F;Disallow:&#x2F;*.jpg$ 第一行：“#禁止admin页面”第一个字符“#”，表示注释，可以随意写不对蜘蛛爬行产生任何效果，主要的作用就是提醒自己接下来一段代码是什么目的。 第二行代码：“user-agent:*user-agent汉译为用户代理，你可能在网站日志里可以看到这个单词，手机浏览器的“UA标识”也是这个词，在robot.txt里你可以理解为“访问用户（搜索蜘蛛）的身份”。 常见的搜索蜘蛛标识有： 1.谷歌Google蜘蛛 Googlebot Googlebot-Mobile Googlebot-Image Mediapartners-Google Adsbot-Google 2.百度(Baidu)蜘蛛 Baiduspider 3.雅虎(Yahoo)蜘蛛 Yahoo!+Slurp Yahoo!+Slurp+China：雅虎中国蜘蛛 4.有道(Yodao)蜘蛛 YodaoBot YoudaoBot YodaoBot-Image 5.搜搜(Soso)蜘蛛 Sosospider Sosoimagespider 6.微软(Bing和MSN)蜘蛛 bingbot msnbot msnbot-media 7.搜狗(Sogou)蜘蛛 Sogou Web Sprider Sogou Orion spider Sogou-Test-Spider “user-agent:”其中“”是通配符，表示“所有”，意思就是要告诉所有的搜索引擎“：你们要注意了！下面就是我要告诉你们的内容！”，“user-agent:*”下面的代码对所有蜘蛛都有效；如果是”user-agent:Baiduspider “在段落头，表示下面这段代码是对百度蜘蛛说的，其他蜘蛛不受下面代码控制。 第三行代码：“Disallow:&#x2F;admin&#x2F;”disallow，是”不允许“之意，表示”你的网站地址&#x2F;admin“这个目录下的网页不允许蜘蛛访问抓取， 例如我还可以不想让搜索引擎收录我网站的bbs目录，那我就可以写成“Disallow:&#x2F;bbs&#x2F;”，如果是多个目录，一个目录写一行，下一个目录换一行写，以此类推就可以了。如果你整个网站都不让抓取，比如你的网站正在调试内测时，可以写”disallow:“;另外，”disallow:&#x2F;wp“表示包括”wp-content、wp-include“等网站根目录下以wp为前缀的目录都禁止蜘蛛爬行。 第四行代码：“Disallow:&#x2F;*.jpg$”这行代码就是要告诉搜索引擎，我不需要你收录以.jpg结尾的所有图片文件。例如我还可以不想让搜索引擎收录我网站的.png格式的图片，那我就可以写成“Disallow:&#x2F;*.png$”如果是多个文件格式，一个文件格式写一行，下一个文件格式换一行写，以此类推就可以了。 总结1.写完之后你就可以把他保存成名为”robot.txt“（文件名必须如此）的文件，用FTP上传到你网站的根目录就可以了！ 2.网站的网页不是收录越多越好，大家都知道搜索引擎比较网络上的网页相似度（相似度太高的两个页面会分散权重）的时候，不仅仅会进行不同网站间的纵向比较，而且会进行同一网站不同页面间的比较，所以，比如对于个人博客的作者归档和首页，页面内容差不多一样，我们完全可以屏蔽蜘蛛访问作者归档的页面。当然，你可以酌情控制你的日期归档、目录归档是否让搜索蜘蛛抓取。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"robots.txt","slug":"robots-txt","permalink":"https://baiyuan.wang/tags/robots-txt/"}]},{"title":"在wordpress上写说说/短微博","slug":"write-in-wordpress-said","date":"2015-03-10T08:59:01.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"write-in-wordpress-said.html","link":"","permalink":"https://baiyuan.wang/write-in-wordpress-said.html","excerpt":"","text":"在我们写博客的时候，有时候只要简单记录一下程序的一个bug怎样解决，或者只言片语抒发一下点滴感想，如果长篇大论起来未免繁琐，但是几句话也当做一篇文章看起来感觉莫名其妙。wordpress是最受欢迎的博客程序之一，但是却没有其它有些博客CMS程序的“微语”这样的功能。有时候我们只想用一两句话抒发一下自己的情绪，就想用wordpress发个微博，发个说说；没有必要写成长篇大论，如果凑字数就完全失去了“抒发”的真谛。上次写了一篇用wordpress写说说的文章，访友们很是踊跃，希望做成插件。 一、插件[button class&#x3D;”demo” size&#x3D;”lg” href&#x3D;”https://github.com/geekeren/WordPressShuoShuo“ title&#x3D;”在Github上StarWordPress说说插件”]在Github上Star[&#x2F;button] 本插件处于许多网友的要求为wordpress提供说说功能，wordpress不仅仅可以长篇大论，而可以微言大义。 二、使用注意由于本人不是专业的wordpress开发者，没有大量时间优化这项功能。本插件提供发表说说等功能，至于说说页面的样式界面文件只分享本人正在使用的，_我的界面样式可能并不适合你_，这可能需要你自己根据自己的主题适配说说展示页界面布局和样式。 三、插件截图预览地址：http://baiyuan.wang/shuoshuo电脑端界面： 手机端界面： 下面主要介绍一下核心代码： 首先在主题的functions.php里面加入以下代码： 四、代码部分&#x2F;&#x2F;新建说说功能add_action(‘init’, ‘my_custom_init’);function my_custom_init(){ $labels &#x3D; array( ‘name’ &#x3D;&gt; ‘说说’,‘singular_name’ &#x3D;&gt; ‘说说’,‘add_new’ &#x3D;&gt; ‘发表说说’,‘add_new_item’ &#x3D;&gt; ‘发表说说’,‘edit_item’ &#x3D;&gt; ‘编辑说说’,‘new_item’ &#x3D;&gt; ‘新说说’,‘view_item’ &#x3D;&gt; ‘查看说说’,‘search_items’ &#x3D;&gt; ‘搜索说说’,‘not_found’ &#x3D;&gt; ‘暂无说说’,‘not_found_in_trash’ &#x3D;&gt; ‘没有已遗弃的说说’,‘parent_item_colon’ &#x3D;&gt; ‘’, ‘menu_name’ &#x3D;&gt; ‘说说’ );$args &#x3D; array( ‘labels’ &#x3D;&gt; $labels,‘public’ &#x3D;&gt; true,‘publicly_queryable’ &#x3D;&gt; true,‘show_ui’ &#x3D;&gt; true,‘show_in_menu’ &#x3D;&gt; true,‘exclude_from_search’ &#x3D;&gt;true,‘query_var’ &#x3D;&gt; true,‘rewrite’ &#x3D;&gt; true, ‘capability_type’ &#x3D;&gt; ‘post’,‘has_archive’ &#x3D;&gt; false, ‘hierarchical’ &#x3D;&gt; false,‘menu_position’ &#x3D;&gt; null, ‘supports’ &#x3D;&gt; array(‘editor’,’author’,’title’, ‘custom-fields’) );register_post_type(‘shuoshuo’,$args);} 然后新建一个页面模板，如“page-shuoshuo.php” — CSS样式：[toggle hide&#x3D;”yes” title&#x3D;”我的css样式：” color&#x3D;”red”] #content-container{background: url() top left repeat,url(http://baiyuan.wang/wp-content/uploads/2015/01/background.jpg) top center no-repeat;background-attachment: fixed;background-size: 2px 2px,cover;}#body-container{background: #72d0eb;background-attachment: fixed;background-size: 2px 2px,cover;}body.ssbody{max-width:900px;margin:0px auto;background-attachment:fixed;background-repeat: repeat;color: #FFFFFF;font-family: 隶书;} .shuoshuo {position: relative;padding: 10px 0;}.shuoshuo li {padding: 8px 0;display: block;}.shuoshuo-content {color: #FFFFFF;font-family: 隶书;box-shadow: 0 0 3px RGBA(0,0,0,.15);background-color: rgba(148, 137, 137, 0.43);border:1px #FFF solid;border-radius: 4px;font-size: 1.2em;line-height:1.5em;margin:0 150px 0 200px;letter-spacing: 1px;padding: 20px 20px 5px 30px;min-height:60px;position: relative;white-space: pre; &#x2F;* CSS 2.0 &#x2F;white-space: pre-wrap; &#x2F; CSS 2.1 &#x2F;white-space: pre-line; &#x2F; CSS 3.0 &#x2F;white-space: -pre-wrap; &#x2F; Opera 4-6 &#x2F;white-space: -o-pre-wrap; &#x2F; Opera 7 &#x2F;white-space: -moz-pre-wrap; &#x2F; Mozilla &#x2F;white-space: -hp-pre-wrap; &#x2F; HP Printers &#x2F;word-wrap: break-word; &#x2F; IE 5+, 文本行的任意字内断开 *&#x2F;}.shuoshuo-content p{margin:0;}&#x2F;作者&#x2F;.shuoshuo-meta {text-align: right;letter-spacing: 0px;margin-top:-10px;}&#x2F;时间&#x2F;.shuoshuo .tt{margin: 35px 0 0 15px;float:left;}.shuoshuo li em{float:left;background:url(“http://www.wuover.com/wp-content/themes/QIUYE/images/bolangxian.png“) repeat-y;width:50px;height:10px;margin:42px 0 0 28px;}.shuoshuo li:hover .tt {color:#0c0;font-weight:bold;}&#x2F;头像&#x2F;.shuoshuo .zhutou{border-radius: 50%;margin: 25px 35px 0 5px;float:right;padding: 2px;border: 1px #ddd solid;display: block;transition: .5s;width: 40px;height: 40px;overflow:hidden;}.shuoshuo li:hover .zhutou {transform: rotate(720deg);-webkit-transform: rotate(720deg);-moz-transform: rotate(720deg);border-color: #0c0;}&#x2F;前面的轴&#x2F;.shuoshuo:before {height: 100%;width: 2px;background: #eee;position: absolute;left: 164px;content: “”;top:0px;}.shuoshuo-content:before {position: absolute;top: 40px;bottom: 0px;left: -42px;background: #fff;height: 12px;width: 12px;border-radius: 6px;content: “”;box-shadow: inset 0 0 2px #0c0;}.shuoshuo-content:after {position: absolute;top: 42px;bottom: 0px;left: -40px;background: #ccc;height: 8px;width: 8px;border-radius: 6px;content: “”;}.shuoshuo li:hover .shuoshuo-content:after {background: #0c0;-webkit-transform: scale(1.3);-moz-transform: scale(1.3);-ms-transform: scale(1.3);-o-transform: scale(1.3);}.shuoshuo li:hover .shuoshuo-content:before {-webkit-transform: scale(1.3);-moz-transform: scale(1.3);-ms-transform: scale(1.3);-o-transform: scale(1.3);}&#x2F;后面的轴&#x2F;.shuoshuo:after {height: 100%;width: 2px;background: #eee;position: absolute;right: 100px;content: “”;top:0px;}.shuoshuo-meta:before {position: absolute;top: 42px;bottom: 0px;right: -56px;background: #fff;height: 12px;width: 12px;border-radius: 6px;content: “”;z-index:2;box-shadow: inset 0 0 2px #0c0;}.shuoshuo-meta:after {position: absolute;top: 44px;bottom: 0px;right: -54px;background: #ccc;height: 8px;width: 8px;z-index:2;border-radius: 6px;content: “”;}.shuoshuo li:hover .shuoshuo-meta:after {background: #0c0;}@media screen and (max-width: 800px) {.shuoshuo-content {margin:0 60px 0 70px;padding: 10px 10px 5px 10px;}.shuoshuo .tt{width:30px;font-weight:bold;margin: 30px 0 0 1px;height: 20px;}.shuoshuo li:hover .tt {color:#0c0;font-size:1.2em;}.shuoshuo:before {left: 50px;}.shuoshuo-content:before {left: -26px;top:30px;}.shuoshuo-content:after {left: -24px;top:32px;} .shuoshuo:after {right: 27px;}.shuoshuo-meta:before {right: -39px;top:33px;}.shuoshuo-meta:after {right: -37px;top:35px;} .shuoshuo .zhutou{margin: 17px 5px 0 5px;}.shuoshuo li em{float:left;width:39px;height:10px;margin:34px 0 0 -1px;}} [&#x2F;toggle] 然后新建一个页面，使它的页面模板为“说说”样式。你可以访问我的“博客说说”预览一","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"}]},{"title":"u盘windowsPE重装windows系统","slug":"windowspe-u-disk-to-reinstall-windows-system","date":"2015-03-08T10:40:00.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"windowspe-u-disk-to-reinstall-windows-system.html","link":"","permalink":"https://baiyuan.wang/windowspe-u-disk-to-reinstall-windows-system.html","excerpt":"","text":"所需工具 系统镜像 u盘一枚（大于1G即可） 新系统的网卡驱动安装包（事先准备！没有网卡驱动，你的新系统将无法联网） 第一步：制作winPE系统启动盘对于u盘装系统，首先需要做一个叫winPE的系统。那什么叫winPE的系统呢？在回答这个问题之前，我想大家都知道计算机的一个常识，计算机的运行是需要操作系统为基础的，操作系统为计算机提供了设备管理、存储管理等功能，可以说是一台电脑的灵魂，电脑的文件读写都需要操作系统做支撑。在硬盘上装系统就是把系统文件写进去，然后让计算机运行这些程序文件让计算机跑起来。装系统的过程就是把系统文件写进磁盘里。前面说到，计算机的存储管理是需要操作系统作支撑的。既然是要给电脑装个系统，原本的电脑上自然是没有操作系统的，那怎么实现将文件写入呢？ 所以我们需要用一个叫“winPE”的系统作铺垫，我们一般把PE系统放在u盘，然后让电脑从u盘里启动操作系统——winPE，在u盘里面的PE系统为硬盘装上真正要使用的操作系统。winPE的系统本质和我们常用的XP、win7本质上是没有区别的，只是这个系统比较小（磁盘空间占用和运行内存占用都比较小，有人也称它是”微型（mini）系统“）,由于我们往往只是把这个系统用来安装与维护操作系统，我们不需要它像win7和winXP那样强大的全部功能，winPE的界面和XP、7差不多，却往往无法联网，没有强大的显卡处理功能等，它本质上是WIN XP、WIN7等系统的精简版。它往往就提供磁盘管理的功能，然后你就可以为你的磁盘进行分区然后写入系统文件了。 1.下载大白菜等PE制作工具，软件下载及制作教程地址：http://www.winbaicai.com/down_130.html。目前笔者所知比较有名的PE系统有老毛桃和大白菜，笔者选用的大白菜，上面这个地址介绍的很详细，制作u盘启动盘的过程笔者就不一一赘述了；需要给大家提示的时，用这些PE做的系统有时会被强行捆绑一些广告和流氓软件，好在大白菜自己提供了一个除去广告的选项 2.大白菜PE去广告的具体方法进入大白菜u盘启动盘制作工具软件的”个性设置“菜单， 在右下方有个大白菜赞助商，把下面两个选项全部取消勾选，然后它会跳出一个取消密码。输入：”winbaicai.com“ 第二步，开机进入BIOS,选择系统启动项做完u盘启动盘以后我们需要将电脑从u盘启动而不是硬盘，所以需要在bios里设置一下，由于各个厂商的bios设置不一样，具体进入bios和修改启动项的方法，你可以分别百度“ 【你的电脑品牌】怎样进入BIOS“和”【你的电脑品牌】怎样从u盘启动启动“。 笔者的电脑是戴尔的，它提供了一个F12热键选择启动项的快捷方法；而据我所知，华硕的则需要修改磁盘启动里硬盘启动顺序，你可用”+“或”-“改变启动顺序（对于新手，你这里真的要好好百度，具体品牌的方法都不太一样）。 在这里需要提醒的是，u盘启动选项里一般都带着”USB“字样. 第三步，进入windowsPE系统在启动项选项中选择”u盘“启动按enter后，就进入了windows PE系统 用上下方向键——“↑”“↓”选择【02】“运行大白菜WinPEx64正式版”，然后就正式进入了大白菜装机系统 第四步：格式化C盘（装双系统时可以保留c盘，格式化D盘，将新系统装在D盘） 第五步:加载系统镜像为虚拟光盘 一般的PE工具都提供虚拟光盘功能呢,你可以直接双击格式为.iso的虚拟光盘镜像文件,然后你可以在计算机的驱动器里看到系统的虚拟光盘 第六步:打开应用软件”Win系统安装器”安装系统 选择install.wim文件： 点击开始安装。系统安装过程就开始了，大概花费8分钟，系统安装完毕，重启电脑即可。 最后系统安装后的第一步的工作就是安装系统，个人建议使用电脑厂商官网提供的硬件驱动。其中网卡驱动和显卡驱动可以首先安装，缺少网卡驱动无法联网；缺少显卡驱动，将无法获得流畅的视频、动画体验、窗口无法透明、亮度无法调节。 如果你怕安装驱动麻烦，可以百度“驱动精灵”、“驱动人生”等工具进行安装，个人还是建议使用官网驱动。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"百元百科","slug":"技术/百元百科","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"重装系统","slug":"重装系统","permalink":"https://baiyuan.wang/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"}]},{"title":"为discuz站点做移动客户端（安卓+IOS）","slug":"mobile-client-for-discuz-site-android-ios","date":"2015-03-06T06:31:54.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"mobile-client-for-discuz-site-android-ios.html","link":"","permalink":"https://baiyuan.wang/mobile-client-for-discuz-site-android-ios.html","excerpt":"","text":"前段时间我写了一篇关于“利用第三方网站在线做自己的APP”的文章，介绍了许多在线APP生成工具，在这里我特以“安米”为典例向大家介绍一下怎样为discuz做移动客户端，包括主流移动操作系统：安卓和IOS。其中要告诉大家的是，最近安米已经移除了discuz客户端免费版的植入广告。 为discuz站点做移动客户端（安卓+IOS）1.登录安米官网，进入discuz转换页面安米官网：www.appbyme.com/mobcentACA/app/create/start discuz转换页面地址：http://www.appbyme.com/mobcentACA/app/create/start 请根据实际注册登录新建应用页面 2.根据官方文档，制作客户端 官方文档地址：http://www.appbyme.com/mobcentACA/view/staticPage/Discuz.jsp，官方的文档介绍的相当仔细，在此我就不赘述了。 制作过程中，会下载安米的验证文件和插件，插件可在discuz后台“应用”中添加插件，搜索“安米”，安装该插件即可。根据在线制作的人数多少，你的建立应用的任务可能会等待一段时间。 应用管理、发布和升级在安米的应用管理面板中会提供应用管理和更新推送服务，每一次升级应用后，当用户启动你的论坛app是都会弹出更新信息框，提示升级，百度贴吧类似。 应用截图预览![“百源IT论坛”安卓APP首页](http://baiyuan.wang/wp-content/uploads/2015/03/Screenshot_2015-03-06-14-26-38-568_thumb.jpg “”百源IT论坛”安卓APP首页”) 百源IT论坛——用户中心 客户端发帖 如果你想尝试其他第三方制作app，可能参考我之前写的文章：利用第三方网站在线做自己的APP | 王柏元的博客 http://baiyuan.wang/107.html","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"在线应用","slug":"在线应用","permalink":"https://baiyuan.wang/tags/%E5%9C%A8%E7%BA%BF%E5%BA%94%E7%94%A8/"}]},{"title":"信息查询开放平台API大全","slug":"information-collection-of-open-platform-api","date":"2015-03-04T05:33:20.000Z","updated":"2024-03-28T02:24:50.732Z","comments":false,"path":"information-collection-of-open-platform-api.html","link":"","permalink":"https://baiyuan.wang/information-collection-of-open-platform-api.html","excerpt":"","text":"使用API可以方便网站实现一些信息查询功能，通过连接第三方服务器请求数据为自己所用，下面是我为大家整理的信息查询开放平台API大全 注意事项：① Appkey请使用的微信公众号，不要使用默认的trailuser ② 接口返回类型为文本、图文、及音乐三种基本消息 ③ 请在所有消息底部主动加上“技术支持 方倍工作室” ④ JSON验证网址 http://apix.sinaapp.com/json/ ⑤ 接口将不定期增加或更新，欢迎指出错误 ⑥ 如果有想要实现的，请在下面评论中列出并提供数据来源 ⑦ 提供的例子为天气、笑话、点歌功能，其他接口可以同样的调用 ⑧ 每个IP每天免费最大调用次数为200次，不要使用公用IP，如SAE或BAE ⑨ SAE每日运行需要开支，欢迎主动付费使用，付费用户功能上将不受任何限制 ⑩ 不必费尽心思使用虚假的appkey，它仅为统计使用，真实appkey能得到更快更好的程序响应 API大全001. 天气预报接口 [20130901] city：城市名，传递时须做urlencodehttp://apix.sinaapp.com/weather/?appkey=trialuser&amp;city=%E6%B7%B1%E5%9C%B3 002. 空气质量指数接口 [20130901] city：城市名，传递时须做urlencodehttp://apix.sinaapp.com/airquality/?appkey=trialuser&amp;city=%E6%B7%B1%E5%9C%B3 003. 快递查询接口 [20130901] [toggle hide&#x3D;”yes” title&#x3D;”点击查看英文代码列表” color&#x3D;”red”] 序号 英文代码 快递公司中文名 1 aae AAE快递 2 anjie 安捷快递 3 anneng 安能物流 4 anxun 安迅物流 5 aoshuo 奥硕物流 6 aramex Aramex国际快递 7 baiqian 百千诚国际物流 8 balunzhi 巴伦支 9 baotongda 宝通达 10 benteng 成都奔腾国际快递 11 changtong 长通物流 12 chengguang 程光快递 13 chengji 城际快递 14 chengshi100 城市100 15 chuanxi 传喜快递 16 chuanzhi 传志快递 17 chukouyi 出口易物流 18 citylink CityLinkExpress 19 coe 东方快递 20 coscon 中国远洋运输(COSCON) 21 cszx 城市之星 22 dada 大达物流 23 dajin 大金物流 24 datian 大田物流 25 dayang 大洋物流快递 26 debang 德邦物流 27 dhl DHL快递 28 diantong 店通快递 29 disifang 递四方速递 30 dpex DPEX快递 31 dsu D速快递 32 ees 百福东方物流 33 ems EMS快递 34 eyoubao E邮宝 35 fanyu 凡宇快递 36 fardar Fardar 37 fedex 国际Fedex 38 fedexcn Fedex国内 39 feibao 飞豹快递 40 feihang 原飞航物流 41 feite 飞特物流 42 feiyang 飞洋快递 43 feiyuan 飞远物流 44 fengda 丰达快递 45 gangkuai 港快速递 46 gaotie 高铁快递 47 gdyz 广东邮政物流 48 gnxb 邮政小包 49 gongsuda 共速达物流|快递 50 guanda 冠达快递 51 guotong 国通快递 52 haihong 山东海红快递 53 haolaiyun 好来运快递 54 haosheng 昊盛物流 55 hebeijianhua 河北建华快递 56 henglu 恒路物流 57 hengyu 恒宇运通 58 hkpost 香港邮政 59 huacheng 华诚物流 60 huahan 华翰物流 61 huahang 华航快递 62 huangmajia 黄马甲快递 63 huaqi 华企快递 64 huayu 华宇物流 65 huitong 汇通快递 66 hutong 户通物流 67 hwhq 海外环球快递 68 intmail 国际邮政快递 69 jiahuier 佳惠尔快递 70 jiaji 佳吉快运 71 jiayi 佳怡物流 72 jiayu 佳宇物流 73 jiayunmei 加运美快递 74 jiete 捷特快递 75 jinda 金大物流 76 jingdong 京东快递 77 jingguang 京广快递 78 jinyue 晋越快递 79 jiuyi 久易快递 80 jixianda 急先达物流 81 jldt 嘉里大通物流 82 jppost 日本邮政 83 kangli 康力物流 84 kcs 顺鑫(KCS)快递 85 kuaijie 快捷快递 86 kuaitao 快淘速递 87 kuaiyouda 快优达速递 88 kuanrong 宽容物流 89 kuayue 跨越快递 90 lanhu 蓝弧快递 91 lejiedi 乐捷递快递 92 lianhaotong 联昊通快递 93 lijisong 成都立即送快递 94 lindao 上海林道货运 95 longbang 龙邦快递 96 menduimen 门对门快递 97 mengsu 蒙速快递 98 minbang 民邦快递 99 mingliang 明亮物流 100 minsheng 闽盛快递 101 nanbei 南北快递 102 nell 尼尔快递 103 nengda 能达快递 104 nsf 新顺丰（NSF）快递 105 ocs OCS快递 106 peixing 陪行物流 107 pinganda 平安达 108 pingyou 中国邮政 109 ppbyb 贝邮宝 110 quanchen 全晨快递 111 quanfeng 全峰快递 112 quanritong 全日通快递 113 quanyi 全一快递 114 ririshun 日日顺物流 115 riyu 日昱物流 116 rpx RPX保时达 117 rufeng 如风达快递 118 ruifeng 瑞丰速递 119 saiaodi 赛澳递 120 santai 三态速递 121 scs 伟邦(SCS)快递 122 shengan 圣安物流 123 shengbang 晟邦物流 124 shengfeng 盛丰物流 125 shenghui 盛辉物流 126 shentong 申通快递（可能存在延迟） 127 shiyun 世运快递 128 shunfeng 顺丰快递 129 simai 思迈快递 130 singpost 新加坡邮政 131 suchengzhaipei 速呈宅配 132 suijia 穗佳物流 133 sure 速尔快递 134 suteng 速腾快递 135 sutong 速通物流 136 tiantian 天天快递 137 tnt TNT快递 138 tongzhishu 高考录取通知书 139 ucs 合众速递 140 ups UPS快递 141 usps USPS快递 142 wanbo 万博快递 143 wanjia 万家物流 144 wanxiang 万象物流 145 weitepai 微特派 146 wuhuan 五环速递 147 xianglong 祥龙运通快递 148 xinbang 新邦物流 149 xinfeng 信丰快递 150 xingchengzhaipei 星程宅配快递 151 xiyoute 希优特快递 152 yad 源安达快递 153 yafeng 亚风快递 154 yanwen 燕文物流 155 yibang 一邦快递 156 yinjie 银捷快递 157 yishunhang 亿顺航快递 158 yousu 优速快递 159 ytfh 北京一统飞鸿快递 160 yuancheng 远成物流 161 yuantong 圆通快递 162 yuefeng 越丰快递 163 yuhong 宇宏物流 164 yumeijie 誉美捷快递 165 yunda 韵达快递 166 yuntong 运通中港快递 167 zengyi 增益快递 168 zhaijisong 宅急送快递 169 zhengzhoujianhua 郑州建华快递 170 zhima 芝麻开门快递 171 zhongtian 济南中天万运 172 zhongtie 中铁快运 173 zhongtong 中通快递 174 zhongxinda 忠信达快递 175 zhongyou 中邮物流 176 ztwl 中铁物流 177 zuochuan 佐川急便 [&#x2F;toggle] company：快递公司英文代码number：快递单号http://apix.sinaapp.com/express/?appkey=trialuser&amp;company=yuantong&amp;number=3143490877 新版Web页查询http://apix.sinaapp.com/express2/index.php 004. 智能快递查询接口 [20130901] number：快递单号http://apix.sinaapp.com/expressauto/?appkey=trialuser&amp;number=3143490877备注：支持EMS,申通快递,圆通快递,中通快递,汇通快递,天天快递,韵达快递,顺丰快递,宅急送,速尔快递,德邦物流,联昊通物流,全峰快递,中国邮政，如风达 005. 股票查询接口 [20130901] code：股票代码[通达信代码]http://apix.sinaapp.com/stock/?appkey=trialuser&amp;code=000063 006. 股票分析接口 [20131004] code：股票代码http://apix.sinaapp.com/stockanalysis/?appkey=trialuser&amp;code=000063 007. 公交线路接口 [20131004] city：城市名，传递时须做urlencodeline：线路，传递时须做urlencodehttp://apix.sinaapp.com/busline/?appkey=trailuser&amp;city=%E6%B7%B1%E5%9C%B3&amp;line=209 008. 公交、地铁换乘接口 [20131004] city：城市名，传递时须做urlencodestart：起点，传递时须做urlencodeend：终点，传递时须做urlencodehttp://apix.sinaapp.com/bus/?appkey=trailuser&amp;city=%E6%B7%B1%E5%9C%B3&amp;start=%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97&amp;end=%E7%AB%B9%E5%AD%90%E6%9E%97 009. 地铁查询接口 [20131004] http://apix.sinaapp.com/subway/?appkey=trialuser 010. 火车查询 [20131004] http://apix.sinaapp.com/train/?appkey=trialuser 011. 汽车查询接口 [20131004] http://apix.sinaapp.com/coach/?appkey=trialuser 012. 自驾线路 [20131004] startcity：起点城市，传递时须做urlencodestartplace：起点地名，传递时须做urlencodeendcity：终点城市，传递时须做urlencodeendplace：终点地名，传递时须做urlencodehttp://apix.sinaapp.com/driving/?appkey=trailuser&amp;startcity=%E5%8C%97%E4%BA%AC&amp;startplace=%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6&amp;endcity=%E5%8C%97%E4%BA%AC&amp;endplace=%E5%A4%A9%E5%AE%89%E9%97%A8 013. 出租车费用 [20131004] city：城市名，传递时须做urlencodestart：起点，传递时须做urlencodeend：终点，传递时须做urlencodehttp://apix.sinaapp.com/taxi/?appkey=trailuser&amp;city=%E5%8C%97%E4%BA%AC&amp;start=%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6&amp;end=%E5%A4%A9%E5%AE%89%E9%97%A8 014. 航班状态接口 [20131004] number：航班号http://apix.sinaapp.com/flight/?appkey=trialuser&amp;number=ca1111 015. 笑话接口 [20131004] http://apix.sinaapp.com/joke/?appkey=trialuser 016. 周公解梦接口 [20131004] content: 梦见内容，传递时须做urlencodehttp://apix.sinaapp.com/dream/?appkey=trialuser&amp;content=%E8%80%81%E5%B8%88 017. 中英互译 [20131104] content: 翻译内容，传递时须做urlencodehttp://apix.sinaapp.com/translate/?appkey=trialuser&amp;content=%E8%A1%A8%E7%A4%BA 018. 星座运势接口 [20131104] name: 星座名，传递时须做urlencodehttp://apix.sinaapp.com/astrology/?appkey=trialuser&amp;name=%E7%99%BD%E7%BE%8A%E5%BA%A7 019. 彩票开奖结果接口 [20131104] name：彩票名称，传递时须做urlencodehttp://apix.sinaapp.com/lottery/?appkey=trailuser&amp;name=%E5%8F%8C%E8%89%B2%E7%90%83备注：支持双色球,大乐透,3D,排列3,排列5,七星彩,七乐彩,胜负彩,任选九,六场半全场,四场进球 020. 苹果IMEI&#x2F;序列号查询接口 [20131104] number: IMEI号或序列号http://apix.sinaapp.com/apple/?appkey=trialuser&amp;number=358031058974471 021. 百科全书接口 [20131204] word: 词条，传递时须做urlencodehttp://apix.sinaapp.com/encyclopedia/?appkey=trialuser&amp;word=%e5%be%ae%e4%bf%a1 022. 图书介绍 [20131104] name: 图书名，传递时须做urlencodehttp://apix.sinaapp.com/book/?appkey=trialuser&amp;name=%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0 023. 歌曲介绍 [20131104] name: 音乐名，传递时须做urlencodehttp://apix.sinaapp.com/song/?appkey=trialuser&amp;name=%E6%96%B0%E5%B9%B4%E5%A5%BD 024. 影片介绍 [20131104] name: 电影名，传递时须做urlencodehttp://apix.sinaapp.com/movie/?appkey=trialuser&amp;name=%E9%BE%99%E7%8C%AB 025. 历史上的今天接口 [20140104] http://apix.sinaapp.com/history/?appkey=trialuser 026. 经济指标 027. 财经大事 028. 手机充值 http://apix.sinaapp.com/recharge/?appkey=trialuser备注：腾讯财付通官方网站充值接口，基于微信安全支付 029. 城市团购 [20140104] city: 城市名，传递时须做urlencode，你可以指定一个固定城市 查看支持城市列表keyword：关键字，传递时须做urlencode，可为商户名、商品名、地址等http://apix.sinaapp.com/groupon/?appkey=trialuser&amp;city=%E6%B7%B1%E5%9C%B3&amp;keyword=%E5%8D%8E%E5%BC%BA%E5%8C%97 030. 城市优惠 031. 黄金 032. 白银 033. 外汇 034. 图片检索 035. 视频检索 036. 地图位置服务 [20140104] lat：纬度lng：经度entity：查询名称，传递时须做urlencodehttp://apix.sinaapp.com/map/?appkey=trialuser&amp;lat=39.915&amp;lng=116.404&amp;entity=%E5%8C%BB%E9%99%A2 037. 菜谱 [20140104] name: 菜谱名称，传递时须做urlencodehttp://apix.sinaapp.com/recipe/?appkey=trialuser&amp;name=%E5%89%81%E6%A4%92%E9%B1%BC%E5%A4%B4 038. 手机号码归属地查询接口 [20140105] number: 手机号码http://apix.sinaapp.com/mobilephone/?appkey=trialuser&amp;number=13456789000 039. 身份证归属查询查询接口 [20140105] number: 15或18位身份证号码http://apix.sinaapp.com/idcard/?appkey=trialuser&amp;number=542621201212210003 040. 电视节目表 [20140116] http://apix.sinaapp.com/tvprogram/?appkey=trialuser 041. IP地址查询接口 [20140116] http://apix.sinaapp.com/ip/?appkey=trialuser&amp;ip=202.203.208.80 042. 每日宜忌查询接口 [20140116][源网站已关闭，失效] http://apix.sinaapp.com/almanac/?appkey=trialuser 043. 疾病查询 [20140121] name: 疾病名，传递时须做urlencodehttp://apix.sinaapp.com/illness/?appkey=trailuser&amp;name=%E6%84%9F%E5%86%92 044. 号码吉凶 045. 邮政编码 code：邮政编码http://apix.sinaapp.com/postcode/?appkey=trailuser&amp;code=518057 046. 产品比价查询接口 [20140118] name: 商品名，传递时须做urlencodehttp://apix.sinaapp.com/price/?appkey=trialuser&amp;name=iphone%205s 047. 食物热量查询接口 [20140120] name：食物名http://apix.sinaapp.com/calorie/?appkey=trailuser&amp;name=%E9%B8%A1%E8%9B%8B 048. 人品计算 [20140118] name: 人名，传递时须做urlencodehttp://apix.sinaapp.com/moral/?appkey=trialuser&amp;name=%E5%BC%A0%E4%B8%89 049. 违章查询 [20140118] http://apix.sinaapp.com/peccancy/?appkey=trialuser 050. 药物查询 [20140117] name: 药物名，传递时须做urlencodehttp://apix.sinaapp.com/medicine/?appkey=trialuser&amp;name=%E9%9D%92%E9%9C%89%E7%B4%A0 051. 周易算命 [20140117] name: 人名，传递时须做urlencodehttp://apix.sinaapp.com/fortune/?appkey=trailuser&amp;name=%E5%BC%A0%E4%B8%89 052. 机票查询 [20140118] http://apix.sinaapp.com/airline/?appkey=trialuser 053. 酒店查询 [20140119] http://apix.sinaapp.com/hotel/?appkey=trialuser 054. 驾照模拟考试 [20140119] http://apix.sinaapp.com/drivingtest/?appkey=trialuser 056. 在线点歌查询接口 [20140119] singer: 歌手名，传递时须做urlencodesong: 歌曲名，传递时须做urlencodehttp://apix.sinaapp.com/music/?appkey=trialuser&amp;singer=%E5%87%A4%E5%87%B0%E4%BC%A0%E5%A5%87&amp;song=%E6%9C%80%E7%82%AB%E6%B0%91%E6%97%8F%E9%A3%8E 057. 车牌归属地吉凶 [20140119] number：车牌号码。例如：湘C12345，传递时须做urlencodehttp://apix.sinaapp.com/platenumber/?appkey=trialuser&amp;number=%E6%B9%98C12345 058. 冬吴相对论 [20140120] number：节目期号http://apix.sinaapp.com/dongwu/?appkey=trialuser&amp;number=123 059. 每日英语 [20140120] type：类型，目前支持translation, listeninghttp://apix.sinaapp.com/daily/?appkey=trailuser&amp;type=translation 060. 实时路况 [20140120] http://apix.sinaapp.com/traffic/?appkey=trialuser 061. 菜价查询 [20140121] http://apix.sinaapp.com/foodprice/?appkey=trialuser 062. 成语词典 [20140121] word：成语名，传递时须做urlencodehttp://apix.sinaapp.com/idiom/?appkey=trailuser&amp;word=%E6%96%B9%E5%85%B4%E6%9C%AA%E8%89%BE 063. 人脸识别接口 [20140315] picurl：图片地址，传递时须做urlencodehttp://apix.sinaapp.com/face/?appkey=trialuser&amp;picurl=http://www.ineiyi.com/uploads/allimg/1312/79-131213142315.jpg 064. 四六级成绩查询接口http://apix.sinaapp.com/cet/?appkey=trialuser","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"在线应用","slug":"在线应用","permalink":"https://baiyuan.wang/tags/%E5%9C%A8%E7%BA%BF%E5%BA%94%E7%94%A8/"}]},{"title":"怎样免费申请.Science（科学）域名","slug":"how-to-apply-for-it-science-science-domain-names","date":"2015-03-02T01:09:32.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-apply-for-it-science-science-domain-names.html","link":"","permalink":"https://baiyuan.wang/how-to-apply-for-it-science-science-domain-names.html","excerpt":"","text":"由于传统的几大域名如.com、.cn、.net的广泛使用，导致使用量的增加也是可申请的域名长度越来越长，ICANN会允许每年有符合条件的机构申请增加各种后缀的域名，比如我们可以看到比如（.中国）国别域名，以及各种单词（.wang）后缀的新域名出现。 近期王柏元的博客发现了一个新开放注册的域名.Science（科学、科技），相信对于一些热爱科学的站长来说，这是一个很有吸引力，而且，目前笔者可以通过官网提供的优惠码免费申请使用一年的.Science（科学）域名。由于新域名的申请量还较少，大家可以比较容易申请到自己心仪的域名了。 具体申请步骤如下： 怎样免费申请.Science（科学）域名官方网站地址：http://register.science 在“yourwebsite”文本框中输入你要申请的域名，如“baiyuan” 如果你没有注册网站账号，请先行注册，然后使用优惠码免费注册 很快域名就能注册成功了，使用期为一年，一年后的续费价格为GBP17.7元（英镑），大家不妨将此域名作为备用调试域名。 域名管理注册完毕后网页会进入域名管理面板： 点击“manage DNS”，进入DNS管理页面 这样就进入域名解析记录添加页面了： 使用DNSPOD等第三方域名管理 点击“name servers”修改name servers为第三方的域名服务器，这里推荐DNSPOD 附录DNSPOD的DNS服务器地址： Name Server 1 ：f1g1ns1.dnspod.net. Name Server 2 ：f1g1ns2.dnspod.net.","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"DNSPOD","slug":"DNSPOD","permalink":"https://baiyuan.wang/tags/DNSPOD/"},{"name":"免费域名","slug":"免费域名","permalink":"https://baiyuan.wang/tags/%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D/"},{"name":"域名管理","slug":"域名管理","permalink":"https://baiyuan.wang/tags/%E5%9F%9F%E5%90%8D%E7%AE%A1%E7%90%86/"}]},{"title":"用Windows Live Writer离线写WordPress日志","slug":"using-windows-live-writer-write-wordpress-offline-logs","date":"2015-02-27T10:55:07.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"using-windows-live-writer-write-wordpress-offline-logs.html","link":"","permalink":"https://baiyuan.wang/using-windows-live-writer-write-wordpress-offline-logs.html","excerpt":"","text":"在前一篇博客向大家介绍了用word写wordpress博客的方法，可能使用的朋友发现，word并不能为文章设置标签，设置发布日期，预览和查看源代码，如果你对Word写wordpress博客不满意，那么推荐你一款非常友好的软件：Windows Live Writer（简称WLW）。这里向大家介绍一下如何用Windows Live Writer 离线写WordPress日志 WLW可以自动侦测并保存您的网络日志的视觉主题。所以，您可以在博客发布之前，在写日志的过程中真切地看到日志的外观和排版，再也不必浪费时间来联机预览了。需要指出的是，它几乎可以完成你所有在线能做到的一切！ 现针对WordPress博客的设置详解，如下： 步骤一：准备工作1、官方网站下载 Windows Live Writer 软件，地址：Windows Live Writer 2011（简体中文版） 2、登录你的WordPress管理员后台，在【设置-撰写】的“远程发布”项内，激活启动“XML-RPC”（启用 WordPress，Movable Type，MetaWeblog和Blogger 的 XML-RPC发布协议）。 步骤二：安装软件运行安装程序，勾选Writer进行安装。 此外，你可以安装根据所需选择要安装其他应用软件（因为下载的是微软Windows Live软件包，所以里面涵盖了微软很多其他软件工具，请根据所需勾选下载） 步骤三：设置Windows Live Writer1. 安装完Writer后，会自动弹出如下图提示，点击下一步。 2. 选择”WordPress”，点击下一步。（如果您现在使用的日志服务没有在列表中，请选择“其他服务”，下面我将按“其他服务”的选项进行详解） 3. 点击下一步后，会提示您填写日志帐户信息。日志网址处请填写您的博客主页地址。用户名和密码为您博客后台的登录用户名和密码（不是您设置的日志显示昵称）。如果您的电脑非公用，可勾选“记住我的密码”。 4. 填写完帐户内容后，点击下一步，开始检测连接您的帐户，如下图。 注：如果在连接日志服务器时，出现如下错误提示，需要手动修改相关文件： 提示出错信息：“无法连接到您的日志服务:服务器响应无效 – 从日志服务器接收的对 blogger.getUsersBlogs 方法的响应无效:Invalid response document returned from XmlRpc server 请尝试解决问题，然后重试。” 问题出现的根本原因是因为WordPress本身的一个bug，在utf-8编码下，xml-rpc返回的格式不正确，缺少了三个字节，要修正这个问题，操作如下： a) 找到class-IXR.php文件（注意：wordpress 2.9之前的版本，文件名可能是chass.ixr.php），该文件位于博客根目录wp-includes文件夹下，然后用一个文本编辑工具打开它（推荐使用editplus）； b) 查找到以下语句： $length &#x3D; strlen($xml); 将其替换为： $length &#x3D; strlen($xml)+3; 大家注意：以上方法针对2.9之后的版本，在wordpress 2.9之前的版本中没有class.ixr.php 文件，而是叫chass.ixr.php文件，它其实是WordPress升级后将chass.ixr.php 文件变成了class-IXR.php。不论哪种版本，按照上面的解决办法修改class-IXR.php&#x2F;或chass.ixr.php文件，问题很容易就解决了！ 5. 检测过程中会出现“是否要发布临时日志”的提示窗口，如下图。建议直接选择“否（N）”。 6. 检测完毕之后，会出现下面的窗口，默认情况下会直接提取您的博客Title。当然，您也可以自行输入昵称。点击“完成”，设置成功。 当您想重新修改日志设置信息时，可以在WLW的“管理日志帐户”中重新编辑修改。如图： 设置完以后就可以用Windows Live Writer写博客了，相比Wordpress自带的编辑器有很多优势，尤其对于多图日志，离线编写减少了上传图片的繁琐性。Writer的插入表格和地 图功能也是Wordpress自带编辑器所没有的，由于Windows Live Writer是微软的产品，所以插入的地图是Bing地图。 用Windows Live Writer离线写WordPress日志Windows Live Writer还可以设置日志类别、Ping设置、作者、摘要、发布日期、标签、数据域（永久链接）等几乎所有Wordpress编辑器自带的功能（如下 图），但我用习惯的Simple Tags的一键标签（Click tags）功能，如果一定要用到的话可以使用Windows Live Writer发布完了再去Wordpress编辑器上再编辑一下。 Windows Live Writer的预览功能比Wordpress要更加完善，点击预览按钮，可以直接预览发布后的效果（如果没有显示效果，请尝试联机更新主题）。 Windows Live Writer 最近发表和草稿存放目录 虽然Windows Live Write没有提供备份草稿的功能，但是我们可以通过复制Windows Live Write的安装目录中的文件，从而达到备份Windows Live Write的草稿。（由于默认安装在C盘下，所以如果你重装系统时，务必要将相关的Windows Live Write草稿文件夹进行备份） 最近发表和草稿存放目录的路径：C:Documents and SettingsUserNameMy DocumentsMy Weblog Posts（这里的“C”指的是系统所在硬盘分区的盘符。如果“我的文档”目录另有指定位置，则应该进入之前指定的位置），进入该文件夹中会看到“Drafts”、“Recent Posts”两个目录。 Drafts****：草稿的存放目录，保存的日志以wpost文件格式存在，可以用WLW直接打开。 Recent Posts****：最近发表的存放目录，保存的日志以wpost文件格式存在，可以用WLW直接打开。 由于备份草稿默认放在系统盘，为了避免系统重装或出现其他问题，尽量定期备份将该目录到其他分区或U盘中。在系统重装完成并安装Windows Live Writer之后，再把“Drafts”恢复到原来的目录文件夹，便可恢复Windows Live Writer草稿，非常方便。 Windows Live Writer下载[button class&#x3D;”default” size&#x3D;”lg” href&#x3D;”http://www.baidu.com“ title&#x3D;”下载”] 下载 [&#x2F;button]","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"为什么安卓机没iPhone流畅？","slug":"why-didnt-an-zhuoji-iphone-smoothly","date":"2015-02-26T01:56:34.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"why-didnt-an-zhuoji-iphone-smoothly.html","link":"","permalink":"https://baiyuan.wang/why-didnt-an-zhuoji-iphone-smoothly.html","excerpt":"","text":"网友“foto茄”：为什么iPhone6内存仅有1GB，而很多安卓机配置相当高了，还是觉得iPhone流畅一些？ 腾讯科技：相信很多网友都有类似疑问，感觉安卓手机在流畅度上不如iPhone手机。先不说一些配置低的安卓机，即便是最新版安卓系统的旗舰手机，也会感觉达不到iPhone手机的那种流畅度，因此有人以此判断安卓手机不好。 其实，这都是二者系统机制不同导致的差异。 渲染机制不同Android没有iOS流畅的根本的原因是，iOS的UI渲染采用实时优先级，而Android的UI渲染遵循传统电脑模式的主线程普通优先级。 通俗点说就是iOS对屏幕反应的优先级最高，用户只要触摸屏幕，系统就会最优先处理屏幕显示这个层级，马上给出动画效果，然后才处理媒体、服务、核心的架构。 而安卓则是追求进程优先，触摸屏幕后的手机屏幕显示和动画效果放在比较后的优先级。同样打开相同的网页，Android手机就会直接将整个网页全部加载同时渲染HTML，这无疑就增加了处理器的压力。因此对于Android来说，一个高效的双核处理器是很重要的。 在iOS中UI渲染过程具有绝对的优先等级，当用户接触到iPhone的触摸屏后，iOS中所有的进程都将停止，UI线程拦截了所有的事件，系统会将所有资源用于渲染UI过程，以保证用户界面的实时渲染优先级。 而在Android系统中UI渲染过程的优先级别却没有那么高，也就是说当你触摸Android手机屏幕的时候，系统后台的程序并没有停止，仍然在继续运行之中，比如下载和查收短信，这样系统UI获得的资源就不够，这就是Android系统不流畅的原因。 后台机制不同安卓手机的后台是真后台，像PC一样，将应用保留在RAM中，当使用HOME键退出应用时，程序实际上并没有完全退出，而是被系统挂在了后台，为何我们关掉了聊天软件依然能够收到消息通知，因为它常驻系统内存。包括平时收到的一些垃圾广告推送，也是因为后台有程序运行。 所以这就导致了一个现象，从内存使用上来看，安卓刚开机时内存使用很低，若不进行清理内存操作，正常使用一天，内存占用会达到75%以上。而内存占用越高，使用起来流畅度就会越低，所以安卓机器需要更大的RAM来提升用户体验。 而iOS呢，其实是采用的伪后台，当用户HOME键退出应用时，iOS其实关闭了程序，只保留应用的图像入口，只会默认将应用的最后的运行数据记录在RAM中。 之所以iOS也能收到推送，是因为当用户从应用中选择开启推送之后，系统会增加一些进程，这些进程会从苹果服务器接收信息，然后再通过服务器发给用户，苹果服务器在这里是起到了中转的作用。而正是因为有了这一系列的机制，所以即便iPhone的配置相比于同类安卓机低了很多，但是iOS还是会给人更加流畅的感觉。 iPhone执行程序的效率比安卓机高另外，安卓系统的编程语言是Java，特点是通用性强，效率低。而iOS的则为Objective-C，专一性强，效率高。 iOS系统本身优化得很好，而且程序也是直接执行，所以效率很高。而安卓系统是通过Java虚拟机来执行，系统需要占用大量内存来换取执行速度，也就是要绕了个大圈才执行程序，所以效率低很多。 厂商喜欢给iPhone做优化由于iOS的封闭性，App Store里面的App都是在iPhone等产品上执行，硬件利用效率非常高，而且分辨率大小，硬件的更新等等参数也比较稳定，优化工作也容易进行，因而iPhone上的App和硬件结合程度比安卓高很多。 安卓手机的硬件配置一样天天变，开发者也不可能针对所有的机器型号进行开发，只能在比较主流的机器上进行测试并保证运行流畅，所以很多国产中低端安卓手机很难得到流畅的使用体验。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"IOS","slug":"IOS","permalink":"https://baiyuan.wang/tags/IOS/"}]},{"title":"怎样使用office word向你的博客发布文章","slug":"how-to-publish-your-wordpress-post-by-word","date":"2015-02-25T02:53:32.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-publish-your-wordpress-post-by-word.html","link":"","permalink":"https://baiyuan.wang/how-to-publish-your-wordpress-post-by-word.html","excerpt":"","text":"使用wordpress的用户可能发现wordpress文章编辑器和微软的office word十分相似，但是wordpress自带的文章编辑器功能相对单一，要实现一些高级的编辑工作还要安装某些插件。其实，许多用户可能不知道，office word2007及其更高版本提供了向博客发布文章的功能。由于word强大的编辑功能，我相信使用word发布博客是个非常实用的经验。 打开word”文件”—“新建”选项卡，新建”博客文章”使用word你可以在没有网络的情况下进行离线编辑你的文章，没有必要每次发布你的文章时都要登录你的网站后台。 怎样使用office word向你的博客发布文章点击”博客文章”选项卡下”发布文章”菜单发布你的文章 使用word编辑博客文章的另一个好处是你还可以在本地保存一个word文档的文章副本，防止服务器问题导致的文章丢失事故的发生。 为文章添加分类点击”博客文章”选项卡下”插入类别”菜单选择文章的类别","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"倪光南正推进国产操作系统","slug":"niguangnan-and-cos","date":"2015-02-10T12:42:49.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"niguangnan-and-cos.html","link":"","permalink":"https://baiyuan.wang/niguangnan-and-cos.html","excerpt":"","text":"财经国家周刊2015年2月10日19:52 年逾七旬的中国工程院院士倪光南，最新标签已经变成“中国智能终端操作系统推动人”。 这个身份始于2013年冬，彼时，“中国智能终端操作系统产业联盟”刚成立，倪光南作为主要发起人，为联盟拉来了近百家成员单位。 “这不是好干的差事。”联盟秘书长曹冬说，“从开始，一些国外操作系统公司就明暗手段尽施，百般阻挠，倪院士压力非常大。” 倪光南倒不是十分在乎这些外部压力，他真正在意的，是来自内部的挑战：如何联合联盟成员，搭建一个统一的国产操作系统生态圈——事实上，这也是多年来，国产操作系统一直没能打开局面的主要原因。 筹划实体公司 岁末年初，中国智能终端操作系统产业联盟秘书长曹冬有一个重要的新任务——找人。 2014年年末，联盟的经济实体——一家以应用商店为核心业务的公司进入了工商注册审批阶段，倪光南和曹冬需要为公司找到一位总经理。 任务并不轻松。这位未来的掌舵人，不仅要熟悉桌面和智能终端操作系统的应用商店和生态系统市场推广运作，还必须兼具为中国自主操作系统大梦想奋斗的信仰。 即使不谈后者，单是运作一个操作系统的应用商店这一条，就足以吓跑大多数人。在微软、苹果、谷歌三分天下的操作系统领域，还没有第四家企业或操盘人能够依靠应用商店模式成功站稳脚跟。 但这看似最坚实的壁垒，却恰好是倪光南和联盟认定的突破口所在。 移动互联网时代，谷歌和苹果的操作系统能够杀出一条血路，所依仗的正是应用商店模式构建的软硬件生态系统。微软在移动互联网时代的没落，也是因为延误时机，没能成功推广基于Windows系统的应用商店。 而在中国，从事操作系统开发的厂商多达15家，绝大多数厂商都推出了正式发行版本的操作系统，但因为缺乏通用的应用软件，这些系统的应用范围都只局限在某个地方省市或者某一两个行业领域。 按照倪光南的设想，应用商店实体公司的作用，就是通过推出统一的应用商店，引导国产操作系统的众多开发方修改各自的系统，适应应用商店的标准，从而实现不同版本的统一。 对他的设想，质疑声音不少。理性一点的建议者提问：“15家国产操作系统开发商，怎么可能会为一个未成型的应用商店大改自己的系统？”偏激一点的批评者，则把矛头直指倪光南本人，说他“纯粹是为了骗取国家经费”。 倪光南从来不反驳“人身攻击”。他觉得做国产操作系统这件事实际上也是一场改革，也是对既有资源的再分配，各种利益团体鱼龙混杂，不理解和反对的声音是必然要出现的。 “把实体公司做起来，把事情做成了，就是对这些质疑最好的回应。”他说。 春风与蛋糕 没有形成统一的生态系统，的确是国产智能操作系统做大做强、实现自主可控的一大障碍。 其实，15家操作系统厂商都明白这个道理。思普集团董事长张龙说，相比微软而言，目前国内操作系统厂商的力量都还比较弱小，如果再分兵作战各人推广自家标准，行业发展将会难有成就。 “国内操作系统厂商就应该联合起来，壮大竞争力。未来，如果国内厂商能够采用统一的标准开发应用，将会促进整个国产操作系统的快速发展。”张龙说。 国家政策的引导，让当下成为了联合国内操作系统厂商的最好时机。 张龙已经明显感受到，2014年前后，国产操作系统的推广工作好做了很多。比如，2012年，思普在政府机关软件采购中连参与投标的资格都没有，微软等国际巨头则只凭借不确保兑现的投资建厂承诺，就能拿下地方政府的订单。2014年，部委和地方政府机关工作人员不仅主动与思普联系招标，多个政府和部委机构的国产操作系统替代工作，也都有了明确的时间表和路线图。 倪光南认为，大环境变好，政企用户的需求又不断增长，这对国产操作系统在应用商店的标准上保持统一，提出了客观要求。 现在的问题是，企业毕竟是企业，除了要有梦想还必须能“活”下来，因而或多或少都希望在这一轮国产化中，建立自己的话语权。 倪光南认为，企业的想法与联盟统一标准的宏愿并不矛盾。就好比谷歌的安卓系统，既有谷歌自己的应用商店，各家智能手机厂商也可以开发自家的应用商店，但前提是，大家的开发环境和接口标准都是一样的。 “谁能吃到更多蛋糕，那要由市场来决定，看谁的应用商店体验做得更好，服务支持更优秀，更符合用户的使用需求。”倪光南说。 市场大山 在最高决策层的推动下，政企用户市场已经破冰，横亘在国产操作系统面前的，是个人消费市场这座大山。 2014年，国产操作系统厂商中科红旗解散清算一案，成为国产操作系统标志性的事件，虽然背后有股东利益纠葛的缘故，但市场造血能力不足早已是业界公认的血淋淋教训。 最初，倪光南发起的联盟也制定了国产操作系统替代的时间表，希望在2014年10月推出支持应用商店的国产桌面操作系统新版本，首先在桌面实现国产化替代，然后在三五年内，从桌面系统扩展到移动端。 从2014年9月一直到年底，普华、中标麒麟、思普、开源软件创新联合实验室等联盟成员单位的新版操作系统相继发布，不过，由于应用商店实体公司一直没能成立，各家系统统一标准的愿望也未能实现。 倪光南认为，这就是鸡生蛋和蛋生鸡的关系，没有应用，就没人愿意用你的操作系统，没人用操作系统，就更没有人给你开发应用。 国产操作系统想要迈过市场关，就必须打破“有鸡没蛋或有蛋没鸡”的恶性循环。国家信息化专家咨询委员会委员曲成义说，改善应用生态，加大应用软件开发力度，做好应用服务支持，都是国产操作系统需要爬过的“高坡”。 倪光南现在想的就是，尽快找到合适的应用商店公司掌舵人，“车轮转起来了，一步步往前走，才有解决问题的可能，呆在原地只会陷入死循环。”","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"国产系统","slug":"国产系统","permalink":"https://baiyuan.wang/tags/%E5%9B%BD%E4%BA%A7%E7%B3%BB%E7%BB%9F/"}]},{"title":"上网只要点盏灯，可见光通信颠覆wifi？","slug":"lifi-replaces-wifi","date":"2015-02-06T13:19:48.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"lifi-replaces-wifi.html","link":"","permalink":"https://baiyuan.wang/lifi-replaces-wifi.html","excerpt":"","text":"有灯光的地方，就有网络信号。关掉灯，网络全无。复旦成功研制出利用屋内可见光传输网络信号。研究人员将网络信号接入一盏1W的LED灯珠，灯光下4台电脑即可上网，最高速率可达3.25G，平均上网速率150M，堪称世界最快的“灯光上网”。 未来的可见光通讯安全又经济 WiFi技术已经越来越普及，不过抱怨无线信号不稳定、上网速度慢、WiFi热点太少而用人却也越来越多。现在，Lifi可能帮助人们解决这样的问题。那什么是Lifi（Light Fidelity）？既可见光无线通信，是利用快速的光脉冲无线传输信息。 据了解，根据不同速率在光中编码信息完全可行，例如LED开表示1，关表示0，通过快速开关就能传输信息。由于LED的发光强度，人眼不会注意到光的快速变化LiFi技术。因全世界使用的灯泡却取之不尽，尤其在国内LED光源正在大规模取代传统白炽灯。只要在任何不起眼的LED灯泡中增加一个微芯片，便可让灯泡变成无线网络发射器。 与此同时，与现有WiFi相比，未来的可见光通讯安全又经济。WiFi依赖看不见的无线电波传输，设备功率越来越大，局部电磁辐射势必增强；无线信号穿墙而过，网络信息不安全。这些安全隐患，在可见光通讯中“一扫而光”。而且，光谱比无线电频谱大10000倍，意味着更大的带宽和更高的速度，网络设置又几乎不需要任何新的基础设施。 Lifi产业化发展才能走进千家万户 那 Lifi是否像wifi一样能走近千家万户呢？复旦大学信息科学与工程学院迟楠教授表示，Lifi技术也有其局限性。“因为，从灯光通讯控制到芯片设计制造等一系列关键技术产品，都是研究人员动手做，目前还没有商用的芯片组，要真正像WiFi那样走进千家万户，需要通过一系列的产业化发展，还有很长的路要走。”迟楠认为，Lifi技术本身也有其局限性，例如若灯光被阻挡，网络信号将被切断等等。 据悉，Lifi并不是WiFi的竞争对手，而是一种相互补充，有助于释放频谱空间。Lifi未来，能否产生杀手锏式的应用，还依赖人们无限的想象力：汽车间依靠LED车灯来“对话”，飞机客舱里乘客利用头顶的LED阅读灯来上网……","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"微信封杀支付宝红包与网易云音乐违法吗？","slug":"micro-envelope-alipay-red-envelope-with-netease-cloud-music-illegally","date":"2015-02-05T11:39:38.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"micro-envelope-alipay-red-envelope-with-netease-cloud-music-illegally.html","link":"","permalink":"https://baiyuan.wang/micro-envelope-alipay-red-envelope-with-netease-cloud-music-illegally.html","excerpt":"","text":"转载自网易科技（文&#x2F;游云庭） 近日，中国互联网巨头企业贴身肉搏式的竞争又起波澜，这次的主角是腾讯公司，他们先后在微信朋友圈停止了支付宝红包、虾米网、网易云音乐的客户端软件的应用接口，这就意味着微信用户无法通过移动客户端把支付宝红包、虾米和网易云音乐上的音乐内容发布到微信朋友圈中。 对于上述封杀事件，腾讯公司对外的表态基本是以暗示方式进行的：其暗示支付宝红包在朋友圈分享的行为是朋友圈恶意营销，破坏朋友圈体验，并且封杀支付宝红包和阿里巴巴公司没有在其平台上接入微信支付有关。而对于封杀虾米网、网易云音乐，则是暗示因为其存在盗版内容。 对此，我在一个法律微信群里讨论时提出，腾讯公司的封杀行为缺乏正当性，他们的声明就是打击竞争对手的借口。而另一位群友不同意我的观点，认为：“打击竞争对手”不正是竞争的本意吗？一个企业选择将自己的软件接口向谁开放，是一件不应受到责难的事情。即使降低了平台的价值，也是一种自主的选择，自然有市场来调节。这位朋友的观点是有市场经济理论依据的：微信是腾讯的产品，如果腾讯公司要打击竞争对手，并且愿意承受微信用户体验下降的损失，这当然是腾讯的权利。 但我不认同上述观点：无论从合理性还是合法性的角度，腾讯的行为和对外声明中的说辞都是无法接受的。从合理性上说： 如果你是一名微信、虾米、网易云音乐的共同用户，你想通过虾米或者网易云音乐给微信上的朋友分享一首歌曲，发现被腾讯禁止了，你会不会觉得此事不合理？ 如果你是一个应用开发者，发现腾讯为了保护自己的产品，禁止用户在微信上分享你的服务，理由是恶意营销，但腾讯自己一直在微信上做同样的事情，你会不会觉得此事不合理？ 你是一个音乐应用的运营者，虽然你花了几千万乃至上亿元买音乐版权，腾讯声称因为你的曲库里有少量比例的未授权歌曲而以盗版为由在微信里封杀你，实际QQ音乐的盗版歌曲比例跟你差不多甚至比你高，你会不会觉得此事不合理？ 好吧，听完上面的例子，如果你仍然认为市场经济是一个物竞天择、优胜劣汰的系统，微信是腾讯的地盘，存在的就是合理的，所以腾讯可以在微信上任性，那么我们再来探讨一下合法性的问题。市场经济是自由竞争的经济，但自由也是在法律框架下的，因此，腾讯的自由应当是在不违反法律规定前提条件下的，但腾讯任性的在微信里屏蔽了支付宝、虾米、网易云音乐实际违反了多部法律法规，影响到了数以亿记的个人和企业的合法权益。 违法一：上亿用户的消费者权益被侵害。 微信用户和腾讯什么关系？服务合同关系。用户加入微信时都要点击同意腾讯公司规定的用户协议才能注册账户，这个用户协议就是服务合同。除了服务合同，用户和腾讯的关系还受《消费者权益保护法》的制约。协议里基本都是腾讯的免责条款，而法律里多为保护用户权益的规定，效力上，法律比协议高。 根据《消费者权益保护法》第8、9、16、20条的规定，用户作为消费者，对腾讯公司享有对提供服务的查询权、知情权、自主选择权、公平交易权。这些问题上，腾讯公司的问题很大： 其屏蔽支付宝、虾米、网易云音乐时在微信上告知用户的理由是安全原因，但对外声明又说是恶意营销，阿里不对等开放，音乐软件有盗版。这些前后不一致的说法侵害了消费者的知情权。更关键的问题是，它们其实都缺乏正当性，腾讯的真实目的是打击竞争对手，就无理的拒绝向消费者提供原有的服务，逼着消费者只能用腾讯的服务，这个做法给用户带来了极大的不便，涉嫌侵犯微信用户的自主选择权、公平交易权。 根据公开的资料显示，支付宝钱包的用户数近两亿、虾米网和网易云音乐客户端则各有数千万的用户量，而微信的用户数则超过5亿，根据我个人保守估算，微信用户应该占到上面这三个应用的7成以上，因为腾讯公司的不兼容行为，至少一亿多用户没法使用自己合理合法可以使用的功能了。 违法二：对被屏蔽的软件构成不正当竞争。 腾讯为了打击竞争对手，禁止用户通过微信分享竞争对手服务，还涉嫌违反工信部《互联网信息服务市场秩序监督管理暂行办法》中的多项规定。 该办法第六条，互联网信息服务提供者在市场活动中不得有下列不正当竞争行为： (二)无正当理由，擅自对其他经营者提供的合法产品或服务实施不兼容；因非人为因素与已有的其他经营者提供的合法产品或服务不兼容时，未主动向用户进行客观提示，或欺骗、诱导用户做出选择； (三)干扰用户终端上其他经营者提供的合法产品或服务的运行，或者修改其他经营者提供的合法产品或服务的内容，或者拦截其他经营者提供的合法产品或服务的信息； 帖出来的两项，第二项腾讯是累犯，这条就是工信部为了其当年在3Q大战中不兼容360软件的行为而度身定做的，但这次又涉嫌违反了。第三项的规定从文义看也违反，关键是，腾讯的行为没有正当性，其理由都是牵强、前后矛盾的。 第八条互联网信息服务提供者应遵守《电信服务规范》的有关规定，不得有下列侵犯用户合法权益的行为： (一)无正当理由，单方面拒绝、拖延或中止向用户提供服务； (二)以任何方式限定用户使用其指定业务或者限制用户选择其他经营者依法提供的产品和服务； (三)利用虚假信息欺骗误导用户接受其提供的不公平服务条款或选择其提供的特定业务； (四)其他侵犯用户知情权、选择权的行为。 个人认为第八条的全部4项规定腾讯都涉嫌违反。 违法三：屏蔽竞争对手软件涉嫌垄断，滥用市场支配地位。 根据《反垄断法》规定，一个经营者在相关市场的市场份额达到二分之一的，可以推定经营者具有市场支配地位。具有市场支配地位的经营者不得没有正当理由，拒绝与交易相对人进行交易；不得没有正当理由搭售商品，或者在交易时附加其他不合理的交易条件。 如果腾讯在移动社交领域被认定市场占有率超过50%，其屏蔽行为就涉嫌违反《反垄断法》规定，用微信这个社交软件屏蔽竞争对手的服务根本上还是为了扶植微信支付、QQ音乐等自有产品，这是典型的滥用市场支配地位的行为。 但腾讯微信软件在社交软件市场的占有率有多高，是个有争议的问题，我们的法院在认定此问题时往往会给设立原告很高的举证门槛，《反垄断法》生效前两年法院受理的滥用市场支配地位案几乎无一例外的以市场占有率证据不足为由驳回了原告的诉讼请求。而发改委在认定市场支配地位时又相当的开放，几乎任何大企业都可以认定为在某个细分市场上占有率超过50%。 因此，如果此事诉讼解决的，技术上认定腾讯违反《反垄断法》的难度较高，但如果是工商行政总局对腾讯进行反垄断调查并进行处罚的，个人估计认定其具有市场支配地位是板上钉钉的。你认为这矛盾吗？是的，确实矛盾，但这就是目前中国《反垄断法》的法律适用现状。 对于如此之多的违法，微信用户能做什么？ 此次微信屏蔽事件，本质上是巨头间的火并，腾讯、阿里、网易都是体量巨大的上市公司，对于类似的损害消费者权益时间，他们中不少都有不光彩的历史，比如阿里早期禁止虾米客户端的用户在微信分享音乐，至今仍禁止淘宝用户在微信分享淘宝的链接，网易则拒绝用户在视频网站直播网易游戏的视频，直接封杀分享用户的账户。巨头如何竞争用户可以看戏，但如果因为他们的竞争用户的利益受损了，用户就应当拿起法律武器保护自己的权益，下面以介绍几条途径： 一、《消费者权益保护法》下的维权途径。 《消费者权益保护法》第三十九条规定：消费者和经营者发生消费者权益争议的，可以通过下列途径解决：与经营者协商和解、请求消费者协会或者依法成立的其他调解组织调解、向有关行政部门投诉。因此，微信用户可以向消保委投诉腾讯，也可以向国家工商总局或者腾讯公司所在地工商局投诉腾讯公司侵害消费者的知情权、自主选择权、公平交易权。 二、《反不正当竞争法》下的维权途径。 《互联网信息服务市场秩序监督管理暂行办法》规定：用户与互联网信息服务提供商之间发生服务争议时，用户可向全国电信用户申诉受理中心和省、自治区、直辖市电信用户申诉受理机构提出申诉，申诉受理机构依法按照《电信用户申诉处理暂行办法》处理。 《电信用户申诉处理暂行办法》则规定，用户先向电信业务经营者(也就是腾讯公司，其为增值电信业务经营者)投诉，电信业务经营者应当认真受理用户的投诉，并在接到用户投诉之日起15个工作日内答复用户。用户对电信业务经营者的处理结果不满意或者电信业务经营者在接到投诉后15个工作日内未答复的，可以向申诉受理机构提出申诉。申诉人应当向被申诉人所在省，自治区、直辖市的申诉受理机构提出申诉。被申诉人所在省、自治区、直辖市没有设立申诉受理机构的，申诉人可以向全国电信用户申诉受理中心提出申诉。 三、《反垄断法》下的维权途径。 《反垄断法》第三十八条规定：反垄断执法机构依法对涉嫌垄断行为进行调查。对涉嫌垄断行为，任何单位和个人有权向反垄断执法机构举报。反垄断执法机构应当为举报人保密。举报采用书面形式并提供相关事实和证据的，反垄断执法机构应当进行必要的调查。本案涉及的垄断行为其管辖权限应该在工商总局，因此，用户也可以向国家工商总局举报腾讯公司滥用市场地位损害消费者合法权益的行为。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"wordpress使用tinection主题怎样节省流量","slug":"tinection-themes-wordpress-how-to-save-traffic","date":"2015-01-31T07:51:17.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"tinection-themes-wordpress-how-to-save-traffic.html","link":"","permalink":"https://baiyuan.wang/tinection-themes-wordpress-how-to-save-traffic.html","excerpt":"","text":"做博客站以来，笔者换了不少主题，最后决定使用的是知言创作的tinection主题，这是一款个人认为非常优秀的wordpress主题，但是其缺点也很明显：速度太慢，因为tinection主题代码里加载了太多css，js文件，导致向服务器请求次数极多，好在知言更新主题的速度较快，希望能在以后的更新中精简一下代码和减少文件请求次数。 除了上述缺点，tinection还有一个问题：它耗费流量太大。之前笔者使用的欲思主题在仅本人调试访问的情况下一个月才花费1个G流量，而现在的tinection主题一天就要花费近300M流量，而且扪心自问网站的访问频次并没有之前使用欲思主题的次数多。而对于个人用户来说，大家一般使用的是虚拟主机，空间商提供的月流量常常有限，而且即使使用CDN加速，按照tinection主题的这样的“耗油量”也不够花，为此，笔者琢磨了一下主题的代码，向大家介绍一个实用的wordpress使用tinection主题怎样节省流量的方法。 减少随机缩略图的张数tinection的文章列表和相关列表都为无图文章随机分配缩略图，但是很“鸡肋”的是随机分配的所有图片竟然有40张之多，其实由于随机分配图片，减少图片张数并不能节省流量，但是在大多数使用了“静态文件缓存”的博客站来说，太多的随机图片将使访问者很难碰到之前缓存的同一文件。所以减少缩略图以提高缓存文件命中概率，是省流量的可行方法。 具体方法：在主题文件夹themes\\tinection\\下找到functions.php，搜索“$random &#x3D; mt_rand”，这是个产生随机数的函数，你可以根据需要设置为你想要的图片张数。 例如笔者只想使用15张： $random &#x3D; mt_rand(1, 15); 这样主题只会调用tinection主题随机图片文件夹“tinection\\images\\random\\”下的“1~15.jpg”图片 推荐：降低缩略图质量减少流量笔者通过“审查元素”发现，tinection主题缩略图大小偏大，而且极其可笑的是，竟然有的缩略图片比原图片还大不少。其中有一个原图片54K，缩略之后竟然达到102K！对于大量使用的tinection主题将耗费太多不必要的流量。笔者经过修改代码后把这个图片大小降到了14K，而且图片质量影响不大。 具体方法：在主题文件夹themes\\tinection\\下找到functions.php，搜索“function tin_thumb_source”，将该函数内容改成： &#x2F;* 缩略图采用类型&#x2F;* ----------------- *&#x2F;function tin_thumb_source($src,$w&#x3D;300,$h&#x3D;200,$customize&#x3D;true){ $timthumb &#x3D; ot_get_option(‘timthumb’); $cloudimgsuffix &#x3D; ot_get_option(‘cloudimgsuffix’); if($timthumb&#x3D;&#x3D;&#x3D;’on’){ if(tin_is_mobile()&#x3D;&#x3D;true){&#x2F;&#x2F;判断是否是移动设备 $img &#x3D; get_bloginfo(‘template_url’).’&#x2F;functions&#x2F;timthumb.php?src&#x3D;’.$src.’&amp;q&#x3D;30&amp;w&#x3D;’.$w.’&amp;h&#x3D;’.$h.’&amp;zc&#x3D;1’;}&#x2F;&#x2F;移动设备图片质量为30 else{ $img &#x3D; get_bloginfo(‘template_url’).’&#x2F;functions&#x2F;timthumb.php?src&#x3D;’.$src.’&amp;q&#x3D;80&amp;w&#x3D;’.$w.’&amp;h&#x3D;’.$h.’&amp;zc&#x3D;1’;}&#x2F;&#x2F;默认图片质量为80 &#125;else&#123; if(empty($cloudimgsuffix)||$customize==false) $cloudimgsuffix = &#39;?imageView2/1/w/&#39;.$w.&#39;/h/&#39;.$h.&#39;/q/100&#39;; $img = $src.$cloudimgsuffix; &#125; return $img; } 其中笔者把移动设备的缩略图质量设置成了20，其它设备设置成了80，大家可以根据自己的需要修改。还有需要指出的是，经本人实践，本主题的缩略图功能对png格式图片缩略效果极差，甚至增加原图片大小，建议大家写文章时插入jpg格式图片。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"}]},{"title":"wordpress无插件实现六个经典功能","slug":"wordpress-plugin-free-six-classic-features","date":"2015-01-29T01:14:29.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"wordpress-plugin-free-six-classic-features.html","link":"","permalink":"https://baiyuan.wang/wordpress-plugin-free-six-classic-features.html","excerpt":"","text":"wordpress建站系统为我们提供了丰富的插件功能，但是使用太多的插件往往会拖慢网站的速度，其实一些小插件的功能我们完全可以自己用代码实现，下面是我为大家整理的一些wordpress经典功能的无插件纯代码实现方法，代码来自互联网。如果没有特殊说明，下面的代码请放在主题文件夹（…&#x2F;wp-content&#x2F;themes&#x2F;你的主题&#x2F;）的模板函数functions.php文件里，修改方法：将下面代码复制粘贴到functions.php的局域内。 wordpress无插件实现六个经典功能修改wordpress代码实现smtp邮件功能相关插件：easy wp smtp 下载地址（(经本人汉化)）[button class&#x3D;”download” size&#x3D;”lg” href&#x3D;”http://pan.baidu.com/s/1mgqV5Rq“ title&#x3D;”easy wp smtp”]密码：0bmd [&#x2F;button] &#x2F;&#x2F;使用smtp发邮件add_action(‘phpmailer_init’, ‘mail_smtp’);function mail_smtp( $phpmailer ) {$phpmailer-&gt;IsSMTP();$phpmailer-&gt;SMTPAuth &#x3D; true;&#x2F;&#x2F;启用SMTPAuth服务$phpmailer-&gt;Port &#x3D; 465;&#x2F;&#x2F;MTP邮件发送端口，这个和下面的对应，如果这里填写25，则下面为空白$phpmailer-&gt;SMTPSecure &#x3D;”ssl”;&#x2F;&#x2F;是否验证 ssl，这个和上面的对应，如果不填写，则上面的端口须为25$phpmailer-&gt;Host &#x3D;”smtp.gmail.com”;&#x2F;&#x2F;邮箱的SMTP服务器地址，如果是QQ的则为：smtp.exmail.qq.com$phpmailer-&gt;Username &#x3D; “&#x61;&#100;&#109;&#105;&#110;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;“;&#x2F;&#x2F;你的邮箱地址$phpmailer-&gt;Password &#x3D;”******”;&#x2F;&#x2F;你的邮箱登陆密码} WordPress无插件代码实现评论回复邮件通知 &#x2F;&#x2F;comment_mail_notify(所有的回复都会发邮件通知) function comment_mail_notify($comment_id) {$comment &#x3D; get_comment($comment_id);$parent_id &#x3D; $comment-&gt;comment_parent ? $comment-&gt;comment_parent : ‘’;$spam_confirmed &#x3D; $comment-&gt;comment_approved;if (($parent_id !&#x3D; ‘’) &amp;&amp; ($spam_confirmed !&#x3D; ‘spam’)) {$wp_email &#x3D; ‘no-reply@’ . preg_replace(‘#^www.#’, ‘’, strtolower($_SERVER[‘SERVER_NAME’]));&#x2F;&#x2F;发件人e-mail地址$to &#x3D; trim(get_comment($parent_id)-&gt;comment_author_email);$subject &#x3D; ‘您在[‘.get_option(“blogname”).’]的留言有了回复’;$message &#x3D; ‘ '.trim(get\\_comment($parent\\_id)->comment_author).', 您好! 这是您在《'.get\\_the\\_title($comment->comment\\_post\\_ID).'》中的留言:' .trim(get\\_comment($parent\\_id)->comment_content).' 以下是'.trim($comment->comment_author).' 给您的回复:' .trim($comment->comment_content).' 您可以点击这里查看回复的完整内容. 欢迎再度光临 ' . get\\_option('blogname') . ' (注:此邮件由系统自动发出,请勿回复!) '; $from = \"From: \"\" . get\\_option('blogname') . \"\" \"; $headers = \"$fromnContent-Type: text/html; charset=\" . get\\_option('blog\\_charset') . \"n\"; wp_mail( $to, $subject, $message, $headers ); //echo 'mail to ', $to, ' ' , $subject, $message; // for testing } } add\\_action('comment\\_post', 'comment\\_mail\\_notify'); 文章图片自动添加alt和title信息&#x2F;* 文章图片自动添加alt和title信息 *&#x2F;function tin_image_alt($content){global $post;$pattern &#x3D; “&#x2F;&lt;img(.*?)src&#x3D;(‘|\\“)(.*?).(bmp|gif|jpeg|jpg|png)(‘|\\“)(.*?)&gt;&#x2F;i”;$replacement &#x3D; ‘&lt;img$1src&#x3D;$2$3.$4$5 alt&#x3D;”‘.$post-&gt;post_title.’” title&#x3D;”‘.$post-&gt;post_title.’”$6&gt;’;$content &#x3D; preg_replace($pattern,$replacement,$content);return $content;}add_filter(‘the_content’,’tin_image_alt’,15); WordPress文字标签关键词自动内链 &#x2F;* WordPress文字标签关键词自动内链*&#x2F;$match_num_from &#x3D; 1; &#x2F;&#x2F;一篇文章中同一個標籤少於幾次不自動鏈接$match_num_to &#x3D; 4; &#x2F;&#x2F;一篇文章中同一個標籤最多自動鏈接幾次function tag_sort($a, $b){if ( $a-&gt;name &#x3D;&#x3D; $b-&gt;name ) return 0;return ( strlen($a-&gt;name) &gt; strlen($b-&gt;name) ) ? -1 : 1;}function tin_tag_link($content){global $match_num_from,$match_num_to;$posttags &#x3D; get_the_tags();if ($posttags) {usort($posttags, “tag_sort”);$ex_word &#x3D; ‘’;$case &#x3D; ‘’;foreach($posttags as $tag) {$link &#x3D; get_tag_link($tag-&gt;term_id);$keyword &#x3D; $tag-&gt;name;$cleankeyword &#x3D; stripslashes($keyword);$url &#x3D; “&lt;a href&#x3D;\\“$link\\“ class&#x3D;\\“tooltip-trigger tin\\“ title&#x3D;\\“”.str_replace(‘%s’,addcslashes($cleankeyword, ‘$’),__(‘查看更多关于 %s 的文章’)).”\\“”;$url .&#x3D; ‘ target&#x3D;”_blank”‘;$url .&#x3D; “&gt;”.addcslashes($cleankeyword, ‘$’).”“;$limit &#x3D; rand($match_num_from,$match_num_to);$content &#x3D; preg_replace( ‘|(&lt;a[^&gt;]+&gt;)(.)&lt;pre.*?&gt;(‘.$ex_word.’)(.)&lt;\\&#x2F;pre&gt;(&lt;&#x2F;a[^&gt;]&gt;)|U’.$case, ‘$1$2$4$5’, $content);$content &#x3D; preg_replace( ‘|(&lt;img)(.*?)(‘.$ex_word.’)(.*?)(&gt;)|U’.$case, ‘$1$2$4$5’, $content);$cleankeyword &#x3D; preg_quote($cleankeyword,’\\‘’);$regEx &#x3D; ‘\\‘(?!((&lt;.*?)|(&lt;a.*?)))(‘. $cleankeyword . ‘)(?!(([^&lt;&gt;]?)&gt;)|([^&gt;]*?))\\‘s’ . $case;$content &#x3D; preg_replace($regEx,$url,$content,$limit);$content &#x3D; str_replace( ‘’, stripslashes($ex_word), $content);}}return $content;}add_filter(‘the_content’,’tin_tag_link’,12); Avatar改用多说gravatar服务器或SSL链接 &#x2F;* Avatar改用多说gravatar服务器或SSL链接 &#x2F;function mytheme_get_avatar($avatar) {if(ot_get_option(‘gravatar_source’) &#x3D;&#x3D; ‘duoshuo’){$avatar &#x3D; str_replace(array(“","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"怎样为wordpress导航菜单设置图标","slug":"how-to-wordpress-directory-settings-icon","date":"2015-01-28T08:48:55.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"how-to-wordpress-directory-settings-icon.html","link":"","permalink":"https://baiyuan.wang/how-to-wordpress-directory-settings-icon.html","excerpt":"","text":"访问本站的朋友可以发现，笔者的导航菜单是带图标的，而wordpress导航菜单默认是没有图标的，下面是我的博客图示效果： 而且这些图标就像文字一样，可以改变它的颜色，可以美化我们的网页界面。在此，抛砖引玉出一个名词：Font Awesome Font Awesome介绍Font Awesome是一款很流行的字体图标工具。随着Bootstrap的流行而逐渐被人所认识，现在FontAwesome不仅仅可以在bt上使用，还可以应用在各种web前端开发中。相对于传统的使用背景图片作为图标，字体图标主要是支持自适应、可以使用字体的各种特性（比如变色、变大变小、字体阴影等）、减少数据加载、样式更容易定义等。 Font Awesome 特性 一个字体文件， 369 个图标。 不需要JavaScript要求：更快的载入速度 无限的可扩展性：可伸缩矢量图形意味着每一个图标在任何大小看起来真棒。 自由免费：你可以将它应用到你的商业中。 CSS控制：轻松的定义图标的颜色，大小，阴影，和任何与CSS相关的特性。 完美的视网膜显示：使用矢量字体，这意味着他们可以完美的显示在高分辨率显示器中 为BootStrap而生：完全的兼容BootStrap新版3.0 桌面友好：你可以查看字体的样式列表 兼容屏幕阅读器：不像其他字体图标不兼容屏幕阅读器 Font Awesome的使用 你只需要到：http://fontawesome.io 下载压缩包然后解压到你的项目中。 在你的HTML头部的head里面添加对相应的font-awesome的样式。 根据这里的案例开始你的项目。 如需兼容IE浏览器，可以使用Font-awesome的3.2.1版本。下载font-awesome-ie7.css或者是font-awesome-ie7.min.css。然后在项目中引入该样式文件。 然后在wordpress后台-菜单编辑中设置某个菜单比如首页的导航标签属性为： 首页 现在一般的主题都已经引用了Font Awesome，你不妨直接尝试最后一步，看是否能成功加载图标，这样能省去你的许多时间","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"FontAwesome","slug":"FontAwesome","permalink":"https://baiyuan.wang/tags/FontAwesome/"}]},{"title":"码农、黑客和2B程序员之间的区别","slug":"difference-between-three-kinds-of-programers","date":"2015-01-27T05:37:32.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"difference-between-three-kinds-of-programers.html","link":"","permalink":"https://baiyuan.wang/difference-between-three-kinds-of-programers.html","excerpt":"","text":"笔记本电脑黑客： 码农： 2B程序员： 求2的32次方：码农： System.out.println(Math.pow(2, 32)); 黑客： System.out.println(1L&lt;&lt;32); 2B程序员： System.out.println(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2); 交换两个数：码农： void swap(int &amp;a,int &amp;b){ int temp; temp&#x3D;a; a&#x3D;b; b&#x3D;temp;} 黑客： void swap(int &amp;a,int &amp;b){ a=a^b; b=a^b; a=a^b; } 2B程序员： void swap(int a,int b){ int temp; temp&#x3D;a; a&#x3D;b; b&#x3D;temp;} 类属性定义：码农： public static int TYPE &#x3D; 1; 黑客： &#x2F;*** 此策略下消息类型为全局类型，用以通知所有符合B05协议要求的处理者* …… ……*&#x2F;public static int TYPE &#x3D; MsgTypes.TYPE_GLOBAL; 2B程序员： public static String TYPE_ONE &#x3D; “1”;public String TYPE &#x3D; TYPE_ONE; 手机开发平台：码农：WinCE&#x2F;BlackBerry&#x2F;Symbian&#x2F;Android 黑客：iPhone 2B程序员：MTK 桌面应用界面开发：码农：Swing&#x2F;MFC&#x2F;C# 黑客：WPF 2B程序员：VB(哈哈，不要怪我，我也做过VB项目，我没有偏见，不过关于VB的非议实在是太多太多了，连Dijkstra都说，“It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.”) 即时通讯软件：码农：工作：MSN，生活：Skype 黑客： 工作：GTalk、生活：保密 2B程序员： 工作：腾讯QQ，生活：QQ 问题查询：码农： Google搜索 黑客： Google Scholar&#x2F;Scirus 2B程序员： 百度知道 Window 死机的解决方案：码农： 根据异常信息搜索问题原因和解决方法 黑客： 哥从懂事起就不用Windows的! 2B程序员： 重装系统(万能解决方案)，安装360 个人Blog：码农： CSDN&#x2F;CNBlogs&#x2F;BlogBus 黑客： 个人站(俺不是自夸啊，哈哈) 2B程序员： QQ空间 面试地点：码农： 会议室&#x2F;教室 黑客： 咖啡厅 2B程序员： 食堂 Java面试题目：码农： 请分别说一说封装、继承和多态的含义? 黑客： 如果要设计一个系统，用来统计世界上所有道路的总数，你会怎样设计? 2B程序员： 请说说Spring2.5.6版本和2.5.5版本的区别? 仅此一笑，你还有什么更有意思的程序员版本? 原文：http://www.techug.com/the-diffenents-between-coder-hacker-and-2b-programmer","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[]},{"title":"21 个非常有用的 .htaccess 提示和技巧","slug":"21-htaccess-skills","date":"2015-01-15T09:11:54.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"21-htaccess-skills.html","link":"","permalink":"https://baiyuan.wang/21-htaccess-skills.html","excerpt":"","text":"Apache Web 服务器可以通过 .htaccess 文件来操作各种信息，这是一个目录级配置文件的默认名称，允许去中央化的 Web 服务器配置管理。可用来重写服务器的全局配置。该文件的目的就是为了允许单独目录的访问控制配置，例如密码和内容访问。在做网站的时候常常用到很多.htaccess 规则，我给大家总结了21 个非常有用的 .htaccess 提示和技巧 下面是 21 个非常有用的 .htaccess 配置的提示和技巧： 1. 定制目录的 Index 文件 DirectoryIndex index.html index.php index.htm 你可以使用上面的配置来更改目录的默认页面，例如你将这个脚本放在 foo 目录，则用户请求 &#x2F;foo&#x2F; 时候就会访问 &#x2F;foo&#x2F;index.html。 2. 自定义错误页ErrorDocument 404 errors&#x2F;404.html 当用户访问页面报错时，例如页面找不到你希望显示自定义的错误页面，你可以通过这种方法来实现。或者是动态的页面： ErrorDocument 404 &#x2F;psych&#x2F;cgi-bin&#x2F;error&#x2F;error?404 3. 控制访问文件和目录的级别.htaccess 经常用来限制和拒绝访问某个文件和目录，例如我们有一个 includes 文件夹，这里存放一些脚本，我们不希望用户直接访问这个文件夹，那么通过下面的脚本可以实现： # no one gets in here!deny from all 上述脚本是拒绝所有的访问，你也可以根据IP段来拒绝： # no nasty crackers in here!order deny,allowdeny from allallow from 192.168.0.0&#x2F;24# this would do the same thing..#allow from 192.168.0 一般这些方法是通过防火墙来处理，但在一个生产环境中的服务器来说，这样的调整非常方便。 有时候你只是想禁止某个ip访问： # someone else giving the ruskies a bad name..order allow,denydeny from 83.222.23.219allow from all 4. 修改环境变量环境变量包含了服务器端 CGI 的一些扩展信息，可使用 SetEnv 和 UnSetEnv 进行设置以及取消设置. SetEnv SITE_WEBMASTER “Jack Sprat”SetEnv SITE_WEBMASTER_URI mailto:&#74;&#x61;&#99;&#107;&#46;&#83;&#x70;&#114;&#x61;&#116;&#64;&#x63;&#104;&#x61;&#114;&#x61;&#99;&#116;&#101;&#114;&#111;&#108;&#x6f;&#x67;&#121;&#46;&#99;&#x6f;&#x6d; UnSetEnv REMOTE_ADDR 5. 301 重定向如果你希望某个页面跳转到新的页面： Redirect 301 &#x2F;old&#x2F;file.html http://yourdomain.com/new/file.html 下面可以实现对整个路径的重定向 RedirectMatch 301 &#x2F;blog(.*) http://yourdomain.com/$1 6. 通过 .htaccess 实现缓存策略通过设置在浏览器上缓存静态文件可以提升网站的性能： # year&lt;FilesMatch”.(ico|pdf|flv|jpg|jpeg|png|gif|swf|mp3|mp4)$”&gt;Header set Cache-Control “public”Header set Expires “Thu, 15 Apr 2010 20:00:00 GMT”Header unset Last-Modified#2 hours&lt;FilesMatch”.(html|htm|xml|txt|xsl)$”&gt;Header set Cache-Control “max-age&#x3D;7200, must-revalidate”&lt;FilesMatch”.(js|css)$”&gt;SetOutputFilter DEFLATEHeader set Expires “Thu, 15 Apr 2010 20:00:00 GMT” 7. 使用 GZIP 对输出进行压缩在 .htaccess 中添加下面的代码可以将所有的 css、js 和 html 使用 GZIP 算法压缩： &lt;IfModulemod_gzip.c&gt; mod_gzip_on Yes mod_gzip_dechunk Yes mod_gzip_item_include file .(html?|txt|css|js|php|pl)$ mod_gzip_item_include handler ^cgi-script$ mod_gzip_item_include mime ^text&#x2F;.* mod_gzip_item_include mime ^application&#x2F;x-javascript.* mod_gzip_item_exclude mime ^image&#x2F;.* mod_gzip_item_exclude rspheader ^Content-Encoding:.*gzip.* 使用上面代码的前提是启用 mod_gzip 模块，你可以使用下面脚本来判断 Web 服务器是否提供 mod_deflate 支持： SetOutputFilter DEFLATE SetEnvIfNoCase Request_URI .(?:gif|jpe?g|png)$ no-gzip dont-vary SetEnvIfNoCase Request_URI .(?:exe|t?gz|zip|gz2|sit|rar)$ no-gzip dont-vary 如果 Web 服务器不支持 mod_deflate ，那么可使用下面方法： &lt;FilesMatch”.(txt|html|htm|php)”&gt; php_value output_handler ob_gzhandler 更多关于压缩的内容请阅读: Compressing PHP, CSS, JavaScript(JS). 8. 强制要求使用 HTTPS 访问通过以下脚本可以强制整个网站必须使用 https 方式访问： RewriteEngine OnRewriteCond %{HTTPS} !onRewriteRule (.*) https:&#x2F;&#x2F;%{HTTP_HOST}%{REQUEST_URI} 9. URL 重写例如要将 product.php?id&#x3D;12 重写为 product-12.html RewriteEngine onRewriteRule ^product-([0-9]+).html$ product.php?id&#x3D;$1 将 product.php?id&#x3D;12 重写为 product&#x2F;ipod-nano&#x2F;12.html RewriteEngine onRewriteRule ^product&#x2F;([a-zA-Z0-9_-]+)&#x2F;([0-9]+).html$ product.php?id&#x3D;$2 重定向没有 www 到有 www 的 URL 地址： RewriteEngine OnRewriteCond %{HTTP_HOST} ^viralpatel.net$RewriteRule (.*) http://www.viralpatel.net/$1 [R&#x3D;301,L] 重写 yoursite.com&#x2F;user.php?username&#x3D;xyz 到 yoursite.com&#x2F;xyz RewriteEngine OnRewriteRule ^([a-zA-Z0-9_-]+)$ user.php?username&#x3D;$1RewriteRule ^([a-zA-Z0-9_-]+)&#x2F;$ user.php?username&#x3D;$1 重定向某个域名到一个 public_html 里新的子文件夹： RewriteEngine OnRewriteCond %{HTTP_HOST} ^test.com$ [OR]RewriteCond %{HTTP_HOST} ^www.test.com$RewriteCond %{REQUEST_URI} !^&#x2F;new&#x2F;RewriteRule (.*) &#x2F;new&#x2F;$1 10. 阻止列出目录文件使用下面代码可以防止列表目录里的所有文件： Options -Indexes 或者 IndexIgnore * 更多详情 Denying&#x2F;Allowing directory listing. 11. 添加新的 MIME-TypesMIME-types 依赖于文件的扩展名，未能被识别的文件扩展名会当成文本数据传输 AddType application&#x2F;x-endnote-connection enzAddType application&#x2F;x-endnote-filter enfAddType application&#x2F;x-spss-savefile sav 12. 防盗链你不希望别人网站引用你站内的图片、css 等静态文件，也就是传说中的防盗链，可以使用如下脚本： RewriteCond %{HTTP_REFERER} !^$RewriteCond %{REQUEST_URI} !^&#x2F;(wp-login.php|wp-admin&#x2F;|wp-content&#x2F;plugins&#x2F;|wp-includes&#x2F;).* [NC]RewriteCond %{HTTP_REFERER} !^http://www.askapache.com.*$ [NC]RewriteRule .(ico|pdf|flv|jpg|jpeg|mp3|mpg|mp4|mov|wav|wmv|png|gif|swf|css|js)$ - [F,NS,L] 13. 指定上传文件的大小限制，适用于 PHPphp_value upload_max_filesize 20Mphp_value post_max_size 20Mphp_value max_execution_time 200php_value max_input_time 200 上述脚本中，通过四个参数来设置上传文件的限制，第一个参数是文件的大小，第二个是 POST 数据的大小，第三个是传输的时间（单位秒），最后一个是解析上传数据最多花费的时间（单位秒） 14. 禁止脚本执行Options -ExecCGIAddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi 15. 修改字符集和语言头AddDefaultCharset UTF-8DefaultLanguage en-US 16. 设置服务器时区(GMT)SetEnv TZ America&#x2F;Indianapolis 17. 强制 “File Save As” 提示AddType application&#x2F;octet-stream .avi .mpg .mov .pdf .xls .mp4 18. 保护单个文件正常情况下 .htaccess 可用于限制整个目录的访问，但也可以只限制某个文件： &lt;Filesquiz.html&gt;order deny,allowdeny from allAuthType BasicAuthName “Characterology Student Authcate”AuthLDAP onAuthLDAPServer ldap:&#x2F;&#x2F;directory.characterology.com&#x2F;AuthLDAPBase “ou&#x3D;Student, o&#x3D;Characterology University, c&#x3D;au”require valid-usersatisfy any 19. 设置 Cookie通过环境变量来设置 Cookie Header set Set-Cookie “language&#x3D;%{lang}e; path&#x3D;&#x2F;;” env&#x3D;lang 基于请求设置 Cookie，该代码发送 Set-Cookie 头用于设置 Cookie 值为第二个括号里的匹配项 RewriteEngine OnRewriteBase &#x2F;RewriteRule ^(.*)(de|es|fr|it|ja|ru|en)&#x2F;$ - [co&#x3D;lang:$2:.yourserver.com:7200:&#x2F;] 20. 设置自定义的响应 HeadersHeader set P3P “policyref&#x3D;”http://www.askapache.com/w3c/p3p.xml“”Header set X-Pingback “http://www.askapache.com/xmlrpc.php“Header set Content-Language “en-US”Header set Vary “DontTrackMeHere” 21. 根据 User-Agent 来阻止请求SetEnvIfNoCase ^User-Agent$ .(craftbot|download|extract|stripper|sucker|ninja|clshttp|webspider|leacher|collector|grabber|webpictures) HTTP_SAFE_BADBOTSetEnvIfNoCase ^User-Agent$ .(libwww-perl|aesop_com_spiderman) HTTP_SAFE_BADBOTDeny from env&#x3D;HTTP_SAFE_BADBOT 英文原文， OSCHINA原创翻译 &lt;filesmatch “.(ico|pdf|flv|jpg|jpeg|png|gif|swf|mp3|mp4)$”&#x3D;””&gt;&lt;filesmatch “.(html|htm|xml|txt|xsl)$”&#x3D;””&gt;&lt;filesmatch “.(js|css)$”&#x3D;””&gt;&lt;filesmatch “.(txt|html|htm|php)”&#x3D;””&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"}]},{"title":"致我们早已逝去的童年","slug":"to-our-childhood-which-has-gone","date":"2015-01-13T14:21:06.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"to-our-childhood-which-has-gone.html","link":"","permalink":"https://baiyuan.wang/to-our-childhood-which-has-gone.html","excerpt":"","text":"最近小学同学建了QQ群，聊得不亦乐乎。 其实，彼此的容颜早已不再，彼此相处的岁月早就模糊，而维系这十年一别后聊天时滔滔不绝的，是那段一同度过的童年，一同坐过的教室，甚至还依稀记得的一个姓名。 谈论间，仿佛童年又在眼前。而如今，昔日同窗，有的还在读大学，有的已经成家立业，生儿育女，不禁油然而发一种岁月匆匆，到乡翻似烂柯人的感慨。感慨之余，只觉得自己还是个长不大的孩子，不谙世事，问问自己:少年，你该当如何成熟起来。 ——致我们早已逝去的童年","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[]},{"title":"wordpress文件结构和函数帮助文档大全","slug":"wordpress-filestructure-function-api","date":"2015-01-13T00:08:00.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"wordpress-filestructure-function-api.html","link":"","permalink":"https://baiyuan.wang/wordpress-filestructure-function-api.html","excerpt":"","text":"WordPress模板基本文件模板基本文件（在你的网站根目录&#x2F;wp-content&#x2F;themes&#x2F;下） style.css 样式表文件 index.php 主页文件 single.php 日志单页文件 page.php 页面文件 archvie.php 分类和日期存档页文件 searchform.php 搜索表单文件 search.php 搜索页面文件 comments.php 留言区域文件(包括留言列表和留言框) 404.php 404错误页面 header.php 网页头部文件 sidebar.php 网页侧边栏文件 footer.php 网页底部文件 WordPress Header头部 PHP代码（注: 也就是位于和之间的PHP代码） 网站标题 日志或页面标题 WordPress主题样式表文件style.css的相对地址 WordPress博客的Pingback地址 WordPress主题文件的相对地址 博客的WordPress版本 WordPress博客的Atom地址 WordPress博客的RSS2地址 WordPress博客的绝对地址 WordPress博客的名称 网站的HTML版本 网站的字符编码格式 WordPress 主体模板 PHP代码 日志内容 确认是否有日志 如果有，则显示全部日志 结束PHP函数”while” 结束PHP函数”if” header.php文件的内容 sidebar.php文件的内容 footer.php文件的内容 显示格式为”02-19-08″的日期 显示一篇日志的留言链接 显示一篇日志或页面的标题 显示一篇日志或页面的永久链接&#x2F;URL地址 显示一篇日志或页面的所属分类 显示一篇日志或页面的作者 显示一篇日志或页面的ID 显示一篇日志或页面的编辑链接 显示Blogroll中的链接 comments.php文件的内容 显示一份博客的页面列表 显示一份博客的分类列表 下一篇日志的URL地址 上一篇日志的URL地址 调用日历 显示一份博客的日期存档列表 显示较新日志链接(上一页)和较旧日志链接（下一页） 显示博客的描述信息 其它的一些WordPress模板代码 &#x2F;%postname%&#x2F; 显示博客的自定义永久链接 搜索表单的值 打印输出信息 显示注册链接 显示登入&#x2F;登出链接 &lt;!–next page–&gt; 在日志或页面中插入分页 &lt;!–more–&gt; 截断日志 显示管理员的相关控制信息 显示载入页面的时间 显示载入页面查询 wordpress调用最新、最热、随机文章1. wordpress调用最新文章 WordPress最新文章的调用可以使用一行很简单的模板标签wp_get_archvies来实现. 代码如下： (显示10篇最新更新文章) 或者 后面这个代码显示你博客中最新的20篇文章，其中format&#x3D;custom这里主要用来自定义这份文章列表的显示样式。具体的参数和使用方法你可 以参考官方的使用说明- wp_get_archvies。(fromat&#x3D;custom也可以不要，默认以UL列表显示文章标题。) 补充: 通过WP的query_posts()函数也能调用最新文章列表， 虽然代码会比较多一点，但可以更好的控制Loop的显示，比如你可以设置是否显示摘要。具体的使用方法也可以查看官方的说明。 2. wordpress调用随机文章 &lt;!–下面是你想自定义的Loop–&gt; 3. wordpress调用最新留言下面是我之前在一个WordPress主题中代到的最新留言代码，具体也记不得是哪个主题了。该代码直接调用数据库显示一份最新留言。其中 LIMIT 10限制留言显示数量。绿色部份则是每条留言的输出样式。 comments LEFT OUTER JOIN $wpdb->posts ON ($wpdb->comments.comment\\_post\\_ID = $wpdb->posts.ID) WHERE comment\\_approved = ’1′ AND comment\\_type = ” AND post_password = ” ORDER BY comment\\_date\\_gmt DESC LIMIT 10″; $comments = $wpdb->get_results($sql); $output = $pre_HTML; foreach ($comments as $comment) { $output .= “n”.strip\\_tags($comment->comment\\_author) .”:” . ” ID) . “#comment-” . $comment->comment_ID . “” title=”on ” . $comment->post\\_title . “”>” . strip\\_tags($comment->com_excerpt) .””; } $output .= $post_HTML; echo $output;?> 7.wordpress调用含gravatar头像的评论输出comments LEFT OUTER JOIN $wpdb->posts ON ($wpdb->comments.comment\\_post\\_ID = $wpdb->posts.ID) WHERE comment\\_approved = ’1′ AND comment\\_type = ” AND comment\\_author != ‘郑 永’ AND post\\_password = ” ORDER BY comment\\_date\\_gmt DESC LIMIT 10″; $comments = $wpdb->get_results($sql); $output = $pre_HTML; foreach ($comments as $comment) { $output .= “n”.get\\_avatar(get\\_comment\\_author\\_email(‘comment\\_author\\_email’), 18). ” post\\_title . ” 上的评论”>”. strip\\_tags($comment->comment\\_author) .”： “. strip\\_tags($comment->com_excerpt) .””; } $output .= $post_HTML; $output = convert_smilies($output); echo $output; ?> 上面代码把comment_author的值改成你的ID，18是头像大小，10是评论数量。 8.wordpress调用网站统计大全 1、日志总数： publish;?> 2、草稿数目： draft; ?> 3、评论总数： get\\_var(“SELECT COUNT(*) FROM $wpdb->comments”);?> 4、成立时间： 5、标签总数： 6、页面总数： publish; ?> 7、分类总数： 8、链接总数： get\\_var(“SELECT COUNT(*) FROM $wpdb->links WHERE link\\_visible = ‘Y’”); echo $link; ?> 9、用户总数： get\\_var(“SELECT COUNT(ID) FROM $wpdb->users”); echo $users; ?> 10、最后更新： get\\_results(“SELECT MAX(post\\_modified) AS MAX\\_m FROM $wpdb->posts WHERE (post\\_type = ‘post’ OR post\\_type = ‘page’) AND (post\\_status = ‘publish’ OR post\\_status = ‘private’)”);$last = date(‘Y-n-j’, strtotime($last\\[0\\]->MAX\\_m));echo $last; ?> 9.wordpress判断语句 is_single() 判断是否是具体文章的页面is_single(’2′) 判断是否是具体文章（id&#x3D;2）的页面is_single(’Beef Stew’) 判断是否是具体文章（标题判断）的页面is_single(’beef-stew’) 判断是否是具体文章（slug判断）的页面comments_open() 是否留言开启pings_open() 是否开启pingis_page() 是否是页面is_page(’42′) id判断，即是否是id为42的页面is_page(’About Me’) 判断标题is_page(’about-me’) slug判断is_category() 是否是分类is_category(’6′) id判断，即是否是id为6的分类is_category(’Cheeses’) 分类title判断is_category(’cheeses’) 分类 slug判断in_category(’5′) 判断当前的文章是否属于分类5is_author() 将所有的作者的页面显示出来is_author(’1337′) 显示author number为1337的页面is_author(’Elite Hacker’) 通过昵称来显示当前作者的页面is_author(’elite-hacker’) 下面是通过不同的判断实现以年、月、日、时间等方式来显示归档 is_date() is_year() is_month() is_day() is_time() 判断当前是否是归档页面is_archive() 判断是否是搜索is_search() 判断页面是否404：is_404() 判断是否翻页，比如你当前的blog是http://domain.com 显示http://domain.com?paged=2的时候，这个判断将返 回真，通过这个函数可以配合is_home来控制某些只能在首页显示的界面， 例如： &#x2F;&#x2F;这里写你想显示的内容，包括函数或者：&#x2F;&#x2F;这里写你想显示的内容，包括函数 10.wordpress 非插件调用评论表情&lt;!–smilies–&gt; $smile) { $file = get_bloginfo(‘wpurl’).’/wp-includes/images/smilies/’.$smile; $value = ” “.$key.” “; $img = “”; $imglink = htmlspecialchars($img); $link .= “{$img}&nbsp;”; } echo ‘’.$link.’’; } ?>&lt;!–smilies—&gt; 将以上代码复制到 comments.php 中合适的位置：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"百元百科","slug":"技术/百元百科","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"}]},{"title":"阿里巴巴助微软打击盗版","slug":"alibaba-help-microsoft-crack-down-on-piracy","date":"2015-01-12T03:22:33.000Z","updated":"2024-03-28T02:24:50.724Z","comments":true,"path":"alibaba-help-microsoft-crack-down-on-piracy.html","link":"","permalink":"https://baiyuan.wang/alibaba-help-microsoft-crack-down-on-piracy.html","excerpt":"","text":"1月9日消息，阿里巴巴集团和微软签署了一项谅解备忘录（Memorandum of Understanding）承诺在淘宝和天猫提高微软知识产权的安全。作为该谅解备忘录的一部分，阿里巴巴将加强以上两个站点防伪措施，比如通过删除伪造或未经授权的微软产品列表。 微软在中国一直在努力打击盗版软件，在2011年，当时的首席执行官史蒂夫·鲍尔默说，该公司由于知识产权保护上的不严格，丢掉了大概95％的潜在收入。 有了新的协议，阿里巴巴和微软两家公司将合作帮助消费者辨别假冒和未经授权的软件，告知消费者假冒或未经授权软件带来的威胁：易泄漏个人隐私和数据。这一举措将通过各种在线渠道执行，如阿里巴巴集团旗下的电子商务平台和在线支付工具。 本文章由王柏元原创翻译，英语原文","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"电脑开机自检声音对应的故障分析","slug":"computer-post-sound-corresponds-to-the-fault-analysis","date":"2015-01-12T00:54:00.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"computer-post-sound-corresponds-to-the-fault-analysis.html","link":"","permalink":"https://baiyuan.wang/computer-post-sound-corresponds-to-the-fault-analysis.html","excerpt":"","text":"有些童鞋的电脑出现故障时候，电脑开机时会发出“滴滴滴”的声音，对于新手来说，这样的滴滴声没有什么区别。其实这是电脑开机过程中自检的报警声，通过不同的报警声告诉用户电脑的故障发生在哪里，好让用户维修时对症下药。 首先，笔者普及一下什么是开机自检开机自检是电脑开机过程中对自身硬件，如硬盘，内存，显卡，CPU等等 ，进行的检查过程，如果硬件设备出现了故障，就会通过“滴滴”声发出警告，有时会无法开机。 要想听懂BIOS报警声的意思，你需要先了解自己的BIOS是什么类型的。下面是几种BIOS开机自检报警声对应的故障内容: 电脑开机自检声音对应的故障分析 Award BIOS1短 系统正常启动 2短 常规错误，请进入CMOS SETUP重新设置不正确的选项 1长1短 内存或主板出错 1长2短 显示错误(显示器或显示卡) 1长3短 键盘控制器错误 1长9短 主板FlashRAM或EPROM错误（BIOS 损坏） 不断地响(长声) 内存插不稳或损坏 不停地响 电源,显示器未和显示卡连接好 重复短响 电源问题 无声音无显示 电源问题 AMI BIOS1短 内存刷新失败 2短 内存ECC校验错误 3短 系统基本内存(第1个64K)检查失败 4短 系统时钟出错 5短 中央处理器(CPU)错误 6短 键盘控制器错误 7短 系统实模式错误，不能切换到保护模式 8短 显示内存错误(显示内存可能坏了) 9短 ROM BIOS检验和错误 1长3短 内存错误(内存损坏，请更换) 1长8短 显示测试错误(显示器数据线松了或显 示卡插不稳) Phoenix BIOS1短 系统正常启动 3短 系统加电自检初始化(POST)失败 1短1短2短 主板错误（主板损坏，请更换） 1短1短3短 主板电池没电或CMOS损坏 1短1短4短 ROM BIOS校验出错 1短2短1短 系统实时时钟有问题 1短2短2短 DMA通道初始化失败 1短2短3短 DMA通道页寄存器出错 1短3短1短 内存通道刷新错误（问题范围为所有 的内存） 1短3短2短 基本内存出错（内存损坏或RAS设置错误） 1短3短3短 基本内存错误（很可能是DIMM0槽上的内存损坏） 1短4短1短 基本内存某一地址出错 1短4短2短 系统基本内存(第1个64K)有奇偶校验 错误 1短4短3短 EISA总线时序器错误 1短4短4短 EISA NMI口错误 2短1短1短 系统基本内存(第1个64K)检查失败 3短1短1短 第1个DMA控制器或寄存器出错 3短1短2短 第2个DMA控制器或寄存器出错 3短1短3短 主中断处理寄存器错误 3短1短4短 副中断处理寄存器错误 3短2短4短 键盘时钟有问题,在CMOS中重新设置 成Not Installed来跳过POST 3短3短4短 显示卡RAM出错或无RAM,不属于致命错误 3短4短2短 显示器数据线松了或显示卡插不稳或 显示卡损坏 3短4短3短 未发现显示卡的ROM BIOS 4短2短1短 系统实时时钟错误 4短2短2短 系统启动错误，CMOS设置不当或BIOS 损坏 4短2短3短 键盘控制器(8042)中的Gate A20开关 有错,BIOS不能切换到保护模式。 4短2短4短 保护模式中断错误 4短3短1短 内存错误（内存损坏或RAS设置错误） 4短3短3短 系统第二时钟错误 4短3短4短 实时时钟错误 4短4短1短 串行口(COM口、鼠标口)故障 4短4短2短 并行口（LPT口、打印口）错误 大家可以根据自己的报警声情况对号入座，对症下药。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"bios","slug":"bios","permalink":"https://baiyuan.wang/tags/bios/"},{"name":"电脑故障","slug":"电脑故障","permalink":"https://baiyuan.wang/tags/%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"}]},{"title":"新建wordpress网站速度慢怎么办","slug":"what-about-new-wordpress-website-speed-is-slower","date":"2015-01-11T11:09:24.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"what-about-new-wordpress-website-speed-is-slower.html","link":"","permalink":"https://baiyuan.wang/what-about-new-wordpress-website-speed-is-slower.html","excerpt":"","text":"新建立的wordpress站点，不管是前台还是后台，一般会有打开速度的问题。笔者也遇到这个问题，接下来向大家介绍：新建wordpress网站速度慢怎么办 出现的原因有两个:1.google在中国大陆被网络长城屏蔽，导致网站引用Google 的资源无法加载；2.wordpress的Gravatar头像无法加载（也是墙掉的结果）； 怎样解决google字体无法加载问题 最好的方法是禁用google字体服务。 Google在中国大陆访问时常抽风，因此也影响到了google api和一些公共服务，而其中现在很流行的google fonts也饱受困扰，很多google的公共库文件访问缓慢或者根本就是无法访问， 比如： theme.googleusercontent.com 、fonts.google apis.com 、ajax.google apis.com 很多网站前端以前都是直接用google的地址，这会或多或少的影响网站打开速度（不过笔者没遇到这个问题，可能是使用国人自己做的主题的原因）。 解决方法1、安装插件：在插件中搜索 Disable Google Fonts，选择安装，然后启用，这样就可以禁止Google字体的加载，这样就可以提高访问速度了。 最近360网站卫士提供的公共库资源（ http://libs.useso.com/ ），效果果然提高不少。 这个插件是调用360的CDN常用前端公共库替换所有谷歌google.com域名链接。 插件下载地址: http://baiye.us/wp-content/uploads/2014/06/googlefontsto360.zip 2、删除代码：很多人不喜欢用插件那么这个可以修改代码打开&#x2F;wp-includes&#x2F;script-loader.php搜索fonts.googleapis.com找到代码位置，直接把&#x2F;&#x2F;fonts.googleapis.com&#x2F;…这个链接整个删掉即可。（修改前请备份好数据，用&#x2F;&#x2F;注释掉也是可以的哦） 3、推荐使用这种方法，依次打开 &#x2F;wp-includes&#x2F;script-loader.php，约581行的位置，替换谷歌的字体库为360网站卫士的国内CDN节点，把&#x2F;wp-includes&#x2F;script-loader.php文件中的fonts.googleapis.com换成fonts.useso.com即可。 怎样解决wordpress的Gravatar头像无法加载的问题首先讲讲什么是gravatar头像Gravatar全称Globally Recognized Avatar（全球识别头像），来自国外网站（http://www.gravatar.com）提供的在线头像服务，主要用在博客和论坛留言中，依靠邮件地址识别判断，为每个用户展示个性化的通用头像服务，完全免费，最初用在WordPress上，现在已经遍地开花，很多博客都支持Gravatar头像显示。——因为被墙掉的缘故，所有的博客一般都会出现头像无法加载的问题 介绍一下头像插件-WP User Avatar安装 WP User Avatar 以后，就可以 在后台 - 设置 - 讨论，设置网站的默认头像，还会在后台 - 用户 - 我的个人资料，添加了一个自定义头像功能，允许用户设置自己的头像。这样一来，如果用户在“个人资料”中设置了自己的头像，就优先显示，如果没有设置，就显示用户的 Gravatar 头像，或者网站的默认头像。详细参考地址：http://www.wpdaxue.com/wp-user-avatar.html 如果想保留Gravatar服务，可以这样参考地址：http://www.v7v3.com/wpjiaocheng/201401511.html","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"}]},{"title":"斯诺登：美国已经把太多的重点放在网络进攻，现在需要的是防御","slug":"snowdon-united-states-put-emphasis-on-network-attack-now-needs-defensive","date":"2015-01-09T06:21:25.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"snowdon-united-states-put-emphasis-on-network-attack-now-needs-defensive.html","link":"","permalink":"https://baiyuan.wang/snowdon-united-states-put-emphasis-on-network-attack-now-needs-defensive.html","excerpt":"","text":"在PBS NOVA采访中，斯诺登警告说，美国的网络战战略，可能会适得其反。 by Sean Gallagher - Jan 8, 2015 7:10 pm UTC 爱德华·斯诺登警告说，美国国防部和国家安全局、能源部已经过分强调进攻性网络能力的发展，却把美国自己的系统置身于更大风险之中。随着现在其他国家发展网络攻击能力来瞄准美国国家安全局和美国网络司令部，斯诺登认为，美国的处境越来越危险。 这份NOVA采访的原始记录显示，斯诺登完全主导了这次采访提问的方向，甚至到了建议如何组织采访报告和搭配它的视觉元素的地步。斯诺登经常引导问题远离那些可能透露更多有关NSA业务的地方，避免涉及一些他认为是雷区的问题，比如白宫政策。但这位泄密者雄辩地阐述了网络战的危害，以及对于NSA和网络司令部采取发现并利用对手的软件漏洞来攻击对手的这一做法，他指出了其不安全性。他说，（因为在）事实上，同样的漏洞也存在于美国的系统之中。 “安装在美国的同一路由器，同样被安装在中国，”斯诺登解释： “控制美国的水坝开闸软件，在俄罗斯绝无二致；一款在叙利亚使用的医用软件，同样也在美国使用。” 去年六月在俄罗斯的一些采访，仿佛预示着针对索尼影业的网络攻击。斯诺登说，网络攻击，如2012年的“Shamoon”恶意软件，和其它类似针对索尼影业的网络攻击，都是像婴儿般稚嫩的黑客网络活动——具有破坏网络的能力，但没有真正地造成持久的损害。但他表示，更复杂的组织，包括民族国家的演员，现在越来越多热衷于破坏性网络攻击的能力，而这和你在网上通常看到的网络破坏的形式恰恰相反“。 “我不想大肆渲染这种威胁，”斯诺登告诉班福德。 “没有人打算做这样的事：只要轻触键盘按键，就能扳倒政府；只要轻触键盘按键，就能将一个国家从地球上抹掉。”但斯诺登强调，美国应更注重防御，而不是试图渗透对手的网络搜集信息和进行网络攻击。 “当你看到‘美国究竟是优先考虑进攻还是防御’这个问题时，你可以试想一下你有两个银行金库：美国银行和中国银行的金库，”斯诺登解释说： “美国银行的金库是完全充满的，它会一路攀升，直干云霄。而中国、俄罗斯、非洲或其他对手的银行金库才填满一半，四分之一甚至十分之一。“他说，因为美国过去一直专注于能够侵入别国网络，在开发网络技术的同时也创造了大量的漏洞，于是其他国家可以使用相同的漏洞来攻击美国的网络。 “我们将自己暴露在网络攻击下，”斯诺登说。 “我们降低自身防御，让我们更有优势去进攻其他国家。但是事实是：当你争相把别人与自己的一项成就一较高低过程中，从这些网络攻击中获取的数据、知识、信息，对于对手的价值远比我们大，因为我们的技术已经世界顶尖，和从它们获取知识来强大自我相比，这更容易把我们拖向下坡路“。 美国最有价值也正处于风险之中的基础设施，斯诺登说，是互联网。 “对于个人，互联网沟通彼此;对于企业，互联网是每日之必须。”他解释说。 “如果对手没有针对我们的发电厂，但他们瞄准核心路由器，整个美国就可以被拦腰截断……我们的经济和商业将会在黑暗中度过几分钟，几小时，乃至几天，这都对我们的社会将产生极大的影响，甚至引发政治动荡。“ 当被问及2013年叙利亚互联网的多日中断，是否可能是美国国家安全局试图攻击叙利亚的核心路由器的结果，斯诺登不以为然。他说，此类事情发生在过去。 “问题在于，如果你做这件事，当你操纵装置的硬件控制时出现了一个错误，你所做的就是所谓把硬件设备变砖，这将会在整个国家的通信发展之路上，把它从价值600万美元的互联网通信设备变成600万美元纸张“。 就在这次采访发生几天前，国家安全局的新董事、海军上将迈克尔·S·罗杰斯，淡化了斯诺登在接受纽约时报记者采访时泄密所造成的伤害。斯诺登认为这个转换具有讽刺性意味，并且他也对前国家安全局局长海登2013年九月在华盛顿特区圣约翰圣公会教堂的讨论作出了评论。在那次讨论中，海登说，斯诺登是“自命清高”，并可能会“像大多数去旧苏联的叛逃者那样，最终陷入隔离，无聊，孤独，郁闷的田地，并且其中大部分人沦落为酒鬼。” “我不喝酒，”斯诺登对班福德和NOVA的工作人员说: “我平生未曾醉酒。他们谈论俄罗斯的时候，就像俄罗斯是地球上最糟糕的地方，（其实）俄罗斯是一个伟大的国度。” 本文章由王柏元、吴仁杰原创翻译，英文原文","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"斯诺登","slug":"斯诺登","permalink":"https://baiyuan.wang/tags/%E6%96%AF%E8%AF%BA%E7%99%BB/"}]},{"title":"使用.htaccess文件实现301重定向常用的七种方法","slug":"use-the-htaccess-file-seven-ways-to-achieve-301-redirect","date":"2015-01-06T13:30:33.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"use-the-htaccess-file-seven-ways-to-achieve-301-redirect.html","link":"","permalink":"https://baiyuan.wang/use-the-htaccess-file-seven-ways-to-achieve-301-redirect.html","excerpt":"","text":"使用.htaccess文件实现301重定向常用的七种方法301重定向对广大站长来说并不陌生，从网站建设到目录优化，避免不了对网站目录进行更改，在这种情况下用户的收藏夹里面和搜索引擎里面可能保存的还是老的地址，在打开这些链接时会无法显示页面出现404的错误，造成很差的用户体验并失去了很多流量，今天笔者就给大家分享一下实现301重定向的七种方法。 从搜索引擎优化的角度来看，目前301重定向是网站目录更改后重新定向最为可行的一种办法。在你更改地址使用了301重定向后，搜索引擎只会对新地址进行索引，同时会把旧地址下原来收录的链接转移到新地址下，而上述的这些操作并不会影响到网站在搜索引擎的排名。 实现301重定向最直接的方法是编辑.htaccess文件，想了解关于htaccess文件使用方法，请点此查看。园子需要提醒你的是，在对.htaccess文件进行操作之前，一定要备份好原来的.htaccess文件，以避免修改出错带来不必要的麻烦。 1.重定向domain.com到www.domain.com这种重定向非常常见，最终目的是实现域名的唯一性，也是seo必须要做的。实现方法是在.htaccess文件中加入以下规则： 代码如下: RewriteEngine OnRewriteCond %{HTTP_HOST} !^www.domain.com$ [NC]RewriteRule ^(.*)$ http://www.domain.com/$1 [L,R&#x3D;301] 注：使用这种301重定向方式后，当你打开类似domain.com的网址后会自动定向到www.domain.com。 2.重定向www.domain.com到domain.com这种操作刚好和上面的域名显示是相反的，规则如下： 代码如下: RewriteEngine OnRewriteCond %{HTTP_HOST} !^domain.com$ [NC]RewriteRule ^(.*)$ http://domain.com/$1 [L,R&#x3D;301] 注：使用此301重定向方式，当你打开类似www.domain.com的网址后会自动定向到domain.com。 3.重定向olddomain.com 到 newdomain.com这种操作经常用于更换域名时用到，很多站长因为种种原因可能要为站点更换域名，此时多采用以下规则来实现重新定向： 代码如下: RewriteEngine OnRewriteBase &#x2F;RewriteCond %{HTTP_HOST} !olddomain.com$ [NC]RewriteRule ^(.*)$ http://newdomain.com/$1 [L,R&#x3D;301] 注：当用户打开老的域名后，会自动重定向到新的域名下的站点，此时域名显示格式为不带www.的格式。 4.重定向olddomain.com 到 www.newdomain.com这种操作是基于第三种方式的改良，只是显示网址显示为带www.的那种。 代码如下: RewriteEngine OnRewriteCond %{HTTP_HOST} !olddomain.com$ [NC]RewriteRule ^(.*)$ http://www.newdomain.com/$1 [L,R&#x3D;301] 注：当用户打开老的域名后，会自动重定向到新的域名下的站点，并且网址显示格式为带www.的格式。 5.重定向domain.com&#x2F;file&#x2F;file.php 到 otherdomain.com&#x2F;otherfile&#x2F;other.php这种操作针对于更改一个域名的同时，网站目录路径也发生变化的情况下使用，规则如下： 代码如下: RewriteCond %{HTTP_HOST} ^www.domain.com$RewriteRule ^file&#x2F;file.php$ http://www.otherdomain.com/otherfile/other.php [R&#x3D;301,L] 注：当用户访问老的域名路径时，会重新定向到新的域名新的路径下。 6.IIS服务器下实现301重定向具体方法如下：打开internet信息服务管理器，在欲重定向的网页或目录上按右键，选中“重定向到URL”， 在对话框中输入目标页面的地址，切记要选中“资源的永久重定向”最后点击“应用”即可。 注：再次提醒你，一定要选中“资源的永久重定向”。 7.Apache服务器实现301重定向在Apache服务器实现301重定向的方法园子在以前的文章中提到过，只需要在.htaccess文件中加入以下规则： 代码如下: Redirect &#x2F;旧目录&#x2F;旧文档名 新文档的地址 也可能是： 代码如下: Redirect &#x2F;olddirectory http://www.newsite.com/newdirectory [callout class&#x3D;”warning” title&#x3D;””]注：一定要注意书写格式，第一种是同一域名下将一个文档定向到新的目录地址，第二种是把老目录定义到新域名的新目录下。[&#x2F;callout] 以上七种方法是在网站管理与优化过程中经常会使用到的301重定向方法，当然，你也可能遇到不大相同的状况，这时候就需要根据自己的目的去适当调整下命令规则以适应不同的需求。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"域名解析","slug":"域名解析","permalink":"https://baiyuan.wang/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]},{"title":"关于元旦百度新年大K站的后续消息","slug":"follow-up-on-baidu-k-station-new-year-new-years-day-message","date":"2015-01-04T10:22:47.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"follow-up-on-baidu-k-station-new-year-new-years-day-message.html","link":"","permalink":"https://baiyuan.wang/follow-up-on-baidu-k-station-new-year-new-years-day-message.html","excerpt":"","text":"笔者这几天注意到自己的网站排名好像又回来了，于是专程前往百度官方站长平台一探究竟，得到的消息与大家分享： 来自百度站长平台官方论坛元旦三天有不少童鞋激烈的讨论cc与cn域名被k的事，所以开这个帖集中反馈处理，平台今天预计会出公告，先不要着急。如果大家有相关信息，可以集中在这个帖子讨论， 大家不要再开新帖暴社区了，社区除了这个问题，其他的童鞋的问题也不能忽视 。 官方回复（man_hok修改） 元旦期间有站点流量波动异常，平台还在追查此事，稍后请大家关注平台公告 发现有一些童鞋借这个机会大肆宣传推广相关未经官方证实的信息，然后借机推广自己的相关平台与交流组织，刚与百度管理沟通，特将排名恢复的信息整理如下： 由于网页搜索元旦期间出现相关系统故障，导致部分网站在百度搜索结果中的排序受到影响而出现相关波动情况，今日在加紧修复中，预计今日晚些会修复完成，请大家密切关注平台信息，不要到处传播及揣测相关信息。百度没有对.cn及.cc域名歧视，请这部分站点不要听信谣言。 请大家注意观察自己的站点情况，不要到处转发未经证实的信息。。。 目前相关反馈帖子如下： http://bbs.zhanzhang.baidu.com/thread-15108-1-1.html http://bbs.zhanzhang.baidu.com/thread-15109-1-1.html http://bbs.zhanzhang.baidu.com/thread-15110-1-1.html http://bbs.zhanzhang.baidu.com/thread-15093-1-1.html http://bbs.zhanzhang.baidu.com/thread-15101-1-1.html http://bbs.zhanzhang.baidu.com/thread-15100-1-1.html http://bbs.zhanzhang.baidu.com/thread-15104-1-1.html http://bbs.zhanzhang.baidu.com/thread-15095-1-1.html http://bbs.zhanzhang.baidu.com/thread-15105-1-1.html http://bbs.zhanzhang.baidu.com/thread-15103-1-1.html http://bbs.zhanzhang.baidu.com/thread-15102-1-1.html http://bbs.zhanzhang.baidu.com/thread-15098-1-2.html 百度官方消息还没出来，大家静观其变吧。按照这位应该是内部人员的消息，cn网站被K应该是百度的原因，大家不必担心。对于这次事故的民间推测，可以参考：2015年元旦百度新年大K站的情报汇总","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[]},{"title":"2015年元旦百度新年大K站的情报汇总","slug":"year-2015-baidu-k-station-of-the-intelligence-collection","date":"2015-01-03T04:23:14.000Z","updated":"2024-03-28T02:24:50.740Z","comments":true,"path":"year-2015-baidu-k-station-of-the-intelligence-collection.html","link":"","permalink":"https://baiyuan.wang/year-2015-baidu-k-station-of-the-intelligence-collection.html","excerpt":"","text":"昨天晚上笔者着实郁闷了一回，因为本人的博客从百度搜索自己名字的排名从第一降到25，一直找不到原因。今天终于得到比较靠谱的消息。不管你信不信，我是信了！ 对于这次风波，我给大家梳理了一下网上的说法，希望cn网站躲过一劫 来自《上学吧》根据各站长们的反馈，2015年1月1日起，百度搜索引擎出现了大范围大幅度的波动，导致大批量网站排名被降，收录减少，流量大减，权重被降，从目前反映的情况来看，主要有： 1. cn类域名网站大面积中招，出现长尾关键词大量消失、关键词排名下降等情况 2. 据chinaz的抽样调查：这次被K网站的比例达到了5% 3. 传闻此次“事件”百度元旦上线了新算法——瑞丽算法 4. 很多网站反映：流量减少了25%-75% 5. 百度官方工作人员表示正在调查，预计1月3日会在百度站长平台发布相关公告 来自《中华论文网》 元旦佳节本来是喜庆之日，但2015年新年对广大站长来说，是一个阴冷的日子，心冷。 从中国站长工站数据风向标中的走势图可以看出，2015年新年百度K站比例：1月1日5.22%，1月2日2.87%，1月3日11.27%，这次百度出手真是够狠的。对广大站长来说不知是大快人心还是大痛人心。对没被K的人来说是大快人心，对被K站的人来说是大痛人心。 作为一名小站长，和广大小站长一样，每天最爱做的事就是看看一自己的网站收录了多少，排名上去了多少，有多少人访问。 1月1日早，我发现我的网站排名不错的演讲稿这个关键词突然没了，当时觉得心痛，但其它的关键词还在，以为是百度调整，过段时间就会回来。中午时一个朋友跟我说，他网站600多个前50名的关键词一直往下掉，我还安慰了他几句，以为是他这段时间服务器不稳定，弄个好的服务器就行了。下午查一下自己的站，关键词一下子跌得只剩下3个，排名也以平方基数下跌，天啊，掉到70万名开外，估计被百度k网站了，当时那个心灰意冷。第二天继续观察，收录没有下降，还多出了几百，首页也没掉，朋友跟我说，他的止住了，我查了一下，关键词数量又上升了差不多20个，只是网站从权重3降为2。 从各种迹象表明，我们的站都是被降权了，收录继续，就是排名降了。算是一种惩罚吧，平时自己的网站疏于管理，前期还能加一些原创或伪原创，排名上得挺快，但时间久了没耐心管理，就买了个火车头进行采集，觉得用软件做伪原创破坏浏览者的体验，所以一直都没做伪原创，采集文章多应该本次惩罚的主因。 广大站长们也不要心灰意冷，只要坚持走正确的道路，少想歪聪明，一切应该会好起来。 这次应该是2015年百度对网络整顿的决心。下面是K站比例图，有图有真象。 2015年元旦百度K站比例图 来自《SEO研究协会网》SEO研究协会网讯：2015年元旦，新年新气象，多么美好的一时刻。然而，对SEOer和站长来说，这是个非同寻常的元旦。就在元旦初，即2015年一月1日，百度搜索引擎出现了大范围大幅度的波动，导致大批量网站排名被降，收录减少，流量速减，权重被降，甚至有些网站更惨。就在大家都沉迷在新年的欢快当中时，站长圈被这一举动打破了新年第二个造成的宁静。 ** 从目前网页反应的情况看，网站出现异常有一下几种：** 一、行业关键词排名下降 二、网站已收录页面速减 三、网站排名全无，包括网站名称排名 四、网站全职大幅下降 五、网站停止或者减少新收录 但是，从目前反应情况看，全网被K现象并不多。大部分都是排名下降，以及排名下降导致的一系列反应，如流量下降，百度权重下降等等。 百度官方站长大咖群反应情况 根据SEO研究协会网研究员调查发现，本次K站让众多站长措手不及，设计范围之广，设计深度之大是2014年几次百度调整根本无法比拟的。就在大家都各说风云之时，SEO研究协会网柴潇发动SEO研究协会网观察员对各位站长反馈的问题进行了逐一排查和现象分析。 虽然暂时还无法定性，也没有得到百度官方的任何消息，但初步判断出一下几种现象： 一、**.cn和.com.cn后缀网站受伤最大** 从目前反应来看，大部分网站属于.cn为后缀的网站。包括SEO行业专业门户网站SEO研究协会网（www.seoxiehui.cn）也不例外，收到了很大的牵连，甚至搜SEO研究协会网官网名称，都无法搜到该站。 SEO研究协会网官网词排名消失 从目前情况揣测，之所以**.cn和.com.cn**网站受到牵连，有可能是受到国家相关部门干涉，对整体国内域名的网站进行过滤排查导致。在这期间，有网友反应部分地区百度曾有段时间内无法访问。 二、恶意点击网站被K严重 据SEO研究协会网柴潇和行业内各大SEO大咖讨论发现，除了以上提到的.cn的网站受到波及之外。部分有过恶意点击的网站或者“被认为恶意点击”的网站均有不同程度的影响。目前从SEO研究协会网来分析，由于平时经常举办一些活动，导致活动期和非活动期的搜索指数明显不同。有可能被百度误认为是恶意点击而被惩罚。在调查几个站长发现，他们的网站不同程度的都有过故意点击行为，无论是工具点击还是人工故意点击。 最后： 有网友传，本次K站是百度新上线瑞丽算法所致。无论如何，在百度官方没有发表声明之前，本次K站涉及范围之光，涉及程度之深，使大批站长损失惨重，甚至一些以广告联盟为生的资讯站几乎出现了经济来源奔溃的边缘。为了查明真相和给出解决方案，SEO研究协会网作为SEO行业知名门户网站，联合巨推俱乐部将在近期举办“2015黑色元旦SEO研讨会”，请涉及到的站长积极参加。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[]},{"title":"怎样在windows桌面上建永久删除的回收站","slug":"how-to-delete-your-files-forever","date":"2015-01-03T04:05:57.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-delete-your-files-forever.html","link":"","permalink":"https://baiyuan.wang/how-to-delete-your-files-forever.html","excerpt":"","text":"对于我们不用的文件，大家可能将它删除。我们一般要不右键选择“删除”，要不用按键“delete”，或者直接将它拖进桌面的回收站里。但是我们发现：放进回收站的文件并没有真正的从磁盘删除掉，其实只是被隐藏掉，时间一长会占用你大量的磁盘空间。笔者可以给大家做一个试验： 这是我计算机的磁盘占用情况： 我们注意到我的F盘（媒体娱乐）还有30.6GB可用，我从F盘里选择一部大小为2.82G的电影”The.Interview.1080p.WEB-DL.x264.AC3.mp4”然后将其删除 我们可以在回收站找到它： 请问我的F盘现在的剩余空间是不是30.6+2.82呢？ 答案是 可能大家知道用“shift+delete”可以永久删除文件，但在这里我向大家介绍的一种像拖入桌面回收站一样永久删除文件的方便方法： 在我的桌面上有两个回收站： ，当我将文件拖到右边永久删除里时，是可以永久删除该文件的。 实现方法新建一个bat批处理文件（就是用记事本新建一个txt文件将其改成.bat格式），在里面输入 del &#x2F;a &#x2F;f &#x2F;q \\?%1&gt;nulrd &#x2F;s &#x2F;q \\?%1&gt;nulexit &#x2F;b 保存后在桌面上建立该文件的快捷方式。建立快捷方式的快捷键是：按住文件并拖动，然后按住“ctrl+shift”将文件释放 之后你就发现你将文件拖入这个快捷方式就能方便地永久删除文件了。如果在这过程中发现会弹出一个命令指示符的小黑屏而且图标不好看： 你可以右键该快捷方式选择运行方式为“最小化”，备注“永久删除”，还可以改成你想要的个性图标：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"命令指示符","slug":"命令指示符","permalink":"https://baiyuan.wang/tags/%E5%91%BD%E4%BB%A4%E6%8C%87%E7%A4%BA%E7%AC%A6/"}]},{"title":"十三经结业:《诗经》之《蒹葭》赏析","slug":"shi-san-jing-completion-appreciation-of-the-reeds-of-the-book-of-songs","date":"2014-12-31T10:13:52.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"shi-san-jing-completion-appreciation-of-the-reeds-of-the-book-of-songs.html","link":"","permalink":"https://baiyuan.wang/shi-san-jing-completion-appreciation-of-the-reeds-of-the-book-of-songs.html","excerpt":"","text":"作为一个学习软件工程的工科男，在选择选修课的时候，我特地避开和工科有关的科目。魏征曾说：“偏听则暗，兼听则明”，在日益浮躁的社会，我觉得人文气息对于一个人与科技素养对于一个人同样重要，尤其在沾满了名利气息后，荡涤在人文与传统的清流中，人，可以愈发宁静、澄澈。鉴于此，这个学期我选了一节《国际经济》，又选了一节《十三经导读》，两者的选择都各得其所，各自引发我特有的深思。在此，我选择一篇《诗经》中的经典篇目—《蒹葭》进行赏析，作为我的结业论文。 首先让我们来回顾这段文字: 蒹葭苍苍，白露为霜。所谓伊人，在水一方，溯洄从之，道阻且长。溯游从之，宛在水中央。 蒹葭萋萋，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻。溯游从之，宛在水中坻。 蒹葭采采，白露未已。所谓伊人，在水之涘。溯洄从之，道阻且右。溯游从之，宛在水中沚。 在我看来，《蒹葭》大概讲的是一个暗恋的故事。金秋之末，河水之畔，白露化成霜，蒹葭饶堤岸，就在这某个平常的秋天，男主人公偶遇了那个令他心跳的“女神”，而女神就在河流的彼岸。男主人公沿着弯曲的河边道路到上游去找伊人。水道弯弯，蜿蜒曲折，但是他依旧不愿意放手，沿着路有险阻的河道，顺流而下寻找她，意中人仿佛就在水中央。 河畔的芦苇一片茂盛，清晨露水还尚未晒干，意中人就在河水对岸一边,男主人公依旧没有放弃，如此反复地追求心中爱情，到诗的最后，诗人依旧没有阐明，两人的爱情结局依旧暧昧。 是分是合，《诗经》传颂到今3000年，依旧没人告诉我们这个爱情故事的结局。结局迷离，但是我们可以肯定：三千年前河畔的那个男子，不管前路多么崎岖，依旧会追求他心中的女子，虽然过程或许也像诗的回环“反复”，虽然“所谓伊人”，总是老样子“在水一方”，但心中有认定的爱情，就矢志不渝！ 没有大结局的《蒹葭》仿佛在叩问我们，在经历几次“溯流从之，道阻且长”后，在几次相望却不能相遇后，你，还暗恋着心里的那个她吗？ 当今的社会，有这么一句话深得“民心”，在广大少年少女间口耳相传，网络相传：“你若不离不弃，我便生死相依“。这句话句式很美，我却从中读出了悲凉。用通俗的话来讲只有你爱我，才能让我爱你。用今天的价值取向来看，这对男女双方都公平，你既然不爱我，又有什么资格让我必死乞白赖地与你相守一生，若要相守一生，你得打保票不离不弃。但是没有信任的爱情，没有坚定信仰的爱真的可以长久吗？我想起了蒹葭里那个男子，只是为了自己心中的爱情信仰，便不离不弃。虽然相望无法相见，依旧暗恋始终，追求不渝。这是怎样的痴情，这是怎样浪漫的爱情。 这是这样一种爱情：虽然知道爱你没有结局，我却依旧爱你；不求你天长地久，但我会做到矢志不渝。","categories":[{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"}],"tags":[]},{"title":"数据结构几种排序算法的时间和空间复杂度总结","slug":"data-summary-several-time-and-space-complexity-of-sorting-algorithms","date":"2014-12-30T14:34:39.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"data-summary-several-time-and-space-complexity-of-sorting-algorithms.html","link":"","permalink":"https://baiyuan.wang/data-summary-several-time-and-space-complexity-of-sorting-algorithms.html","excerpt":"","text":"1.插入排序：每次将一个待排的记录插入到前面的已经排好的队列中的适当位置。①.直接插入排序直接排序法在最好情况下（待排序列已按关键码有序），每趟排序只需作1次比较而不需要移动元素。所以n个元素比较次数为n-1，移动次数0。 最差的情况下（逆序），其中第i个元素必须和前面的元素进行比较i次，移动个数i+1，所以总共的比较次数 比较多，就不写出来了 总结：是一种稳定的排序方法，时间复杂度O(n^2)，排序过程中只要一个辅助空间，所以空间复杂度O(1) ②.希尔排序缩小增量排序，对直接插入排序的一种改进 分组插入方法。 总结：是一种不稳定的排序方法，时间复杂度O(n^1.25)，空间复杂度O(1) 2.交换排序①.冒泡排序最好的情况下，就是正序，所以只要比较一次就行了，复杂度O(n) 最坏的情况下，就是逆序，要比较n^2次才行，复杂度O(n^2) 总结：稳定的排序方法，时间复杂度O(n^2)，空间复杂度O(1)，当待排序列有序时，效果比较好。 ②.快速排序通过一趟排序将待排的记录分割成独立的两部分，其中一部分记录的关键字均比另一个部分的关键字小，然后再分别对这两个部分记录继续进行排序，以达到整个序列有效。 总结：在所有同数量级O(nlogn)的排序方法中，快速排序是性能最好的一种方法，在待排序列无序时最好。算法的时间复杂度是O(nlogn)，最坏的时间复杂度O(n^2)，空间复杂度O(nlogn) 3.选择排序①.直接选择排序和序列的初始状态无关 总结：时间复杂度O(n^2)，无论最好还是最坏 ②.堆排序直接选择排序的改进 总结：时间复杂度O(nlogn)，无论在最好还是最坏情况下都是O(nlogn) 4.归并排序总结：时间复杂度O(nlogn)，空间复杂度O(n) 5.基数排序按组成关键字的各个数位的值进行排序，是分配排序的一种。不需要进行排码值间的比较就能够进行排序。 总结：时间复杂度O(d(n+rd)) 总总结：n比较小的时候，适合 插入排序和选择排序 基本有序的时候，适合 直接插入排序和冒泡排序 n很大但是关键字的位数较少时，适合 链式基数排序 n很大的时候，适合 快速排序 堆排序 归并排序 无序的时候，适合 快速排序 稳定的排序：冒泡排序 插入排序 归并排序 基数排序 复杂度是O(nlogn)：快速排序 堆排序 归并排序 辅助空间（大 次大）：归并排序 快速排序 好坏情况一样：简单选择（n^2），堆排序（nlogn），归并排序（nlogn） 最好是O(n)的：插入排序 冒泡排序","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"闲言碎语20141229:对互联网和项目的一点看法","slug":"gossip-20141229-views-on-internet-and-projects","date":"2014-12-29T13:51:40.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"gossip-20141229-views-on-internet-and-projects.html","link":"","permalink":"https://baiyuan.wang/gossip-20141229-views-on-internet-and-projects.html","excerpt":"","text":"一个人为什么要做项目？因为通过一个项目你可以调用很多类库，可以调用你很多的基础知识从而进行知识架构间的磨合。就像一个国家工程，人们只看到它成功后的光辉形象，却不知背后带动起来的是整个产业链和技术链。 一个团队为什么要做项目？一个成功的项目在于调动所有成员的才学。一个失败的项目策划还比不上一个人通宵达旦的孤军奋战。但是一个人是无法完成一个大型的项目。正所谓“独行快，众行远”。 最近发现互联网的精华都在博客里，一些牛人把生活学习中原创的所思所感发到自己的博客并进行彻底的解析。然后一群人撷取他们的只字片语，然后复制粘贴，跑到论坛，跑到贴吧，跑到百度经验，跑到QQ群，复制粘贴，装逼，装大神。显然我还属于后者。","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"}],"tags":[{"name":"闲言碎语","slug":"闲言碎语","permalink":"https://baiyuan.wang/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"}]},{"title":"通过IPV6访问IPV4资源实现免费上网","slug":"implemented-by-ipv6-to-access-ipv4-resources-free-internet-access","date":"2014-12-29T08:45:40.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"implemented-by-ipv6-to-access-ipv4-resources-free-internet-access.html","link":"","permalink":"https://baiyuan.wang/implemented-by-ipv6-to-access-ipv4-resources-free-internet-access.html","excerpt":"","text":"以前可能有人通过6kuaibo实现了不用校园网认证的免费上网，但是后来不知道什么原因6kuaibo就莫名的夭折了。笔者最近又发现了一种IPV6免费上网的方法，再次给大家分享一下。 使用IPv6网络的用户如果需要访问IPv4的网络资源时，一般需要通过第三方软件来实现，而现在大家可直接通过支持NAT64&#x2F;DNS64的服务器，来实现IPv6与IPv4之间的NAT,从而实现IPv6网络访问IPv4资源。 通过IPV6访问IPV4资源实现免费上网目前Windows Vista与Win 7操作系统的用户，如果支持IPv6网络，则在右下角网络图标点击进入网络共享中心， 再打开“本地连接”网卡的属性，双击“Internet协议版本6(TCP&#x2F;IPv6)”,然后将DNS服务器地址手工设定为：2001:778::37,同时取消“Internet协议版本4(TCP&#x2F;IPv4)”前的勾，即不使用IPv4网络协议，只使用纯IPv6协议，这样就可以访问IPv4的网络资源了。 如果勾选了IPV4不进行校园网认证的的话，笔者发现也是可以上网的，但是进入网页的响应速度比较慢。 你也可以在只插上网线的情况下，只要在你要访问的网址后面加入“.sixxs.org”，比如你如果要访问百度（“http://www.baidu.com”）的话,可以在浏览器地址框中输入“http://www.baidu.com.sixxs.org”即可，但这种方法比上面的方法网速慢了很多；以上两种方法都不支持QQ软件的联网，所以实用性不是太强（这两种还有一个隐藏真实IP地址的作用），在此仅作交流。同时借助这篇博客的机会，也向大家爆料一下：IPV6是可以直接访问谷歌的，不需要任何设置。 当然，这一切一切的前提是，你支持IPV6网络访问 附录笔者通过琢磨命令行里的帮助信息，为大家找到一个便捷的方法： netsh interface ipv6 set dnsservers name&#x3D;”本地连接” source&#x3D;static addr&#x3D;2001:778::37 请将上面的代码复制到”以管理员身份运行“的命令指示符里运行，便可一键设置IPV6 DNS地址为上述所说的IP","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IPv6","slug":"IPv6","permalink":"https://baiyuan.wang/tags/IPv6/"}]},{"title":"一键安装JDK和自动配置java环境变量","slug":"one-click-installation-and-automatically-configures-java-jdk-environment-variables","date":"2014-12-28T06:16:32.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"one-click-installation-and-automatically-configures-java-jdk-environment-variables.html","link":"","permalink":"https://baiyuan.wang/one-click-installation-and-automatically-configures-java-jdk-environment-variables.html","excerpt":"","text":"对于java或安卓初学者来说，配置java环境变量是一件比较头疼的事情，在此我向大家分享一个一键安装JDK和自动配置java环境变量的bat批处理方法 一键安装JDK和自动配置java环境变量新建一个txt文档，在里面输入下面的内容： @echo offclscolor 2fecho.echo **********************************************echo.echo 一键安装 Java SE Development Kit 到 D 盘echo.echo 安装请按任意键，退出直接关闭窗口echo.echo **********************************************echo.pauseset myjavapath&#x3D;D:\\Java\\jdk IF EXIST %myjavapath%\\bin\\java.exe (echo. 自动配置java环境变量，来自—王柏元的博客—echo. 有问题到 http://blog.baiyuan.wang留言echo.echo 在 D 盘发现java程序，注册环境变量请按任意键echo.echo 退出直接关闭窗口echo.pausegoto SETENV) echo.echo 正在安装jdk，请不要执行其他操作echo.echo 请稍等，这个时间大约需要二、三分钟echo.start &#x2F;WAIT g:\\收藏软件编程\\jdk-8u20-windows-x64.exe &#x2F;s &#x2F;norestart &#x2F;v &#x2F;qn INSTALLDIR&#x3D;D:Javajdkecho 程序安装完毕，正在注册环境变量echo.goto SETENV :SETENVsetx JAVA_HOME %myjavapath%setx CLASSPATH .;%myjavapath%\\lib\\tools.jar;%myjavapath\\%lib\\dt.jar;%myjavapath%\\jre\\lib\\rt.jarsetx PATH %myjavapath%\\binecho.echo JDK环境变量设置成功echo.echo 安装完毕，测试下看看echo.call %myjavapath%\\bin\\java.exe -versionecho. if %errorlevel% &#x3D;&#x3D; 0 (echo 祝贺您成功安装了Java SE Development Kit !echo.goto END)echo 貌似安装不成功，您得自己想办法了，也可到我的博客http://blog.baiyuan.wang/?p=445留言！echo.goto END :ENDpause 将上面内容中jdk安装包的路径改成你的，比如我的安装包路径是G:收藏软件编程jdk-8u20-windows-x64.exe将建立的txt文件保存，然后重命名成”jdkinstall.bat”,然后双击文件运行如果提示“JDK环境变量设置成功 ”，则说明java环境配置成功，你也可以在命令指示符里键入 javac 进行验证；如果不行，你可以到我的博客里留言交流。 你也可以在文章后面下载本批处理文件","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"命令指示符","slug":"命令指示符","permalink":"https://baiyuan.wang/tags/%E5%91%BD%E4%BB%A4%E6%8C%87%E7%A4%BA%E7%AC%A6/"}]},{"title":"QT入门：怎么写无边框（标题栏）的窗口、透明窗口、圆角控件","slug":"getting-started-with-qt-how-to-write-without-borders-the-title-bar-of-windows-transparent-windows-round-controls","date":"2014-12-26T16:01:45.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"getting-started-with-qt-how-to-write-without-borders-the-title-bar-of-windows-transparent-windows-round-controls.html","link":"","permalink":"https://baiyuan.wang/getting-started-with-qt-how-to-write-without-borders-the-title-bar-of-windows-transparent-windows-round-controls.html","excerpt":"","text":"对于QT的初学者来说，去除边框，实现窗口透明度可能是美化GUI的基本要求，笔者综合了网上的代码，进行了总结： 无边框（标题栏）的窗口&#x2F;&#x2F;无边框（标题栏）的窗口 QApplication a(argc, argv); MainWindow w; w.setWindowOpacity(1); w.setWindowFlags(Qt::FramelessWindowHint); w.setAttribute(Qt::WA_TranslucentBackground); w.show(); setWindowOpacity(1)这一句代码实现窗口的透明效果，函数里面的参数是透明度，1表示不透明 setWindowFlags(Qt::FramelessWindowHint);隐藏窗口的标题栏和边框 背景刷成黑色,前景色设为白色。方法一、paltette方式，经测试，该方法不会影响到其他控件,推荐使用 QPalette bgpal &#x3D; palette();bgpal.setColor (QPalette::Background, QColor (0, 0 , 0, 255));&#x2F;&#x2F;bgpal.setColor (QPalette::Background, Qt::transparent);bgpal.setColor (QPalette::Foreground, QColor (255,255,255,255));setPalette (bgpal); 方法二、stylesheet方式 影响子控件的方法是： setStyleSheet (“background-color: rgb(0,0,0);color: rgb(255,255,255);”); 不影响子控件的方法是： setStyleSheet (“venus–TitleBar {background-color: rgb(0,0,0);color: rgb(255,255,255);}”); 圆角控件 用stylesheet方式 setStyleSheet (“border-radius:10px;”); 圆角窗口 RoundRectWin::RoundRectWin() { QPalette p &#x3D; palette(); QPixmap img(“roundrect.png”); QBitmap mask(“roundrect_mask.png”); p.setBrush(QPalette::Window, QBrush(img)); setPalette(p); setMask(mask); resize(img.size()); &#x2F;&#x2F;setWindowFlags(Qt::FramelessWindowHint);&#x2F;&#x2F;这句会去掉标题栏 } 注意:mask的图多余部分设为白色 半透明窗口 窗口整体透明，但是窗体上的控件不透明。 通过设置窗体的背景色来实现，将背景色设置为全透。 试验效果： QPalette pal &#x3D; palette();pal.setColor(QPalette::Background, QColor(0x00,0xff,0x00,0x00)); setPalette(pal); 窗体标题栏不透明； 窗体客户区上的控件不透明，QLabel控件只是字显示，控件背景色透明； 窗体客户区完全透明。 另外从网上看到的方法： setAttribute(Qt::WA_TranslucentBackground, true)； 试验的结果是类似于上面的方法，但有时候窗体会被一些杂色斑点填充，未找到原因。 窗口及其上面的控件都半透明： setWindowOpacity(0.7) 试验效果：窗口及控件都半透明。注意不能够setWindowFlags(Qt::FramelessWindowHint);要不就不起作用 窗口整体不透明，局部透明：在Paint事件中使用Clear模式绘图。 void TestWindow::paintEvent( QPaintEvent* ){ QPainter p(this); p.setCompositionMode( QPainter::CompositionMode_Clear ); p.fillRect( 10, 10, 300, 300, Qt::SolidPattern ); } 试验效果：绘制区域全透明。如果绘制区域有控件不会影响控件。 以上实验均是基于Directfb的Qte测试。在Linux下及Windows下效果会略有不同。 比如在Windows下第3个实验，绘制区域就是一个黑窟窿，如果Window本身半透，则是Window下面的内容加上半透效果，不是全透明效果。 控制QPixmap的alpha QPixmap temp(pixmapTop.size());temp.fill(Qt::transparent); QPainter p(&amp;temp); p.setCompositionMode(QPainter::CompositionMode_Source); p.drawPixmap(0, 0, pixmapTop); p.setCompositionMode(QPainter::CompositionMode_DestinationIn); p.fillRect(temp.rect(), QColor(0, 0, 0, alpha)); &#x2F;&#x2F;–lable显示前景图片 ui-&gt;label-&gt;setScaledContents(true); ui-&gt;label-&gt;setPixmap(temp); layout 的边界 layout-&gt;setMargin (0); 以上代码来自互联网，经本人整理发布,后续笔者研究后发布拖动窗口代码","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"QT","slug":"QT","permalink":"https://baiyuan.wang/tags/QT/"}]},{"title":"怎样用QT查找字符串并标记要查找的内容","slug":"how-to-use-qt-to-find-content-you-want-to-find-a-string-and-tag","date":"2014-12-26T13:09:51.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-use-qt-to-find-content-you-want-to-find-a-string-and-tag.html","link":"","permalink":"https://baiyuan.wang/how-to-use-qt-to-find-content-you-want-to-find-a-string-and-tag.html","excerpt":"","text":"效果预览: 代码分享：QString searchString &#x3D; ui-&gt;lineEdit_2-&gt;text(); QTextDocument *document &#x3D; ui-&gt;description-&gt;document(); ui-&gt;description-&gt;setHtml(ui-&gt;description-&gt;document()-&gt;toPlainText()); int number&#x3D;0; bool found &#x3D; false; QTextCursor highlightCursor(document); QTextCharFormat plainFormat(highlightCursor.charFormat()); QTextCharFormat colorFormat &#x3D; plainFormat; colorFormat.setForeground(Qt::red); if(ui-&gt;description-&gt;toPlainText()&#x3D;&#x3D;””){ QMessageBox::information(this, tr(“description first”), “Sorry, please display the description first!”); } else&#123; ui-&gt;result-&gt;setPlainText(&quot;&quot;); QString resultstring=&quot;搜索结果：&quot;; QString laststring; &#x2F;*while循环体是本代码的关键-——开始——*&#x2F;while (!highlightCursor.isNull() &amp;&amp; !highlightCursor.atEnd()) { if(ui-&gt;daxiaocheckBox-&gt;isChecked()&#x3D;&#x3D;true){ highlightCursor &#x3D; document-&gt;find(searchString, highlightCursor,QTextDocument::FindCaseSensitively); }&#x2F;&#x2F;这个是实现大小写区分效果的代码，你可能不需要 else highlightCursor &#x3D; document-&gt;find(searchString, highlightCursor); if (!highlightCursor.isNull()) { number++; found &#x3D; true; highlightCursor.movePosition(QTextCursor::Right,QTextCursor::KeepAnchor,0); highlightCursor.mergeCharFormat(colorFormat); laststring&#x3D;QString::number(highlightCursor.position(),10); if(ui-&gt;onlyTwo-&gt;isChecked()&#x3D;&#x3D;true){ if(number&lt;&#x3D;1) resultstring+=&quot;n occurrence&quot;+QString::number(number,10)+&quot;:—— position:&quot;+QString::number(highlightCursor.position(),10); &#125;//这个是实现大小写区分效果的代码，你可能不需要 else resultstring+&#x3D;”n occurrence”+QString::number(number,10)+”:—— position:”+QString::number(highlightCursor.position(),10); } }&#x2F;关键代码结束&#x2F; if(number&gt;1&amp;&amp;ui-&gt;onlyTwo-&gt;isChecked()&#x3D;&#x3D;true) resultstring+&#x3D;”n occurrence”+QString::number(number,10)+”:—— position:”+laststring; ui-&gt;result-&gt;setPlainText(resultstring); if (found &#x3D;&#x3D; false) { QMessageBox::information(this, tr(“Word Not Found”), “Sorry, the word cannot be found.”); } else { QMessageBox::information(this, tr(“Word was Found”), “the word ‘“+searchString+”‘ was found for “+QString::number(number,10)+((number&gt;1)? “ times”:” time”)); } } 代码解析将在笔者后续有空闲时间补全,请读者结合自身实际和关键代码分析，以为己用。代码交流，欢迎大家留言","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"QT","slug":"QT","permalink":"https://baiyuan.wang/tags/QT/"}]},{"title":"Qt多窗口切换程序","slug":"qt-multi-window-switches","date":"2014-12-25T09:07:47.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"qt-multi-window-switches.html","link":"","permalink":"https://baiyuan.wang/qt-multi-window-switches.html","excerpt":"","text":"Qt多窗口切换程序1.ui文件中布局 2.主要程序main.cpp#include &lt;QtGui&#x2F;QApplication&gt;#include “mainwindow.h”int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWindow w; w.show(); return a.exec(); } 主界面程序：mainwindow.hifndef MAINWINDOW_H#define MAINWINDOW_H#include #include “dialog1.h”#include “dialog2.h”namespace Ui {class MainWindow;}class MainWindow : public QMainWindow{ Q_OBJECTpublic: explicit MainWindow(QWidget *parent &#x3D; 0); ~MainWindow();private slots: void on_pushButton_clicked(); void on_pushButton_2_clicked(); void on_pushButton_3_clicked();private: Ui::MainWindow *ui; Dialog1 dialog1; Dialog2 dialog2;};#endif &#x2F;&#x2F; MAINWINDOW_H mainwindow.cpp#include “mainwindow.h”#include “ui_mainwindow.h”MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow){ ui-&gt;setupUi(this);}MainWindow::~MainWindow(){ delete ui;}void MainWindow::on_pushButton_clicked(){ this-&gt;hide(); dialog1.show(); dialog1.exec(); this-&gt;show();}void MainWindow::on_pushButton_2_clicked(){ this-&gt;close();}void MainWindow::on_pushButton_3_clicked(){ this-&gt;close(); dialog2.show(); dialog2.exec(); this-&gt;show();} dialog1.cpp #include “dialog1.h”#include “ui_dialog1.h”Dialog1::Dialog1(QWidget *parent) : QDialog(parent), ui(new Ui::Dialog1){ ui-&gt;setupUi(this);}Dialog1::~Dialog1(){ delete ui;}void Dialog1::on_pushButton_clicked(){ this-&gt;close();} dialog2.cpp与Dialog1相似 关键点： this-&gt;close(); dialog2.show(); dialog2.exec(); this-&gt;show(); 通过等待dialog.exec()消息，判断主界面是否回显。运行结果：","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"QT","slug":"QT","permalink":"https://baiyuan.wang/tags/QT/"}]},{"title":"[转载]QT5.1_Windows 下的 安卓开发环境配置","slug":"reprint-qt5-1-the-android-development-environment-configuration-under-windows","date":"2014-12-22T09:17:40.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"reprint-qt5-1-the-android-development-environment-configuration-under-windows.html","link":"","permalink":"https://baiyuan.wang/reprint-qt5-1-the-android-development-environment-configuration-under-windows.html","excerpt":"","text":"本教程开发环境: win8 64 位，win7 ,xp 应该更没有问题，注意选择 32 位 ,64位的区分 **1. 安装 ****Perl **http://strawberryperl.com/ 这步可能不是必须的，目前来说我是装上了的， 2.下载 **** MinGW-w64 http://sourceforge.net/projects/mingwbuilds/files/host-windows/releases/4.8.1/32-bit/threads-win32/dwarf/x32-4.8.1-release-win32-dwarf-rev1.7z/download 解压到指定目录，目录结构大概是这样 【D:mingw-buildsmingw32】，把【D:mingw-buildsmingw32bin】加入PATH 3.下载****mingwbuilds MSYS and external binaries (for git)http://sourceforge.net/projects/mingwbuilds/files/external-binary-packages/msys+7za+wget+svn+git+mercurial+cvs-rev13.7z/download 解压到上述MinGW-w64的相关目录，目录结构大概是这样 【D:mingw-buildsmsys】 4.安装JDK7 把 【jdk17bin】的路径加入 PATH 5.去安卓官网 下载 SDK,我下载的是 附带ECLIPSE版的，然后下载NDK，解压到SDK的同级目录,保证NDK，SDK的文件夹同级，此时启动附带的Eclipse,应该可以进行安卓APP开发了。 这里注意下 SDKMANAGER.exe，去掉空格，WIN8设置成以管理员启动好像才跑的起来 6.配置以下环境变量: set “ANDROID_NDK_PLATFORM&#x3D;android-9”set “ANDROID_TARGET_ARCH&#x3D;armeabi-v7a”set “ANDROID_BUILD_TOOLS_REVISION&#x3D;17.0.0”set “ANDROID_NDK_HOST&#x3D;windows-x86_64”orset “ANDROID_NDK_HOST&#x3D;windows”.. depending on which NDK you downloaded. 7.下载 QT5.1 for android ,并安装。 8.下载 ANT 9.配置QT CREATER 配置完后，应该就可以用AVD管理器新建模拟器，然后新建项目，编译时注意注意选成android端的。 此时走构建项目，make，部署，如果一切顺利的话，应该就可以跑了，我用9300测试成功。 目前新建里面的，移动QT应用目视不能按上述流程走。 另，可能在此时无法新建AVD,我的机器是重启之后才好用的 声明本文转自http://my.oschina.net/stardriver/blog/142923","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"QT","slug":"QT","permalink":"https://baiyuan.wang/tags/QT/"}]},{"title":"免费域名还可以这样用:为局域网FTP服务提供域名解析","slug":"free-domain-name-can-also-be-used-lan-ftp-service-provides-name-resolution","date":"2014-12-22T08:51:31.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"free-domain-name-can-also-be-used-lan-ftp-service-provides-name-resolution.html","link":"","permalink":"https://baiyuan.wang/free-domain-name-can-also-be-used-lan-ftp-service-provides-name-resolution.html","excerpt":"","text":"我们都知道域名的作用是简化访问地址，让你访问一个网站或者FTP时输入的一段有意义的英文字母甚至汉字而不是一段无规律的IP地址。在局域网网内建立共享资源的FTP是一件很普遍的事，但是大家会发现每次告诉别人一段IP来告诉别人你的FTP地址是一件很“鸡肋”的事情。所以解决IP地址记忆难的方法就是解析域名到你的IP。我们在浏览器中输入域名的时候，计算机通常会向本地DNS服务器请求域名对应的IP地址。如果大家向本地DNS（比如学校）请求在它的DNS数据库记录里为你添加你的IP和域名，这几乎是不太可能的事情。 某一天，笔者突发奇想： 能不能申请一个免费顶级域名来解析到你的IP呢 之所以说是“奇想”，是因为我觉得不太会有哪个人会把域名解析到局域网，也许域名解析商也不会支持吧。 但是结果出我意料，笔者成功在我的“DNSpod”域名管理中，成功添加了一个“ftp”A记录并解析到我的局域网IP：10.22.56.*；之后在资源管理器中成功访问了我的FTP服务器： 之所以使用免费域名，是因为局域网里的FTP服务没有必要发布在整个互联网，使用免费域名恰得其所。百度对TK域名收录很不友好（其实就是不收录TK域名网站），用免费域名来解析局域网IP也不失为一个绝好的方法。当然使用收费域名就太浪费了。 为局域网FTP服务提供域名解析的缺点在于：在你的局域网以外访问这个域名就肯定不是你的计算机了，还有你需要联入互联网向DNS服务器获取域名对应的IP","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"FTP","slug":"FTP","permalink":"https://baiyuan.wang/tags/FTP/"},{"name":"域名解析","slug":"域名解析","permalink":"https://baiyuan.wang/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"}]},{"title":"金工实习心得:锻造","slug":"experience-in-metalworking-forging","date":"2014-12-19T01:43:33.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"experience-in-metalworking-forging.html","link":"","permalink":"https://baiyuan.wang/experience-in-metalworking-forging.html","excerpt":"","text":"“宝剑锋从磨砺出”，剑之神器者，始于千锤百炼。在火的洗礼和空气锤的多次锻压下，又经如此的反反复复，工件，便被赋予了坚韧的内心，真正地成为了撑起大桥的钢筋铁骨。我想这便是“锻造”的核心要义。 然而，“锻造”并非我们在影视剧中铁匠们那看似毫无规律的锤锤打打。氧化，过热，过烧，内部裂纹，这是深藏在工件内部的质量隐患。要锻造，须得其法，只有掌握了正确的法门，锻造才能发挥其真正的作用。如同人，在学习中锻造，在社会中磨砺。人又如同锻造，须经千锤百炼又得有个尺度，正所谓劳逸结合，“一张一驰”。否则也会出现“过烧”，“过热”，甚至出现隐藏内心深处无法察觉的“内部裂纹”，在更加严峻的社会实践中，不经一战，“剑”断人“亡”。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"建立IPv6 FTP和web服务器实现跨校访问","slug":"setting-up-ipv6-ftp-and-web-server-implements-cross-school-access","date":"2014-12-18T14:19:36.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"setting-up-ipv6-ftp-and-web-server-implements-cross-school-access.html","link":"","permalink":"https://baiyuan.wang/setting-up-ipv6-ftp-and-web-server-implements-cross-school-access.html","excerpt":"","text":"现在在校园局域网里建立个人的FTP服务器和使用远程桌面已经蔚然成风。由于局域网给予了FTP高达10M的传输速度，它便成为极佳的分享工具。由于发现学校的电脑支持IPv6,又考虑到IPv6地址如同天文数字不存在不足问题，笔者突发奇想：能不能通过建立IPV4 FTP和WEB的方法建立IPV6的FTP和WEB服务器？甚至实现不同学校间支持IPV6用户的互联互通！ 试验的结果令人振奋，此法果然可行！下面放出我的试验结果图： 笔者使用这个FTP成功实现了和远在湖南大学同学的直接的FTP文件传输 ping测试结果： 教程：建立IPV6 FTP和web服务器实现跨校访问工具&#x2F;软件 win7及以上版本电脑（XP电脑开启IPV6的方法请百度） serv-u FTP建立软件，XAMPP web环境搭建软件 有IPV6访问功能的网络 （注：XAMPP支持PHP等，单纯的html和简单的FTP服务win7是自带的，可以不安装以上两种软件） 方法&#x2F;步骤 安装IPv6协议并验证是否有IPv6访问权限： 点击右下角网络图标，打开“网络和共享中心”-本地连接-属性-本连接使用下列项目 获取本机IPv6地址，可通过ipconfig命令 搭建FTP服务器 搭建IPV6 FTP服务器和搭建IPV4FTP服务器一样，打开serv-u管理控制台，在 在 域详细信息中 点击“配置域的监听器”，然后如下图添加监听器： 类型：FTP IP地址：你的IPV6地址 为了验证你是否你是否成功搭建，你可以在浏览器中键入：ftp:&#x2F;&#x2F;[你的IPV6地址] 搭建web服务器 搭建web服务器你可以百度，笔者推荐“XAMPP”这款软件，为了验证你是否你是否成功搭建，你可以在浏览器中键入：http:&#x2F;&#x2F;[你的IPV6地址] 下面是我的试验效果： 以上的WEB和FTP服务器访问，笔者在我的其他大学支持IPV6的同学计算机上试验通过，可以直接通过IPV6网络直接传文件和访问WEB网页 进阶篇：添加域名解析到本机IPV6地址，做地址好记的全IPV6网络的web&#x2F;ftp服务器！ 上面看到，IPV6的IP地址极长，和32位的IPV4相比，高达128位的IPv6足足是其4倍，这很不利于我们的记忆，我们可以把自己的域名解析到自己电脑的IPV6地址。 具体方法是在域名管理中添加“AAAA”记录指向你的IPv6地址，笔者使用的是DNSpod管理自己的域名，如下图 最后： 本教程系本人原创，互联网上类似资源也较少，希望大家批评指正。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"FTP","slug":"FTP","permalink":"https://baiyuan.wang/tags/FTP/"},{"name":"IPv6","slug":"IPv6","permalink":"https://baiyuan.wang/tags/IPv6/"}]},{"title":"QT中怎样修改系统时间及其时区错误问题","slug":"qt-how-to-modify-system-time-and-time-zone-error-problem","date":"2014-12-15T01:47:40.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"qt-how-to-modify-system-time-and-time-zone-error-problem.html","link":"","permalink":"https://baiyuan.wang/qt-how-to-modify-system-time-and-time-zone-error-problem.html","excerpt":"","text":"最近写了QT4的第一个编码问题：系统时间界面及实现修改系统时间。本人综合网上的资源，在此作了一个总结。 首先，Qt本身不提供时间设置的函数Qt本身不提供时间设置的函数，实现修改系统时间使用windows 的native API函数SetSystemTime 所以，头文件需要加入 #include&lt;windows.h&gt; 代码部分&#x2F;&#x2F;下面是我的程序的部分代码void MainWindow::on_pushButton_3_clicked(){ SYSTEMTIME st; GetLocalTime(&amp;st); st.wHour&#x3D;ui-&gt;spinBox-&gt;value(); st.wMinute&#x3D;ui-&gt;spinBox_2-&gt;value(); st.wSecond&#x3D;ui-&gt;spinBox_3-&gt;value(); SetLocalTime(&amp;st);} 常见问题： 可能有人在网上找到下述代码： &#x2F;&#x2F;下面的代码出现时区问题bool Dialog::timeedit(){ SYSTEMTIME st; GetSystemTime(&amp;st); st.wHour&#x3D;ui-&gt;timeEdit-&gt;time().hour(); st.wMinute&#x3D;ui-&gt;timeEdit-&gt;time().minute(); return SetSystemTime(&amp;st);} 上述代码的运行结果出现时区不对问题：GetSystemTime()获取的是格林尼治时间; 以上都没问题，程序不报错，但是系统时间就是不改变 请用 管理员身份运行QTcreator，程序权限不够","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"QT","slug":"QT","permalink":"https://baiyuan.wang/tags/QT/"}]},{"title":"怎样在网页中加入“网站已运行多少天”","slug":"how-to-join-page-website-has-been-running-for-many-days","date":"2014-12-14T07:08:00.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"how-to-join-page-website-has-been-running-for-many-days.html","link":"","permalink":"https://baiyuan.wang/how-to-join-page-website-has-been-running-for-many-days.html","excerpt":"","text":"现在有很多 网页会在页脚版权部分加入网站已运行多少天的信息，本文章以我的博客为例向大家分享一下代码，代码非本人原创 代码如下： 王柏元的博客已运行 王柏元的博客已运行","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"}]},{"title":"局域网内远程桌面：让你的电脑如影随形","slug":"remote-desktop-in-lan-let-your-computer-in-hand","date":"2014-12-12T15:14:56.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"remote-desktop-in-lan-let-your-computer-in-hand.html","link":"","permalink":"https://baiyuan.wang/remote-desktop-in-lan-let-your-computer-in-hand.html","excerpt":"","text":"现在大家都有自己的电脑，由于使用时间较长都自己的电脑都有亲和感。但是在学校实验室，由于学校电脑的配置或老旧问题，让我们用的很不爽。所以我们不妨用学校的电脑连接自己的电脑进行远程登录，让自己的电脑如影随行。 1.打开自己电脑的远程登录权限a.右键“计算机”，以此打开 属性-远程设置： 在右侧的远程桌面我们看到有三个选项：不允许连接，允许任意版本连接，仅允许运行使用网络级别身份认证……。 在这里我建议勾选第二项即允许任意版本，这意味着不管你自己的电脑是不是win XP还是WIN 7，别人的win XP或者win7都能远程登录。如果大家在远程桌面出现无法连接的问题时不妨看看是不是这里出了问题。 2.获取本机IP地址获取IP地址可以点击电脑右下角网络图标，进入网络与共享中心-查看活动网络-本地连接（即你当前联网的网络连接），在常规选项卡中点击详细信息，便可获取自己的IPV4地址，即用作远程登录的IP地址； 你也可以在命令指示符中输入“ipconfig”获取当前的IP地址 3.打开他人电脑的远程桌面连接，键入IP地址连接依次点击“开始”-所有程序-附件-远程桌面连接， 键入第二步获取的IP地址，然后点击“连接”，之后就会进入用户登录界面。然后你就能享受远程登录的快感了。 常见问题a.以上配置均无问题还是“无法连接”？ 请看看防火墙有没有屏蔽远程桌面连接联网 b.远程桌面网速要求高，会不会也会消耗大量流量 远程桌面如果在局域网内进行，一般不会消耗你的计费流量 便捷小贴士你可以把远程桌面连接配置保存，以便以便之后直接打开远程桌面文件直接连接，不用输入IP地址 方法：在上图点击“选项”下拉三角，连接设置-保存","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"[转载]各种字符串Hash函数","slug":"reprint-string-hash-function","date":"2014-12-11T09:08:18.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"reprint-string-hash-function.html","link":"","permalink":"https://baiyuan.wang/reprint-string-hash-function.html","excerpt":"","text":"常用的字符串Hash函数还有ELFHash，APHash等等，都是十分简单有效的方法。这些函数使用位运算使得每一个字符都对最后的函数值产生影响。另外还有以MD5和SHA1为代表的杂凑函数，这些函数几乎不可能找到碰撞。 常用字符串哈希函数有BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等。 具体的代码分享 &#x2F;&#x2F;SDBMHashunsigned int SDBMHash(char *str){ unsigned int hash &#x3D; 0; while (*str) &#123; // equivalent to: hash = 65599\\*hash + (\\*str++); hash = (*str++) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash; &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; RS Hash Functionunsigned int RSHash(char *str){ unsigned int b &#x3D; 378551; unsigned int a &#x3D; 63689; unsigned int hash &#x3D; 0; while (*str) &#123; hash = hash * a + (*str++); a *= b; &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; JS Hash Functionunsigned int JSHash(char *str){ unsigned int hash &#x3D; 1315423911; while (*str) &#123; hash ^= ((hash &lt;&lt; 5) + (*str++) + (hash &gt;&gt; 2)); &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; P. J. Weinberger Hash Functionunsigned int PJWHash(char *str){ unsigned int BitsInUnignedInt &#x3D; (unsigned int)(sizeof(unsigned int) * 8); unsigned int ThreeQuarters &#x3D; (unsigned int)((BitsInUnignedInt * 3) &#x2F; 4); unsigned int OneEighth &#x3D; (unsigned int)(BitsInUnignedInt &#x2F; 8); unsigned int HighBits &#x3D; (unsigned int)(0xFFFFFFFF) &lt;&lt; (BitsInUnignedInt - OneEighth); unsigned int hash &#x3D; 0; unsigned int test &#x3D; 0; while (*str) &#123; hash = (hash &lt;&lt; OneEighth) + (*str++); if ((test = hash &amp; HighBits) != 0) &#123; hash = ((hash ^ (test &gt;&gt; ThreeQuarters)) &amp; (~HighBits)); &#125; &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; ELF Hash Functionunsigned int ELFHash(char *str){ unsigned int hash &#x3D; 0; unsigned int x &#x3D; 0; while (*str) &#123; hash = (hash &lt;&lt; 4) + (*str++); if ((x = hash &amp; 0xF0000000L) != 0) &#123; hash ^= (x &gt;&gt; 24); hash &amp;= ~x; &#125; &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; BKDR Hash Functionunsigned int BKDRHash(char *str){ unsigned int seed &#x3D; 131; &#x2F;&#x2F; 31 131 1313 13131 131313 etc.. unsigned int hash &#x3D; 0; while (*str) &#123; hash = hash * seed + (*str++); &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; DJB Hash Functionunsigned int DJBHash(char *str){ unsigned int hash &#x3D; 5381; while (*str) &#123; hash += (hash &lt;&lt; 5) + (*str++); &#125; return (hash &amp; 0x7FFFFFFF); } &#x2F;&#x2F; AP Hash Functionunsigned int APHash(char *str){ unsigned int hash &#x3D; 0; int i; for (i=0; *str; i++) &#123; if ((i &amp; 1) == 0) &#123; hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3)); &#125; else &#123; hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5))); &#125; &#125; return (hash &amp; 0x7FFFFFFF); }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构Exam 2:Enhanced Parking Lot Simulation","slug":"exam-2enhanced-parking-lot-of-data-structure-simulation","date":"2014-12-08T13:49:13.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"exam-2enhanced-parking-lot-of-data-structure-simulation.html","link":"","permalink":"https://baiyuan.wang/exam-2enhanced-parking-lot-of-data-structure-simulation.html","excerpt":"","text":"Description This assessment tests your ability to use the STL stack adapter, the STL vector container, and the STL find algorithm to solve a problem. You are asked to finish the implementation of a program that simulates a multiple-aisle parking lot. When cars are parked bumper-to-bumper, each aisle in this parking lot can hold three cars. There are five aisles in the parking lot. It is your task to finish the implementation of the simulation that processes the vehicle arrivals and departures. The goal of the simulation is to keep track of and report how many times individual cars are moved while handling the departure of other cars. The simulation also displays an alphabetized list of all the cars that visited the parking lot during the simulation. 答案：main.cpp #include #include #include #include #include #include #include #include #include “car.h”using namespace std;const unsigned int PARKING_SPOTS_PER_AISLE &#x3D; 3;const unsigned int NUMBER_OF_AISLES &#x3D; 5; void handle_arrival(vector&amp;, vector&lt;stack &gt;&amp;, const string&amp;);void handle_departure(vector&amp;, vector&lt;stack &gt;&amp;, const string&amp;);Car&amp; find_car(vector&amp;, string); int main(int argc, char* argv[]){ try &#123; if (argc != 2) &#123; cerr &lt;&lt; &quot;Usage:n&quot; &lt;&lt; argv\\[0\\] &lt;&lt; &quot; data-file&quot;; return EXIT_FAILURE; &#125; ifstream inf(argv\\[1\\]); if (! inf) &#123; cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; argv\\[1\\]; return EXIT_FAILURE; &#125; vector&lt;Car&gt; cars; vector&lt; stack&lt;string&gt; &gt; parking\\_lot(NUMBER\\_OF_AISLES); while (! inf.eof()) &#123; string action, plate; inf &gt;&gt; plate &gt;&gt; action; if (action == &quot;arrives&quot;) &#123; handle\\_arrival(cars, parking\\_lot, plate); &#125; else if (action == &quot;departs&quot;) &#123; handle\\_departure(cars, parking\\_lot, plate); &#125; else &#123; cerr &lt;&lt; &quot;Unknown action: &quot; &lt;&lt; action &lt;&lt; endl; &#125; &#125; inf.close(); cout &lt;&lt; &quot;nHere are all the cars that visited the lot today:n&quot;; sort(cars.begin(),cars.end()); for(int i=0; i&lt;cars.size(); i++) cout&lt;&lt;cars\\[i\\].getPlate()&lt;&lt;&quot; &quot;&lt;&lt;cars\\[i\\].getAisle()&lt;&lt;&quot; aisle moved &quot;&lt;&lt;cars\\[i\\].getTimesMoved()&lt;&lt;&quot; times &quot;&lt;&lt;endl; // TODO: Output the license plates of all the // cars that visited the lot, in alphabetical order return EXIT_SUCCESS; &#125; catch (exception&amp; e) &#123; cerr &lt;&lt; e.what() &lt;&lt; endl; &#125; catch (...) &#123; cerr &lt;&lt; &quot;Unknown exception caught!&quot; &lt;&lt; endl; &#125; return EXIT_FAILURE; } void handle_arrival(vector&amp; cars, vector&lt; stack &gt;&amp; parking_lot, const string&amp; plate){for(int i&#x3D;0;i&lt;parking_lot.size();i++){ if(parking_lot[i].size()&lt;PARKING_SPOTS_PER_AISLE) {parking_lot[i].push(plate); cars.push_back(Car(plate,i)); break;} else if(parking_lot[i].size()&gt;NUMBER_OF_AISLES) cout&lt;&lt;”停车场所有过道已满”;} // TODO: Handle car arrivals } void handle_departure(vector&amp; cars, vector&lt; stack &gt;&amp; parking_lot, const string&amp; plate){Car Target_car&#x3D;find_car(cars,plate);int Target_aisle &#x3D;Target_car.getAisle();stack temp; while(!(parking_lot[Target_aisle].top()&#x3D;&#x3D;plate)) {Car *tempcar&#x3D;&amp;find_car(cars,parking_lot[Target_aisle].top()); tempcar-&gt;setTimesMoved(tempcar-&gt;getTimesMoved()+1); temp.push(parking_lot[Target_aisle].top()); parking_lot[Target_aisle].pop(); &#125; parking\\_lot\\[Target\\_aisle\\].pop(); while(temp.size()!=0) &#123; parking_lot[Target_aisle].push(temp.top()); temp.pop(); }} Car&amp; find_car(vector&amp; cars, string plate){ for(int i &#x3D; 0; i &lt; cars.size(); i++){ if(cars[i].getPlate()&#x3D;&#x3D;plate) return cars[i]; } &#x2F;&#x2F; TODO: Return a reference to the &#x2F;&#x2F; the Car object whose license plate equals &#x2F;&#x2F; the parameter ‘plate’ }","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://baiyuan.wang/tags/%E6%A0%88/"}]},{"title":"css3圆角边框和边框阴影示例","slug":"css3-rounded-corners-and-shadow-border-example","date":"2014-12-06T13:30:50.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"css3-rounded-corners-and-shadow-border-example.html","link":"","permalink":"https://baiyuan.wang/css3-rounded-corners-and-shadow-border-example.html","excerpt":"","text":"border-radius向元素添加圆角边框，css3中的。IE9+ chrome safari5+ firefox4+ 现在都支持。可以向input div等设置边框。与border相似，可以四个角一起设置，也可以单独设置。 1.圆角效果效果演示： css3圆角边框和边框阴影示例——王柏元的博客 语法： 代码如下: border-radius: 1-4 length|% &#x2F; 1-4 length|%;-moz-border-radius:10px;支持旧的firefox-webkit-border-radius:10px;支持chrome 按top-left, top-right, bottom-right, bottom-left顺序设置每个 radius 的值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。 例子1: 代码如下: border-radius:2px; 等价于： 代码如下: border-top-left-radius:2px;border-top-right-radius:2px;border-bottom-right-radius:2px;border-bottom-left-radius:2px; 例子2: 代码如下: border-radius:2em 1em 4em &#x2F; 0.5em 3em; 等价于： 代码如下: border-top-left-radius:2em 0.5;border-top-right-radius:1em 3em;border-bottom-right-radius:4em 0.5em;border-bottom-left-radius:1em 3em; 2.阴影效果效果演示： css3圆角边框和边框阴影示例——王柏元的博客 box-shadow向框添加一个或多个阴影。IE9+、Firefox 4、Chrome、Opera 以及 Safari 5.1.1 支持 box-shadow 属性。 语法： 代码如下: box-shadow: h-shadow v-shadow blur spread color inset; h-shadow,v-shadow必须。水平，垂直阴影的位置。允许赋值。blur可选，模糊距离。spread可选，阴影的尺寸。color可选，阴影的颜色。inset可选，将外部阴影（outset）改为内部阴影。 例子： 代码如下: box-shadow: inset 3px 3px 6px #ccc;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://baiyuan.wang/tags/CSS/"}]},{"title":"网络空间，你真的可以口无遮掩吗？","slug":"in-cyberspace-you-can-really-cover-your-mouth-right","date":"2014-12-02T15:10:24.000Z","updated":"2024-03-28T02:24:50.732Z","comments":true,"path":"in-cyberspace-you-can-really-cover-your-mouth-right.html","link":"","permalink":"https://baiyuan.wang/in-cyberspace-you-can-really-cover-your-mouth-right.html","excerpt":"","text":"今天，一个匿名的朋友在我的博客里发了个评论，并叫我别查他的IP地址，但是将计就计的我打开后台的评论管理果然发现了他的IP ，虽然我知道网站后台一般是可以获取用户的Ip地址的。但是这一查让我也吃了一惊。 于是百度了一下这个IP，在http://ip.911cha.com/查询到了这个IP的详细物理地址，其精确度让我吃惊。 作为保护朋友的隐私，第一幅图里的IP是他隐藏后的，对于”隐藏IP”的办法，大家可以百度一下 所以，当我们在各大网站发表自己的意见时你是否会反省：网络空间，你真的可以口无遮掩吗？","categories":[{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"计算机技术","slug":"极客视点/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"IP","slug":"IP","permalink":"https://baiyuan.wang/tags/IP/"}]},{"title":"【转载】带宽、下载速度、网速 的关系","slug":"reprint-relationship-between-bandwidth-and-download-speed-speed","date":"2014-12-01T07:13:52.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"reprint-relationship-between-bandwidth-and-download-speed-speed.html","link":"","permalink":"https://baiyuan.wang/reprint-relationship-between-bandwidth-and-download-speed-speed.html","excerpt":"","text":"有很多人以为2Mb的带宽等同於2MB&#x2F;s下载速度，以致出现不少误会，其实一般数据机及网络通讯的传输速率都是以「bps」为单位。如28Kbps、56Kbps、128Kbps、1Mbps 及 10Mbps 等等。小写 b 代表 bit(位元),大写 B代表Byte(字节),1Byte&#x3D;8bit。以2M 带宽为例，2Mbps 等如2 X 1024&#x2F;8，亦即等于256KB&#x2F;s的下载速度，但以上的速度只是理论上的最高速度。 因为在实际应用上要减去大约30% 的Ethernet header、TCP header及 ATM header等网络损耗，所以其平均下载速度约为180KB&#x2F;s 左右。 一般说来，带宽越大，下载速度就越快，但下载速度除受服务供应商因素所影响外，用户本身所使用操作系统、浏览器、电脑配备等亦可影响下载速度，而且还跟你连接的网站的服务器能力，提供的带宽有密切关系。（同时浏览同个网站的人数越多，这个网站所能提供给每个浏览者的带宽就越低）。这些都影响下载速度。 网速则指服务器响应你的连接要求或交换你发送的数据的时间，也就是网络延时或者叫ping值，单位是ms（毫秒），不少用户把网速等同于下载速度，也是不正确的。Ping值的大小表示是客户端和服务器端交换数据的快慢。Ping值越小，网络速度越好。 一般说来，带宽越大，ping值就会越小，但实际情况却取决于网络线路的连接和路由，出现相反的情况也不足为奇。为例，2Mbps 等如2 X 1024&#x2F;8，亦即等于256KB&#x2F;s的下载速度，但以上的速度只是理论上的最高速度。因为在实际应用上要减去大约30% 的Ethernet header、TCP header及 ATM header等网络损耗，所以其平均下载速度约为180KB&#x2F;s 左右。 一般说来，带宽越大，下载速度就越快，但下载速度除受服务供应商因素所影响外，用户本身所使用操作系统、浏览器、电脑配备等亦可影响下载速度，而且还跟你连接的网站的服务器能力，提供的带宽有密切关系。（同时浏览同个网站的人数越多，这个网站所能提供给每个浏览者的带宽就越低）。这些都影响下载速度。 网速则指服务器响应你的连接要求或交换你发送的数据的时间，也就是网络延时或者叫ping值，单位是ms（毫秒），不少用户把网速等同于下载速度，也是不正确的。Ping值的大小表示是客户端和服务器端交换数据的快慢。Ping值越小，网络速度越好。 一般说来，带宽越大，ping值就会越小，但实际情况却取决于网络线路的连接和路由，出现相反的情况也不足为奇。","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"数据结构-传染病问题","slug":"data-structure-infectious-diseases","date":"2014-11-30T08:31:08.000Z","updated":"2024-03-28T02:24:50.728Z","comments":true,"path":"data-structure-infectious-diseases.html","link":"","permalink":"https://baiyuan.wang/data-structure-infectious-diseases.html","excerpt":"","text":"DescriptionThis assignment asks you to finish the implementation of a program that assesses the level of infection in a tissue sample. You are given data representing a rectangular tissue sample, overlaid with a grid. Certain portions of the tissue are infected; others are not. Your goal is to help assess the extent of the infection by writing a program that, given the coordinates of a colony of infection, can determine its size. A typical use of the program follows. The user interacts with the program only through command-line arguments. The user supplies to the program a data filename and the coordinates of a cell in the grid. The coordinates are specified by row and then column, both starting at zero. The program calculates the extent of infection at that coordinate and outputs a two-dimensional representation of the tissue sample. Figure 1 depicts（叙述） the execution（执行） of the program. 代码#include #include using namespace std; #include “grid.h” &#x2F;&#x2F; You do not need to alter function indexof.int grid::indexof (int row, int col) const { return row*cols+col;} &#x2F;&#x2F; You do not need to alter function infected.bool grid::infected(int row, int col) const { return (area-&gt;operator[](indexof(row, col)) &#x3D;&#x3D; INFECTED);} &#x2F;&#x2F; You may need to alter the constructorgrid::grid (string file) { ifstream grid_file; grid_file.open (file.c_str()); grid_file &gt;&gt; rows; grid_file &gt;&gt; cols; area &#x3D; new vector(rowscols, NOT_INFECTED); note &#x3D; new vector(rowscols, “0 “); while (true) { int blob_row; int blob_col; grid\\_file &gt;&gt; blob\\_row; grid\\_file &gt;&gt; blob\\_col; if (grid_file.eof()) &#123; break; &#125; area-&gt;operator\\[\\](indexof(blob\\_row,blob\\_col)) = INFECTED; note-&gt;operator\\[\\](indexof(blob\\_row,blob\\_col)) = &quot;1 &quot;; } grid_file.close();} &#x2F;&#x2F; You may need to alter the destructorgrid::~grid () { delete area; delete note;} &#x2F;&#x2F; You will need to alter this function to display the&#x2F;&#x2F; plus signs (+) next to the cells that belong to&#x2F;&#x2F; a counted colony.ostream &amp;operator&lt;&lt;(ostream &amp;stream, const grid&amp; ob) { for (int row&#x3D;0; row &lt; ob.rows; row++) { for (int col=0; col &lt; ob.cols; col++) &#123; //stream &lt;&lt; ob.area-&gt;operator\\[\\](ob.indexof(row, col)); stream &lt;&lt; ob.note-&gt;operator\\[\\](ob.indexof(row, col)); &#125; stream &lt;&lt; endl; } stream &lt;&lt; endl; return stream;} &#x2F;&#x2F; Replace the return statement in this function with your&#x2F;&#x2F; recursive implementation of this method *&#x2F;int grid::count (int row, int col) { if(0&lt;&#x3D;row&amp;&amp;row &lt; rows&amp;&amp;0&lt;&#x3D;col&amp;&amp;col &lt; cols) { if(infected( row,col)&amp;&amp;note-&gt;operator[](indexof(row,col)) &#x3D;&#x3D;”1 “) { note-&gt;operator[](indexof( row,col)) &#x3D;”1+ “; return 1+count (row+1, col+1)+count (row+1, col)+ count (row+1, col-1)+count (row, col-1)+ count (row , col+1)+count (row-1, col+1)+ count (row-1, col )+count (row-1, col-1); } else return 0; } else return 0;}&#x2F;*string grid::noteplus(int row,int col) const{ if(note-&gt;operator[](indexof(row, col)) &#x3D;&#x3D; INFECTED){ return “+ “; }else return “ “;} *&#x2F;","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"递归","slug":"递归","permalink":"https://baiyuan.wang/tags/%E9%80%92%E5%BD%92/"},{"name":"数据结构","slug":"数据结构","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【转载】利用第三方网站在线做自己的APP","slug":"reprint-use-of-third-party-web-sites-online-to-do-your-app","date":"2014-11-30T03:14:02.000Z","updated":"2024-03-28T02:24:50.736Z","comments":true,"path":"reprint-use-of-third-party-web-sites-online-to-do-your-app.html","link":"","permalink":"https://baiyuan.wang/reprint-use-of-third-party-web-sites-online-to-do-your-app.html","excerpt":"","text":"对大多数的WPer而言，自己开发移动应用终究是不现实的。不说Native App的开发需要较好地Java基础，即使是Hybrid开发，例如使用用PhoneGap，现在也是比较复杂的事情。 好在技术的进步，让我们可以在网络上找到很多可以免费使用的工具，把我们的Wordpress网站转变成一个看起来还可以的移动App。 通过搜索引擎，可以找到很多在线移动App制作的工具，很多都是免费的，用起来也很简单。在前些时候尝试Wordpress博客移动化的时候，研究了一些在线移动App制作的工具，分享如下： 国内主流的在线APP生成工具 百度Site app：http://siteapp.baidu.com 应用公园：http://www.apppark.cn/ 追信魔盒：http://app.zhui.cn/ 安米网：http://www.appbyme.com/ 简网APP工场：http://www.cutt.com/ 应用之星：http://www.appstar.com.cn/ AppCan：http://www.appcan.cn/ 国外比较有名的有在线开发平台 Infinite Monkeys：http://www.infinitemonkeys.mobi apppmakr：http://www.appmakr.com/ GameSalad：http://gamesalad.com/ Jimu：http://jimulabs.com/ Mobile Roadie：http://mobileroadie.com/ Attendify：http://attendify.com/","categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"},{"name":"作品","slug":"作品","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/"},{"name":"技术","slug":"作品/技术","permalink":"https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/%E6%8A%80%E6%9C%AF/"},{"name":"业界","slug":"技术/业界","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E4%B8%9A%E7%95%8C/"},{"name":"极客视点","slug":"技术/极客视点","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"极客视点","slug":"极客视点","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"岁月","slug":"岁月","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"},{"name":"软件开发","slug":"极客视点/软件开发","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"算法语言","slug":"技术/算法语言","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/"},{"name":"软件开发","slug":"技术/算法语言/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"软件开发","slug":"技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"技术/前端","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"百元百科","slug":"百元百科","permalink":"https://baiyuan.wang/categories/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"},{"name":"业界","slug":"业界","permalink":"https://baiyuan.wang/categories/%E4%B8%9A%E7%95%8C/"},{"name":"极客视点","slug":"业界/极客视点","permalink":"https://baiyuan.wang/categories/%E4%B8%9A%E7%95%8C/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"百元百科","slug":"技术/百元百科","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E7%99%BE%E5%85%83%E7%99%BE%E7%A7%91/"},{"name":"前端","slug":"前端","permalink":"https://baiyuan.wang/categories/%E5%89%8D%E7%AB%AF/"},{"name":"wordpress作品","slug":"技术/wordpress作品","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/wordpress%E4%BD%9C%E5%93%81/"},{"name":"计算机技术","slug":"极客视点/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"},{"name":"计算机技术","slug":"技术/计算机技术","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"},{"name":"软件开发","slug":"技术/计算机技术/软件开发","permalink":"https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"软件开发","slug":"前端/软件开发","permalink":"https://baiyuan.wang/categories/%E5%89%8D%E7%AB%AF/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"Algorithm language","slug":"Algorithm-language","permalink":"https://baiyuan.wang/categories/Algorithm-language/"},{"name":"极客视点","slug":"岁月/极客视点","permalink":"https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"},{"name":"Geek Viewpoint","slug":"Geek-Viewpoint","permalink":"https://baiyuan.wang/categories/Geek-Viewpoint/"}],"tags":[{"name":"基础设施","slug":"基础设施","permalink":"https://baiyuan.wang/tags/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"},{"name":"安全","slug":"安全","permalink":"https://baiyuan.wang/tags/%E5%AE%89%E5%85%A8/"},{"name":"敏捷","slug":"敏捷","permalink":"https://baiyuan.wang/tags/%E6%95%8F%E6%8D%B7/"},{"name":"DevOps","slug":"DevOps","permalink":"https://baiyuan.wang/tags/DevOps/"},{"name":"Node.JS","slug":"Node-JS","permalink":"https://baiyuan.wang/tags/Node-JS/"},{"name":"JAVA","slug":"JAVA","permalink":"https://baiyuan.wang/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://baiyuan.wang/tags/Spring/"},{"name":"运维","slug":"运维","permalink":"https://baiyuan.wang/tags/%E8%BF%90%E7%BB%B4/"},{"name":"日志","slug":"日志","permalink":"https://baiyuan.wang/tags/%E6%97%A5%E5%BF%97/"},{"name":"网站安全","slug":"网站安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://baiyuan.wang/tags/CI-CD/"},{"name":"JS","slug":"JS","permalink":"https://baiyuan.wang/tags/JS/"},{"name":"微服务","slug":"微服务","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"架构","slug":"架构","permalink":"https://baiyuan.wang/tags/%E6%9E%B6%E6%9E%84/"},{"name":"沟通","slug":"沟通","permalink":"https://baiyuan.wang/tags/%E6%B2%9F%E9%80%9A/"},{"name":"AWS","slug":"AWS","permalink":"https://baiyuan.wang/tags/AWS/"},{"name":"React Native","slug":"React-Native","permalink":"https://baiyuan.wang/tags/React-Native/"},{"name":"Docker","slug":"Docker","permalink":"https://baiyuan.wang/tags/Docker/"},{"name":"应用监控","slug":"应用监控","permalink":"https://baiyuan.wang/tags/%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/"},{"name":"生活哲学","slug":"生活哲学","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"},{"name":"IoT","slug":"IoT","permalink":"https://baiyuan.wang/tags/IoT/"},{"name":"生活","slug":"生活","permalink":"https://baiyuan.wang/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旅行","slug":"旅行","permalink":"https://baiyuan.wang/tags/%E6%97%85%E8%A1%8C/"},{"name":"个人程序库","slug":"个人程序库","permalink":"https://baiyuan.wang/tags/%E4%B8%AA%E4%BA%BA%E7%A8%8B%E5%BA%8F%E5%BA%93/"},{"name":"android","slug":"android","permalink":"https://baiyuan.wang/tags/android/"},{"name":"android开发","slug":"android开发","permalink":"https://baiyuan.wang/tags/android%E5%BC%80%E5%8F%91/"},{"name":"微信","slug":"微信","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"ruby","slug":"ruby","permalink":"https://baiyuan.wang/tags/ruby/"},{"name":"Web","slug":"Web","permalink":"https://baiyuan.wang/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://baiyuan.wang/tags/CSS/"},{"name":"Linux","slug":"Linux","permalink":"https://baiyuan.wang/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://baiyuan.wang/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"htaccess","slug":"htaccess","permalink":"https://baiyuan.wang/tags/htaccess/"},{"name":"软件工程","slug":"软件工程","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"奇思妙想","slug":"奇思妙想","permalink":"https://baiyuan.wang/tags/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/"},{"name":"应聘复习","slug":"应聘复习","permalink":"https://baiyuan.wang/tags/%E5%BA%94%E8%81%98%E5%A4%8D%E4%B9%A0/"},{"name":"C++","slug":"C","permalink":"https://baiyuan.wang/tags/C/"},{"name":"API","slug":"API","permalink":"https://baiyuan.wang/tags/API/"},{"name":"博客客户端","slug":"博客客户端","permalink":"https://baiyuan.wang/tags/%E5%8D%9A%E5%AE%A2%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"汇编","slug":"汇编","permalink":"https://baiyuan.wang/tags/%E6%B1%87%E7%BC%96/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://baiyuan.wang/tags/Android-Studio/"},{"name":"PHP","slug":"PHP","permalink":"https://baiyuan.wang/tags/PHP/"},{"name":"androd","slug":"androd","permalink":"https://baiyuan.wang/tags/androd/"},{"name":"IOS","slug":"IOS","permalink":"https://baiyuan.wang/tags/IOS/"},{"name":"swift","slug":"swift","permalink":"https://baiyuan.wang/tags/swift/"},{"name":"网站优化","slug":"网站优化","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"Http","slug":"Http","permalink":"https://baiyuan.wang/tags/Http/"},{"name":"SEO","slug":"SEO","permalink":"https://baiyuan.wang/tags/SEO/"},{"name":"闲言碎语","slug":"闲言碎语","permalink":"https://baiyuan.wang/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"},{"name":"回溯法","slug":"回溯法","permalink":"https://baiyuan.wang/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"网络安全","slug":"网络安全","permalink":"https://baiyuan.wang/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://baiyuan.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"递归","slug":"递归","permalink":"https://baiyuan.wang/tags/%E9%80%92%E5%BD%92/"},{"name":"帮助文档","slug":"帮助文档","permalink":"https://baiyuan.wang/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"},{"name":"PPT","slug":"PPT","permalink":"https://baiyuan.wang/tags/PPT/"},{"name":"android控件","slug":"android控件","permalink":"https://baiyuan.wang/tags/android%E6%8E%A7%E4%BB%B6/"},{"name":"Phinx","slug":"Phinx","permalink":"https://baiyuan.wang/tags/Phinx/"},{"name":"翻译文章","slug":"翻译文章","permalink":"https://baiyuan.wang/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"},{"name":"json","slug":"json","permalink":"https://baiyuan.wang/tags/json/"},{"name":"在线应用","slug":"在线应用","permalink":"https://baiyuan.wang/tags/%E5%9C%A8%E7%BA%BF%E5%BA%94%E7%94%A8/"},{"name":"wordpress","slug":"wordpress","permalink":"https://baiyuan.wang/tags/wordpress/"},{"name":"wordpress插件制作","slug":"wordpress插件制作","permalink":"https://baiyuan.wang/tags/wordpress%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/"},{"name":"人工智能","slug":"人工智能","permalink":"https://baiyuan.wang/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"工作求职","slug":"工作求职","permalink":"https://baiyuan.wang/tags/%E5%B7%A5%E4%BD%9C%E6%B1%82%E8%81%8C/"},{"name":"FontAwesome","slug":"FontAwesome","permalink":"https://baiyuan.wang/tags/FontAwesome/"},{"name":"图标字体","slug":"图标字体","permalink":"https://baiyuan.wang/tags/%E5%9B%BE%E6%A0%87%E5%AD%97%E4%BD%93/"},{"name":"IP","slug":"IP","permalink":"https://baiyuan.wang/tags/IP/"},{"name":"MySql","slug":"MySql","permalink":"https://baiyuan.wang/tags/MySql/"},{"name":"域名解析","slug":"域名解析","permalink":"https://baiyuan.wang/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"name":"IPv6","slug":"IPv6","permalink":"https://baiyuan.wang/tags/IPv6/"},{"name":"SSD8","slug":"SSD8","permalink":"https://baiyuan.wang/tags/SSD8/"},{"name":"数据库","slug":"数据库","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSD7","slug":"SSD7","permalink":"https://baiyuan.wang/tags/SSD7/"},{"name":"命令指示符","slug":"命令指示符","permalink":"https://baiyuan.wang/tags/%E5%91%BD%E4%BB%A4%E6%8C%87%E7%A4%BA%E7%AC%A6/"},{"name":"软件推荐","slug":"软件推荐","permalink":"https://baiyuan.wang/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"Navicat","slug":"Navicat","permalink":"https://baiyuan.wang/tags/Navicat/"},{"name":"UA","slug":"UA","permalink":"https://baiyuan.wang/tags/UA/"},{"name":"officeWord","slug":"officeWord","permalink":"https://baiyuan.wang/tags/officeWord/"},{"name":"虚拟主机","slug":"虚拟主机","permalink":"https://baiyuan.wang/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"},{"name":"浏览器","slug":"浏览器","permalink":"https://baiyuan.wang/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"robots.txt","slug":"robots-txt","permalink":"https://baiyuan.wang/tags/robots-txt/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://baiyuan.wang/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"eclipse","slug":"eclipse","permalink":"https://baiyuan.wang/tags/eclipse/"},{"name":"IT博客","slug":"IT博客","permalink":"https://baiyuan.wang/tags/IT%E5%8D%9A%E5%AE%A2/"},{"name":"文章版权保护","slug":"文章版权保护","permalink":"https://baiyuan.wang/tags/%E6%96%87%E7%AB%A0%E7%89%88%E6%9D%83%E4%BF%9D%E6%8A%A4/"},{"name":"重装系统","slug":"重装系统","permalink":"https://baiyuan.wang/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"},{"name":"DNSPOD","slug":"DNSPOD","permalink":"https://baiyuan.wang/tags/DNSPOD/"},{"name":"免费域名","slug":"免费域名","permalink":"https://baiyuan.wang/tags/%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D/"},{"name":"域名管理","slug":"域名管理","permalink":"https://baiyuan.wang/tags/%E5%9F%9F%E5%90%8D%E7%AE%A1%E7%90%86/"},{"name":"国产系统","slug":"国产系统","permalink":"https://baiyuan.wang/tags/%E5%9B%BD%E4%BA%A7%E7%B3%BB%E7%BB%9F/"},{"name":"bios","slug":"bios","permalink":"https://baiyuan.wang/tags/bios/"},{"name":"电脑故障","slug":"电脑故障","permalink":"https://baiyuan.wang/tags/%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"},{"name":"斯诺登","slug":"斯诺登","permalink":"https://baiyuan.wang/tags/%E6%96%AF%E8%AF%BA%E7%99%BB/"},{"name":"数据结构","slug":"数据结构","permalink":"https://baiyuan.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"QT","slug":"QT","permalink":"https://baiyuan.wang/tags/QT/"},{"name":"FTP","slug":"FTP","permalink":"https://baiyuan.wang/tags/FTP/"},{"name":"栈","slug":"栈","permalink":"https://baiyuan.wang/tags/%E6%A0%88/"}]}