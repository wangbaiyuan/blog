<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王柏元的博客</title>
  
  <subtitle>博学广问，自律静思</subtitle>
  <link href="https://baiyuan.wang/atom.xml" rel="self"/>
  
  <link href="https://baiyuan.wang/"/>
  <updated>2024-03-28T02:24:50.728Z</updated>
  <id>https://baiyuan.wang/</id>
  
  <author>
    <name>Baiyuan Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将Github打造成个人全平台作品的持续发布平台</title>
    <link href="https://baiyuan.wang/build-github-into-a-continuous-publishing-platform-for-personal-full-platform-works.html"/>
    <id>https://baiyuan.wang/build-github-into-a-continuous-publishing-platform-for-personal-full-platform-works.html</id>
    <published>2019-12-25T10:47:51.000Z</published>
    <updated>2024-03-28T02:24:50.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章推荐群体：前端Dev、桌面端Dev、DevOps与Github羊毛党</p></blockquote><p>2016年6月，Github发布了GitHub Pages功能，它允许将静态网页文件存放在github仓库上，并将其发布成web网站。借助Hexo博客框架及其周边丰富、优美的博客主题，可以让程序员使用markdown语法搭建出精美、简洁的博客网站。随后，Github page还支持自定义域名、https… 无需服务器、免费https证书，无需操心运维，一时间，不少博客主纷纷放弃wordpress，转战Github Page。 私以为这可谓广大博客主们“薅github羊毛”的迈出的第一步。</p><blockquote><p>为什么说“薅github羊毛”，是因为我发现越来越多的项目在极致地开发出github的潜能，比如将github gist作为前端应用的存储后端、homebrew还将github作为包发布和审核平台</p></blockquote><p>Github Page已成历史，而今天我这里介绍的除了Github Page，还将介绍如何在Github上<strong>持续发布</strong>个人<strong>全平台</strong>应用作品。</p><ul><li>其中，“持续发布”意味着我将介绍：<ul><li>如何实现作品的多平台自动打包</li><li>如何实现自动发布到github release与github page</li><li>如何自动生成Release Note</li></ul></li><li>而“全平台”包括：<ul><li>Web端</li><li>桌面端（Linux&#x2F;Windows&#x2F;Mac）</li><li>Docker镜像</li></ul></li></ul><p>这意味你开发的个人作品将支持同时发布在以上各操作系统或运行平台上，想起来是不是有点些小激动呢？</p><h2 id="Web端：发布到Github-Page"><a href="#Web端：发布到Github-Page" class="headerlink" title="Web端：发布到Github Page"></a>Web端：发布到Github Page</h2><p>鉴于“怎么在Github上部署自己的网站？怎么绑定自定义域名”可以在Google上搜到成千上万条结果，本博客便不赘述相关细节。在这里主要介绍如何将Github Page的发布过程自动化。 在这之前，我们应该有这样一个基本的共识，Github Page只支持纯前端项目。所以我们这里不妨以<code>React.js</code>项目为例： <code>React.js</code> 采用如下脚本完成打包（包括JS&#x2F;CSS构建、JS混淆minify、HTML模板渲染、manifest清单文件更新等）  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts build&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>  运行<code>yarn build</code>命令后，在build文件夹下将会生成上述构建产物，而使用nginx或者apache这样的HTTP服务器将该目录发布，就可以搭建一个静态网站。 通常情况下，我们常常将github repo的master分支根目录和docs目录作为github的发布目录。<strong>实际上github还支持将“gh-pages”分支作为github page发布分支。</strong> 这里推荐一个npm库<code>gh-pages</code>，它可以将指定目录文件发布到<code>gh-pages</code>分支的npm库，项目主页：<a href="https://github.com/tschaub/gh-pages">https://github.com/tschaub/gh-pages</a> 使用<code>yarn install gh-pages</code> 后在<code>package.json</code>添加发布脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;release:web&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gh-pages -d build&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>运行 <code>yarn release:web</code>即可自动发布。</p><h2 id="桌面端：基于Electron多平台Web-APP"><a href="#桌面端：基于Electron多平台Web-APP" class="headerlink" title="桌面端：基于Electron多平台Web APP"></a>桌面端：基于Electron多平台Web APP</h2><p><a href="https://electronjs.org/">Electron</a>是由Github开发，同时包含Chromium和Node.js运行时环境的跨平台桌面应用平台。它可以打包生成运行在Windows、Mac、Linux等多种操作系统的安装包。常用的Virtual Studio Code、Slack APP就是基于Electron开发。</p><h3 id="实现自动构建多平台版本"><a href="#实现自动构建多平台版本" class="headerlink" title="实现自动构建多平台版本"></a>实现自动构建多平台版本</h3><p>建议采用<a href="https://www.electron.build/">electron-builder</a> npm库打包electron应用</p><p>yarn add -D electron-builder</p><p>打包脚本<code>electron-builder.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">appId:</span> <span class="hljs-string">cn.wangbaiyuan.magpie</span><br><span class="hljs-attr">files:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">build/**/*</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/**/*</span><br><span class="hljs-attr">productName:</span> <span class="hljs-string">Magpie幸运抽奖</span><br><span class="hljs-attr">artifactName:</span> <span class="hljs-string">&#x27;$&#123;name&#125;-$&#123;version&#125;-for-$&#123;os&#125;-$&#123;arch&#125;.$&#123;ext&#125;&#x27;</span><br><span class="hljs-attr">icon:</span> <span class="hljs-string">build/icon.png</span><br><span class="hljs-attr">nsis:</span><br>  <span class="hljs-attr">runAfterFinish:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">deleteAppDataOnUninstall:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">allowToChangeInstallationDirectory:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">oneClick:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">installerLanguages:</span> <span class="hljs-string">zh_CN</span><br>  <span class="hljs-attr">language:</span> <span class="hljs-string">&#x27;2052&#x27;</span><br>  <span class="hljs-attr">perMachine:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">createDesktopShortcut:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">win:</span><br>  <span class="hljs-attr">target:</span> <span class="hljs-string">nsis</span><br><span class="hljs-attr">mac:</span><br>  <span class="hljs-attr">target:</span> <span class="hljs-string">dmg</span><br><span class="hljs-attr">linux:</span><br>  <span class="hljs-attr">target:</span> <span class="hljs-string">deb</span><br></code></pre></td></tr></table></figure><p>electron-builder可以帮助我们完成electron应用的安装包打包，文件名加版本号，以及混淆加密。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Dockerhub除了是一个公用的docker镜像仓库，同时帮助我们在无需CI&#x2F;CD的情况下免费、自动地构建docker镜像，具体可以参考<a href="https://baiyuan.wang/using-dockerhub-continually-build-container-mirroring.html">https://baiyuan.wang/using-dockerhub-continually-build-container-mirroring.html</a></p><ul><li>实现在Github Release时自动构建Docker镜像并推送到Dockerhub</li><li>根据Release版本号给镜像打版本标签、Latest标签</li></ul><h2 id="利用Release-it自动化发布过程"><a href="#利用Release-it自动化发布过程" class="headerlink" title="利用Release-it自动化发布过程"></a>利用Release-it自动化发布过程</h2><p><a href="https://github.com/release-it/release-it">release-it</a> npm库可以实现发布的自动化，实现以下功能</p><ul><li>自动升级package.json版本号</li><li>自动创建Github Release</li><li>上传产出物（Electron APP）</li><li>自动添加Release Note</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hooks:</span><br>  <span class="hljs-attr">after:bump:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">dist</span><br>  <span class="hljs-attr">after:git:release:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">release:web</span><br><br><span class="hljs-attr">git:</span><br>  <span class="hljs-attr">tagName:</span> <span class="hljs-string">v$&#123;version&#125;</span><br><span class="hljs-attr">github:</span><br>  <span class="hljs-attr">release:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">assets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dist/*-mac.zip</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dist/*-win.exe</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dist/*-linux.deb</span><br></code></pre></td></tr></table></figure><p> </p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>更多请参考示例作品：<a href="https://github.com/geekeren/Magpie-LuckyDraw">https://github.com/geekeren/Magpie-LuckyDraw</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章推荐群体：前端Dev、桌面端Dev、DevOps与Github羊毛党&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2016年6月，Github发布了GitHub Pages功能，它允许将静态网页文件存放在github仓库上，并将其发布成web网站</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>NodeJs web项目集成调用链追踪</title>
    <link href="https://baiyuan.wang/nodejs-web%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E8%B0%83%E7%94%A8%E9%93%BE%E8%BF%BD%E8%B8%AA.html"/>
    <id>https://baiyuan.wang/nodejs-web%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E8%B0%83%E7%94%A8%E9%93%BE%E8%BF%BD%E8%B8%AA.html</id>
    <published>2019-12-23T05:11:14.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务架构中，一次用户请求往往调用多个服务，微服务调用链追踪工具可以</p><ul><li>在用户请求发生错误时，帮助我们定位root cause</li><li>在性能优化时提供可观测性指标，找到架构中最耗时的服务和API请求，帮助我们对症下药</li></ul><p>现在的NodeJs web项目比较流行地采用express作为服务器，axios也是一款比较流行的HTTP客户端。微服务的特点之一，自己作为服务端的同时，也为作为客户端访问其它服务。所以集成调用链追踪的关键在于：</p><ul><li>集成server，处理客户端请求。通常会有现成的框架实现了此功能：构造新的，或者从上游的HTTP 请求的header中获取一个包含tracing的结构体（如x-b3-spanid）</li><li>集成client，在发出请求和返回数据时记录请求，zipkin等工具需要知道每个请求的请求时间、返回码、路径等等。</li><li>将server的请求头tracing数据传递到客户端</li></ul><h2 id="传统微服务（非istio）"><a href="#传统微服务（非istio）" class="headerlink" title="传统微服务（非istio）"></a>传统微服务（非istio）</h2><h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><p><a href="https://baiyuan.wang/wp-content/uploads/2019/12/zipkin-architecture.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/12/zipkin-architecture.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Tracer</span>, <span class="hljs-title class_">ExplicitContext</span>, <span class="hljs-title class_">ConsoleRecorder</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zipkin&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; expressMiddleware &#125;= <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zipkin-instrumentation-express&#x27;</span>);<br><span class="hljs-keyword">const</span> recorder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleRecorder</span>();<br><span class="hljs-keyword">const</span> &#123; get &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><br><span class="hljs-keyword">const</span> zipkinTracer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tracer</span>(&#123;<br>  <span class="hljs-attr">ctxImpl</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExplicitContext</span>(),<br>  recorder,<br>  <span class="hljs-attr">localServiceName</span>: <span class="hljs-string">&#x27;&lt;YOUR\_SERVICE\_NAME&gt;&#x27;</span><br>&#125;);<br><span class="hljs-keyword">const</span> zipkinMiddleware = <span class="hljs-title function_">expressMiddleware</span>(&#123; <span class="hljs-attr">tracer</span>: zipkinTracer &#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getTraceIdFromRequest</span> = req =&gt; <span class="hljs-title function_">get</span>(req, <span class="hljs-string">&#x27;\_trace\_id&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isolateZipkinContextByRequest</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  zipkinTracer.<span class="hljs-title function_">scoped</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    zipkinTracer.<span class="hljs-title function_">setId</span>(<span class="hljs-title function_">getTraceIdFromRequest</span>(req));<br>    <span class="hljs-title function_">next</span>();<br>  &#125;);<br>&#125;;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  zipkinTracer,<br>  zipkinMiddleware,<br>  isolateZipkinContextByRequest,<br>&#125;;<br></code></pre></td></tr></table></figure><p> </p><h3 id="express-服务器路由集成zipkin"><a href="#express-服务器路由集成zipkin" class="headerlink" title="express 服务器路由集成zipkin"></a>express 服务器路由集成zipkin</h3><p> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">use</span>(zipkinMiddleware);<br>router.<span class="hljs-title function_">use</span>(isolateZipkinContextByRequest);<br></code></pre></td></tr></table></figure><p>由于nodejs是主线程为单线程的服务器语言，高并发由异步消息队列完成。所以保证从服务器端传递tracing信息和客户端tracing信息在同一个“上下文”，不能简单地采用一个全局变量来保存tracing信息。此处的isolateZipkinContextByRequest至关重要，  </p><h3 id="axios客户端集成zipkin"><a href="#axios客户端集成zipkin" class="headerlink" title="axios客户端集成zipkin"></a>axios客户端集成zipkin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);<br><span class="hljs-keyword">const</span> wrapAxios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zipkin-instrumentation-axiosjs&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Tracer</span>, <span class="hljs-title class_">ExplicitContext</span>, <span class="hljs-title class_">ConsoleRecorder</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zipkin&#x27;</span>);<br><br><span class="hljs-keyword">const</span> ctxImpl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExplicitContext</span>();<br><span class="hljs-keyword">const</span> recorder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleRecorder</span>();<br><span class="hljs-keyword">const</span> localServiceName = <span class="hljs-string">&#x27;service-a&#x27;</span>; <span class="hljs-comment">// name of this application</span><br><span class="hljs-keyword">const</span> tracer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tracer</span>(&#123; ctxImpl, recorder, localServiceName &#125;);<br><br><span class="hljs-keyword">const</span> remoteServiceName = <span class="hljs-string">&#x27;weather-api&#x27;</span>;<br><span class="hljs-keyword">const</span> zipkinAxios = <span class="hljs-title function_">wrapAxios</span>(axios, &#123; tracer, remoteServiceName &#125;);<br><br>zipkinAxios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user?ID=12345&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>  详见：<a href="https://github.com/openzipkin/zipkin-js/tree/master/packages/zipkin-instrumentation-axiosjs">https://github.com/openzipkin/zipkin-js/tree/master/packages/zipkin-instrumentation-axiosjs</a>  </p><h2 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h2><p>相比传统的K8S架构，由于service mesh使用sidecar的方式代理了pod的所有网络请求，构造请求头、和记录请求路径、请求返回码等操作可以在sidebar等istio组件上实现。 所以在istio语境下我们只需要实现HTTP header中的tracing信息从服务端到客户端的传递。同样的原因，nodejs是单线程语言，不能通过一个thread级别隔离的全局变量来保存tracing信息，同时通过层层函数调用栈的方式来传递request的tracing信息则过于麻烦。express库本身没有提供类似于spring或者PHP中的session的会话对象，这里会引入一个“express-http-context”的npm库完成request之间的数据“隔离”。</p><h3 id="获取请求中的tracing-header"><a href="#获取请求中的tracing-header" class="headerlink" title="获取请求中的tracing header"></a>获取请求中的tracing header</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; pick &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-title function_">getForwardHeaders</span>(<span class="hljs-params">req</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">pick</span>(req.<span class="hljs-property">headers</span>,<br>      [<span class="hljs-string">&#x27;x-request-id&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-b3-traceid&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-b3-spanid&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-b3-parentspanid&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-b3-sampled&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-b3-flags&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-ot-span-context&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-datadog-trace-id&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-datadog-parent-id&#x27;</span>,<br>        <span class="hljs-string">&#x27;x-datadog-sampled&#x27;</span><br>      ]<br>    ) || &#123;&#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>express的集成代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; getForwardHeaders &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util/tracer&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> httpContext = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-http-context&#x27;</span>);<br>app.<span class="hljs-title function_">use</span>(httpContext.<span class="hljs-property">middleware</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  httpContext.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;traceHeaders&#x27;</span>, <span class="hljs-title function_">getForwardHeaders</span>(req));<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>client的集成代码：<br><br><span class="hljs-string">``</span><span class="hljs-string">`js</span><br><span class="hljs-string">const axios = require(&#x27;axios&#x27;);</span><br><span class="hljs-string">const httpContext = require(&#x27;express-http-context&#x27;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 关键代码</span><br><span class="hljs-string">config.headers = Object.assign(config.headers || &#123;&#125;, httpContext.get(&#x27;traceHeaders&#x27;));</span><br><span class="hljs-string">axios(config)</span><br><span class="hljs-string">    .then(res =&gt; &#123;</span><br><span class="hljs-string">      //</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">    .catch(err =&gt; &#123;</span><br><span class="hljs-string">     //</span><br><span class="hljs-string">    &#125;)</span><br></code></pre></td></tr></table></figure><p>  参考资料  </p><ul><li>zipkin链路追踪原理：<a href="https://www.cnblogs.com/iiiiiher/p/10256676.html">https://www.cnblogs.com/iiiiiher/p/10256676.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在微服务架构中，一次用户请求往往调用多个服务，微服务调用链追踪工具可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在用户请求发生错误时，帮助我们定位root cause&lt;/li&gt;
&lt;li&gt;在性能优化时提供可观测性指标，找到架构中最耗时的服务和API请求，帮助我们对症下药&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>定期清理虚拟机上的docker资源</title>
    <link href="https://baiyuan.wang/periodically-clean-up-the-docker-resources-on-the-virtual-machine.html"/>
    <id>https://baiyuan.wang/periodically-clean-up-the-docker-resources-on-the-virtual-machine.html</id>
    <published>2019-12-19T02:15:46.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<p>在部署持续集成流水线项目的虚拟机上，随着构建次数的增加，机器上的docker镜像等资源会越来越多，最终将机器占满。本项目是帮助DevOps人员自动清理机器上的docker资源。</p><ul><li>开源项目：<a href="https://github.com/geekeren/docker-cleaner">https://github.com/geekeren/docker-cleaner</a></li></ul><h2 id="定期清理脚本"><a href="#定期清理脚本" class="headerlink" title="定期清理脚本"></a>定期清理脚本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -e<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting an new job to clean Docker...&quot;</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CLEAN\_FILTER:<span class="hljs-variable">$&#123;CLEAN\_FILTER&#125;</span>, CLEAN\_INTERVAL: <span class="hljs-variable">$&#123;CLEAN\_INTERVAL&#125;</span>&quot;</span><br>  docker system prune -a -f --filter <span class="hljs-variable">$&#123;CLEAN_FILTER&#125;</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;All docker images after cleaning are at below:&quot;</span><br>  docker images -a<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Clean Docker job finised, next job will start after <span class="hljs-variable">$&#123;CLEAN_INTERVAL&#125;</span> seconds&quot;</span><br>  <span class="hljs-built_in">sleep</span> <span class="hljs-variable">$CLEAN_INTERVAL</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p> </p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> docker<br><span class="hljs-keyword">ENV</span> CLEAN_INTERVAL=<span class="hljs-number">3600</span><br><span class="hljs-keyword">ENV</span> CLEAN_FILTER=<span class="hljs-string">&quot;until=48h&quot;</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> \[<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;./clean_docker.sh&quot;</span>\]</span><br></code></pre></td></tr></table></figure><p> </p><h2 id="K8S部署"><a href="#K8S部署" class="headerlink" title="K8S部署"></a>K8S部署</h2><p>为什么是K8S部署？理论上K8S部署的服务我们一般不会关心服务的docker镜像会不会把机器占满的问题，那么为什么我还要写K8S部署呢？ 这主要用于 CI Agent跑在K8S上的情况。以微软Azure DevOps K8S Agent为例，<a href="https://github.com/Azure/helm-vsts-agent%EF%BC%8C%E5%85%B6agent%E4%BC%9A%E5%B0%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84docker.sock%E6%8C%82%E8%BD%BD%E5%9C%A8K8S">https://github.com/Azure/helm-vsts-agent，其agent会将宿主机的docker.sock挂载在K8S</a> node上，如果agent存在构建docker镜像的行为，就会导致agent构建出来的docker 镜像已经“脱离”了K8S的控制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">docker-cleaner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">devops</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">docker-cleaner</span><br>  <span class="hljs-attr">updateStrategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">10</span><span class="hljs-string">%</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">docker-cleaner</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">dockersocket</span><br>          <span class="hljs-attr">hostPath:</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/var/run/docker.sock</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-cleaner</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">bywang/docker-cleaner</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CLEAN_INTERVAL</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-number">14400</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">10m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">40Mi</span><br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">dockersocket</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/run/docker.sock</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在部署持续集成流水线项目的虚拟机上，随着构建次数的增加，机器上的docker镜像等资源会越来越多，最终将机器占满。本项目是帮助DevOps人员自动清理机器上的docker资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开源项目：&lt;a href=&quot;https://github.com/ge</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>【开源】Terraform实现在Team中分享Azure订阅</title>
    <link href="https://baiyuan.wang/open-source-terraform-implementation-sharing-azure-subscription-in-team.html"/>
    <id>https://baiyuan.wang/open-source-terraform-implementation-sharing-azure-subscription-in-team.html</id>
    <published>2019-10-25T06:59:22.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<p>假设你属于组织中的某个团队，现在你们只有一份Azure subscription，而你是Azure订阅的所有者。那怎么怎么把一个subscription分享给其它人，同时实现：</p><ul><li>与您的团队共享Azure，每个人都可以在您的订阅中使用Azure资源。</li><li>每个人的环境是隔离的，比如你操作不了或者至少看不见别人创建的资源</li><li>每个人的私有资源组只能由其所有者管理。</li><li>可以与所有团队成员共享一个公共资源组。</li><li>当有人离开团队时，他的资源很容易被销毁避免收费。</li></ul><p>文章 <a href="https://lennilobel.wordpress.com/2018/10/15/adding-a-user-to-your-azure-subscription-with-resource-group-access/">https://lennilobel.wordpress.com/2018/10/15/adding-a-user-to-your-azure-subscription-with-resource-group-access/</a> 介绍了在Azure后台UI上实现这一需求，主要是在Resource Group级别进行了IAM控制。 同时，极客人将其进行了代码化：<a href="https://github.com/tf-module/azure-user-resource-group">https://github.com/tf-module/azure-user-resource-group</a> ，它实现过程如下（详情请移步开源地址）</p><ul><li>创建一个Azure AD用户组，其中包含您的团队成员，也就是你提供的邮件地址</li><li>分别为每个成员创建它以其姓名命名的私人资源组，利用role assignment，将自己配置为私人资源组的owner。</li><li>一个给整个团队共享的公共资源组，每个成员都是其贡献者，利用role assignment，将用户组配置为该资源组的contributor。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设你属于组织中的某个团队，现在你们只有一份Azure subscription，而你是Azure订阅的所有者。那怎么怎么把一个subscription分享给其它人，同时实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与您的团队共享Azure，每个人都可以在您的订阅中使用Azure资源。</summary>
      
    
    
    
    <category term="作品" scheme="https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/"/>
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E4%BD%9C%E5%93%81/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="基础设施" scheme="https://baiyuan.wang/tags/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    
  </entry>
  
  <entry>
    <title>密钥管理：从薪火相传的密钥到“密码即服务”</title>
    <link href="https://baiyuan.wang/key-management-from-the-key-handed-down-from-generation-to-generation-to-password-as-a-service.html"/>
    <id>https://baiyuan.wang/key-management-from-the-key-handed-down-from-generation-to-generation-to-password-as-a-service.html</id>
    <published>2019-10-10T02:49:08.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个可运行的软件项目通常包括两个要素：代码和密钥。我们通常会使用<strong>无版本控制的FTP</strong>和<strong>有版本控制的SVN、git</strong>等成熟的工具进行代码管理；而在我参加的大大小小、许许多多的项目中，密钥管理似乎缺乏成熟或标准的实践。本文将历数一下笔者在各个使用过的密钥管理实践并分析他们的优缺点。最后给大家推荐一款密钥管理工具：vault。</p></blockquote><p>在软件项目开发中，密钥常常应用于下面四个场景：</p><ul><li>本地开发：通常包括开发环境的数据库密码、用于访问第三方API的token、一些私有程序包仓库的凭证等。</li><li>CICD流水线：比如Push Docker镜像的Docker仓库的访问凭证、用于部署的云服务凭证（AWS Secret等）、用于访问K8S集群的token等</li><li>运行线上服务：线上服务启动所需的数据库密码、API Token等等，同时可能需要管理用于多套环境的不同密钥。</li><li>线上运维：线上发生事故时，需要在本地登入堡垒机（跳板机）的SSH Key或集群的访问凭证。</li></ul><h2 id="本地开发：“薪火相传”的密钥文件"><a href="#本地开发：“薪火相传”的密钥文件" class="headerlink" title="本地开发：“薪火相传”的密钥文件"></a>本地开发：“薪火相传”的密钥文件</h2><p>当我们加入一个团队时，通常会有一个Readme文档告诉你项目代码库的下载链接。除此之外它会告诉你需要向团队“前辈”索要密钥文件，不然你的代码是不能在本地启动的。同时有人告诉你，这个密钥文件千万不要加入到git仓库中。 这种“薪火相传”的密钥管理方式，是最原始也是最常见的方式。它常常会伴随这样几个问题：</p><ul><li><strong>密钥更换或者引入新的密钥后，团队其它成员因为没有得到最新的密钥文件，导致服务在本地起不来。</strong></li></ul><p>比如你会听到这样的对话：</p><blockquote><ul><li>A: “我拉了一下最近的代码，怎么就跑不起来了？”</li><li>坐在旁边的B突然想起了什么：“好吧，我想起来了！我改了一下数据库密码，忘记告诉你了，我把最新的密钥发给你。”或者“我新加了一个功能因为使用API-KEY要访问消息队列，我在自己本地的环境变量里面加上了这个KEY，忘记告诉你们了”</li><li>随后B把最新的密钥文件传给了A。几天后，同在项目的C也遇到了同样的问题……</li></ul></blockquote><ul><li><strong>误提交到代码仓库问题：</strong></li></ul><p>相信已经不止一次地听人提醒：<strong>千万不要将密钥文件明文提交到git</strong>。但是密钥泄露在代码仓库的问题依旧时有发生。</p><h2 id="本地开发：将密钥加密后存放在Git仓库"><a href="#本地开发：将密钥加密后存放在Git仓库" class="headerlink" title="本地开发：将密钥加密后存放在Git仓库"></a>本地开发：将密钥加密后存放在Git仓库</h2><p>密钥和代码一样，在团队项目中同样需要进行共享、同步。密钥放在git仓库中本来是可以解决团队协作问题的，只不是不能被明文存储。那么，如果是将密钥加密后再提交到git仓库呢？ git-crypt便是这样一款可将git仓库中的密钥文件进行透明加密和解密的工具。它可以将密钥文件在push时加密，在pull下来后解密。更多介绍和使用说明可以参考：<a href="https://github.com/AGWA/git-crypt">https://github.com/AGWA/git-crypt</a> 借助git版本控制工具，它可以实现：</p><ul><li>使用git进行密码共享</li><li>密钥的版本控制</li><li>用户权限管理</li></ul><p>问题：</p><ul><li>密码可能在多个服务中使用，怎么同步？</li></ul><h2 id="持续集成流水线中的密钥管理"><a href="#持续集成流水线中的密钥管理" class="headerlink" title="持续集成流水线中的密钥管理"></a>持续集成流水线中的密钥管理</h2><p><a href="https://baiyuan.wang/wp-content/uploads/2019/10/Screen-Shot-2019-10-15-at-11.01.32.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/10/Screen-Shot-2019-10-15-at-11.01.32.png"></a></p><p>在现在的Web项目的CI&#x2F;CD流程中，通常会将项目代码经过构建打包生成docker镜像（制品）；在部署阶段，不同环境会<strong>采用相同的docker镜像</strong>，但是会使用<strong>不同的环境变量</strong>（比如集群、域名、数据库地址密码等）传入到docker的运行时，从而完成在不同环境的部署。 环境（变量）在不同的CI&#x2F;CD中有不同形式，比如的Jenkins的Credential、GoCD的Environment、CircleCI的Context。 如果将所有的部署与运行时所需要的密钥数据都保存到pipeline上，会导致下面的问题</p><ul><li>过多的密码字段，将密码作为环境变量一个个传递到服务十分复杂</li><li>pipeline存环境变量一般加密后难以解密，如果你设置完自己都忘记了，那这个环境就彻底忘了</li></ul><p>解决的办法一般是<strong>在pipeline上保存尽量少的密钥字段</strong>，我们通过一次认证就可以具备获取所有密钥数据的权限。</p><h2 id="密码即服务：Hashicorp-Vault"><a href="#密码即服务：Hashicorp-Vault" class="headerlink" title="密码即服务：Hashicorp Vault"></a>密码即服务：Hashicorp Vault</h2><p>在云和基础设施自动化时代，我们应该知道一家名为Hashcorp的公司，其代表作有知名的terraform、consul、packer、vagrant。vault也是这家公司的产品之一，它通过API将密码以服务的方式暴露出去。它可以提供：</p><ul><li>中心化的密码服务</li><li>更安全的加密存储</li><li>密码的服务化</li><li>丰富的第三方集成：实现认证的扩展、多平台密钥管理</li></ul><p><img src="https://baiyuan.wang/wp-content/uploads/2019/10/20191015025844212.jpg" alt="Vault架构"></p><p>服务化后的vault可以做到</p><ul><li>与Github身份认证集成，比如你可以做到只允许在特定git organization下的用户才能获取密钥</li><li>签发临时的SSH证书：比如你只允许一个30分钟内有效的SSH KEY来登录堡垒机</li><li>生成临时的AWS KEY：比如你只能用一个30分钟内有效的AWS凭证</li><li>定期更换数据库密码，因为数据库长期不更换会加大泄露的风险</li><li>OTP：基于时间的临时密码</li><li>密码权限策略：只允许特定的微服务读取或者写入指定的密钥</li><li>密码的revoke（同事下项目了怎么办？）</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>不在本地持久化存储密钥，密钥的只存于当前terminal的环境变量里并随terminal session关闭而销毁</li><li>密钥是有时效性的，定期轮换</li><li>密钥获取者是有身份的，并且有权限控制</li><li>团队成员下项目时，revoke成员的token</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个可运行的软件项目通常包括两个要素：代码和密钥。我们通常会使用&lt;strong&gt;无版本控制的FTP&lt;/strong&gt;和&lt;strong&gt;有版本控制的SVN、git&lt;/strong&gt;等成熟的工具进行代码管理；而在我参加的大大小小、许许多多的项目中，密钥</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="安全" scheme="https://baiyuan.wang/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>敏捷会议中的cycle time</title>
    <link href="https://baiyuan.wang/the-cycle-time-meeting-in-agile-process.html"/>
    <id>https://baiyuan.wang/the-cycle-time-meeting-in-agile-process.html</id>
    <published>2019-08-31T15:28:49.000Z</published>
    <updated>2024-03-28T02:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<p>《人月神话》中提到了软件工程中的Brooks法则：</p><blockquote><p>向进度落后的项目中增加人手，只会使进度更加落后</p></blockquote><p>Brooks法则并不是像数据公式一样有严谨的推理，而且也没有介绍一个解决进度落后、除了增加人手以外还有什么通用方法。</p><p> <a href="https://baiyuan.wang/wp-content/uploads/2019/08/088A6C27-5369-44D9-B5EC-DD9C02251A4E.jpeg"><img src="https://baiyuan.wang/wp-content/uploads/2019/08/088A6C27-5369-44D9-B5EC-DD9C02251A4E.jpeg" alt="人月神话中提到的Brooks法则"></a></p><p>实际上，敏捷会议中有一个叫做Cycle time。Cycle time的初衷应该就是解决这个问题，找出估算和实际时间出入很大的卡，对着这些卡，实际时间花的比估算的多，原因是什么，有什么可以采取的action；花的时间比估算的少，是为什么，有什么可以分享的东西。</p><p>还有一个作用就是让团队知道产生估算有出入的具体细节，做这张卡的人可以做一个澄清，一方面可以寻求团队帮助，另一方面当事人吐槽一下，可能他也很委屈，大家都抱怨这个做慢了，却不晓得是因为我趟了好多坑，这些坑是之前没遇到的；或者是之前估卡的scope变大了。</p><p>没有银弹，许多事情都需要case by case地进行分析，而Cycle time就是提供这种流程的实践，帮助团队发现估算有出入问题的原因。一切敏捷流程都是为了尽早暴露问题、增加沟通和加速反馈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《人月神话》中提到了软件工程中的Brooks法则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;向进度落后的项目中增加人手，只会使进度更加落后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Brooks法则并不是像数据公式一样有严谨的推理，而且也没有介绍一个解决进度落后、除了增加人</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="业界" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E4%B8%9A%E7%95%8C/"/>
    
    
    <category term="敏捷" scheme="https://baiyuan.wang/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>【随笔】中台服务，谁为你的服务买单</title>
    <link href="https://baiyuan.wang/who-pays-for-your-service.html"/>
    <id>https://baiyuan.wang/who-pays-for-your-service.html</id>
    <published>2019-06-19T12:28:01.000Z</published>
    <updated>2024-03-28T02:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大概过程与技术原理"><a href="#大概过程与技术原理" class="headerlink" title="大概过程与技术原理"></a>大概过程与技术原理</h2><p>脑洞一下：中台以后各个部门的数据以微服务API形式放在API store里面供其它部分消费，为了避免部门打架、中台成本谁来出、费用怎么收的问题。在想能不能基于istio开发为请求计费的插件（计费链），技术实现的大概思路就是就是像zipkin每个调用单元（span）加一个价格，一次API的价格等于调用链路中所有单元（span）价格的求和。</p><p><a href="https://baiyuan.wang/wp-content/uploads/2019/06/timg-2.jpeg"><img src="https://baiyuan.wang/wp-content/uploads/2019/06/timg-2.jpeg"></a> 最后的大概可视化效果就是这张图的时间ms，换成人民币单位（估计不要一分钱）</p><p>比如调用一次A服务某API价格为a，一次B服务某API价格为b，调一次C服务需要调A和B，那么C调用费用就是a + b + c。其中C分别要给别的服务a和b的费用，c是给自己的。上面为了介绍思想，这里只是做一个简单的求和，其实也许我们可以做更复杂的方案。就像卖商品一样卖自己的API请求。</p><p>比如每个服务可以这样定价：</p><ul><li>基于硬件资源：数据查询次数、CPU、内存</li><li>数据价值人为定价</li><li>以上的综合</li></ul><p>以上可称为<strong>API as Product, Data as Product</strong>的按量收费方案。</p><h2 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h2><ul><li>第一个上面所说的<strong>平台服务谁来买单</strong>的问题，<strong>实际调用者买单，价格为调用单元的费用总和。</strong></li><li>API请求的定价问题，更科学的定价方案，单纯按照API请求数，<strong>忽略了不同请求之间可能耗费硬件资源、业务逻辑复杂度的差异</strong></li><li>衍生到数据部门，解决<strong>数据到底值多少钱的问题</strong></li><li>收费限制了其它消费者<strong>恶意调用</strong>的问题，让他们在消费其它第三方数据服务时<strong>考虑消费成本，让他们更加节约</strong>。对于复杂度较高、数据价值较大的API提高价格，利用<strong>市场化手段</strong>将API或数据作为产品来管理API。服务提供者可以通过抬价方式限制访问，通过降价方式促销自己的数据。</li></ul><h2 id="为什么聊到istio"><a href="#为什么聊到istio" class="headerlink" title="为什么聊到istio"></a>为什么聊到istio</h2><ul><li>istio实现了网络流量的透明代理，对其它服务没有倾入性，新建一个独立的中心服务，不用修改其它服务代码；</li><li>不用其它服务去配合一个一个在header里面加traceId，parentId，其一是麻烦，需要一个人员去协调那么多微服务团队<strong>增加组织协调成本</strong>；<strong>主要是你觉得别人会配合</strong>？我加上这玩意意味着你就要像我收费，我凭啥配合你加？也防止服务使用什么黑科技逃避收费。</li><li>中心化控制公平公道可仲裁，价格在一个地方，一目了然，API商店里面一个个API明码标价。</li></ul><p> </p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p> </p><ul><li>API Gateway可以计费啊？为什么还需要这个</li></ul><blockquote><p>不是从基础架构方面计费，按业务价值；中台没有业务价值，怎么给它定义价值，而且做到每一个API请求他的价格不一样，不是简单地按调多少次来收费；</p><p>每一次API请求需要多少钱，是它自己本身花费的费用，加上它调用其它一些服务的成本</p></blockquote><ul><li>收费模式？</li></ul><blockquote><p>比如服务A定价取一次user信息2分钱，服务B定价取一次商品信息3分钱），订单服务C调了一次user和商品，就要分别给A和B付2分钱和3分钱，然后D调C，可能它要花8分钱，然后它想知道为什么要花8分钱，于是点开调用链可以看到收费清单，上面明明白白地告诉它8毛钱花在哪里，分别给哪些服务付了多少钱。</p></blockquote><ul><li>一个公司内部的，有必要算的这么细吗？</li></ul><blockquote><p>有必要。 第一点，我在公司内部运营部门呆过，因为免费，发现做的API各种被调，不被限制地被调。通过只是想通过收费手段来降低API的调用压力。也有些API服务可以机械性地限流，调用多少次限流，而这种模式是市场化调节。收费高你自然谨慎地调。 第二点，公司高层往往觉得公司的运营部门是一个纯成本消耗的部门，很难去衡量一个内部部门的价值。通过这种方式，可以让高层知道每个部门掌握的业务数据到底值多少钱。为其对内部部门的投资决策提供参考。</p><p>第三点，其实在一个公司里面，内部还是各种算账啊，不展开赘述。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大概过程与技术原理&quot;&gt;&lt;a href=&quot;#大概过程与技术原理&quot; class=&quot;headerlink&quot; title=&quot;大概过程与技术原理&quot;&gt;&lt;/a&gt;大概过程与技术原理&lt;/h2&gt;&lt;p&gt;脑洞一下：中台以后各个部门的数据以微服务API形式放在API store里面供其它部</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="极客视点" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>怎样让你的个人项目看起来更专业</title>
    <link href="https://baiyuan.wang/how-to-make-your-personal-project-look-more-professional.html"/>
    <id>https://baiyuan.wang/how-to-make-your-personal-project-look-more-professional.html</id>
    <published>2019-06-15T05:41:31.000Z</published>
    <updated>2024-03-28T02:24:50.728Z</updated>
    
    <content type="html"><![CDATA[<p> </p><h2 id="Readme文档"><a href="#Readme文档" class="headerlink" title="Readme文档"></a>Readme文档</h2><p><a href="https://baiyuan.wang/wp-content/uploads/2019/06/WechatIMG385.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/06/WechatIMG385.png"></a></p><ul><li>包含使用方法、操作步骤和预览图、在线预览链接</li><li>在标题下面各种标签的徽章</li></ul><h2 id="使用敏捷看板"><a href="#使用敏捷看板" class="headerlink" title="使用敏捷看板"></a>使用敏捷看板</h2><p><img src="https://baiyuan.wang/wp-content/uploads/2019/06/20190615053949311.jpg" alt="使用敏捷看板"></p><ul><li>Github自带的敏捷开发看板工具</li><li>让项目有条不紊，优先级管理</li><li>给Story Card打上标签和milestone</li></ul><h2 id="一键自动化的Release"><a href="#一键自动化的Release" class="headerlink" title="一键自动化的Release"></a>一键自动化的Release</h2><p><img src="https://baiyuan.wang/wp-content/uploads/2019/06/20190615053950412.jpg" alt="一键自动化的Release"></p><ul><li>Windows&#x2F;Linux&#x2F;Mac全平台支持</li><li>使用release-it工具一键自动化发布并生成Release Note 添加产出物Assets</li></ul><h2 id="Docker镜像自动构建和自动打标签"><a href="#Docker镜像自动构建和自动打标签" class="headerlink" title="Docker镜像自动构建和自动打标签"></a>Docker镜像自动构建和自动打标签</h2><p><img src="https://baiyuan.wang/wp-content/uploads/2019/06/20190615053951519.jpg" alt="在Github发布后自动触发dockerhub的镜像构建"></p><h2 id="OSchinak开源软件主页"><a href="#OSchinak开源软件主页" class="headerlink" title="OSchinak开源软件主页"></a>OSchinak开源软件主页</h2><p><img src="https://baiyuan.wang/wp-content/uploads/2019/06/20190615053952619.jpg"></p><p> </p><ul><li>项目地址：<a href="https://github.com/geekeren/Magpie-LuckyDraw">https://github.com/geekeren/Magpie-LuckyDraw</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&quot;Readme文档&quot;&gt;&lt;a href=&quot;#Readme文档&quot; class=&quot;headerlink&quot; title=&quot;Readme文档&quot;&gt;&lt;/a&gt;Readme文档&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://baiyuan.wang/wp-cont</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>中美贸易战对软件行业有什么影响的几个观点</title>
    <link href="https://baiyuan.wang/several-views-on-impact-of-sino-us-trade-war-on-software-industry.html"/>
    <id>https://baiyuan.wang/several-views-on-impact-of-sino-us-trade-war-on-software-industry.html</id>
    <published>2019-05-25T13:34:55.000Z</published>
    <updated>2024-03-28T02:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件授权被禁，国内的市场就大了：用不了国外的，就会自己做，对于中国是机会也是挑战</p></blockquote><blockquote><p>程序员的岗位就多了，中国盗版用习惯了，要是都用正版，愿意为软件付钱，然后又买国产软件，需求就多了，市场就大了，就能让程序员多吃几年饭；现在拿来主义惯了，就不用这个程序员来做，不仅操作系统，像PS MATLAB 这种东西中国都缺啊。</p></blockquote><p> </p><blockquote><p>现在音乐都规范版权了，如果软件方面也规范版权了，就要花钱买，有人买就要人去开发卖，外国的太贵了，中国就可以开发个便宜点的。反正中国市场那么大，便宜点也有钱赚；而要开发这些东西，就要程序员，就业就好了</p></blockquote><p> </p><blockquote><p>现在的中国的软件行业都窝在互联网，一个个产品都做死了，来来回回就那么些东西，哪个火就搞哪个。不管做啥BAT都要搞啥，小厂搞出来，BAT跟着搞就把他灭了；中国软件行业这几年钱全放在互联网，哪像中国全是BAT在玩，而且玩的也是上层应用，搞个UI啥的，技术含量不足</p></blockquote><p> </p><blockquote><p>美国真正厉害的是即使是软件这一块，各个领域都很牛逼，各种小公司都是世界顶尖的，旧金山随便抓一个公司都是世界顶级的；公司之前互相付license费用，做的好，一小块领域就可以让自己活下来了；在中国没有看到这种技术上的商业生态</p></blockquote><p> </p><blockquote><p>小公司活的好，国家就业也就会好；毕竟BAT员工数量对于整个行业还是少部分，众多的小企业都能活下来带来都的是更多的就业数量；中国那么大市场，市场就是资源，做好一小块就可以活的够好，可惜资源都是大厂被把持住</p></blockquote><p> </p><blockquote><p>中国科技是缺乏自驱力的，而从来都是自上向下的号召和政府的引导。在政府关注的领域，我相信这个领域一定能发展的好，比如航天、高铁。现在开始关注操作系统和芯片了，我相信也能发展得好，那么其他领域呢？很难看到百花齐放的氛围，这缺乏行业自己来推动技术发展的自驱力，我一直认为创新来自于自己的自驱力而是上面的压力和重视（就像好的学生是自己想学习，而不是应付老师检查作业或者应付考试）。像旧金山随便找一个公司都是世界顶尖的事情在中国还没有看到曙光。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;软件授权被禁，国内的市场就大了：用不了国外的，就会自己做，对于中国是机会也是挑战&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;程序员的岗位就多了，中国盗版用习惯了，要是都用正版，愿意为软件付钱，然后又买国产软件，需求就多了，</summary>
      
    
    
    
    <category term="极客视点" scheme="https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>新建NodeJS Web服务的几个最佳实践</title>
    <link href="https://baiyuan.wang/best-practices-when-creating-node-js-web-service.html"/>
    <id>https://baiyuan.wang/best-practices-when-creating-node-js-web-service.html</id>
    <published>2019-05-16T04:28:32.000Z</published>
    <updated>2024-03-28T02:24:50.728Z</updated>
    
    <content type="html"><![CDATA[<p>在项目建立初期引入一些最佳实践可以避免后期大量复杂的重构工作，本文总结了在使用Node JS构建Web服务时的一些最佳实践，同时涉及的具体的操作步骤。</p><h2 id="一、使用初始化脚手架"><a href="#一、使用初始化脚手架" class="headerlink" title="一、使用初始化脚手架"></a>一、使用初始化脚手架</h2><p>所谓脚手架，就是在初始化代码库时，脚手架可以帮助自动生成一些代码和项目结构，注入一些框架。对于一个NodeJS项目，不需要我们从npm init初始化起，自己一步步安装一些依赖。</p><h3 id="Express命令"><a href="#Express命令" class="headerlink" title="Express命令"></a>Express命令</h3><p>Express是目前最流行的NodeJS web框架。全局安装一个express-generator，用来初始化express项目。</p><ul><li><p>全局安装命令：<code>npm install express-generator -g</code></p></li><li><p>新建一个名为<strong>hello-express</strong>项目: <code>express hello-express</code></p><p><a href="https://baiyuan.wang/wp-content/uploads/2019/05/Screen-Shot-2019-05-16-at-12.42.38.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/05/Screen-Shot-2019-05-16-at-12.42.38.png" alt="使用脚手架初始化Express项目"></a> 使用脚手架初始化Express项目</p></li></ul><h3 id="使用Swagger脚手架"><a href="#使用Swagger脚手架" class="headerlink" title="使用Swagger脚手架"></a>使用Swagger脚手架</h3><p>当使用NodeJS 开发Web API时，强烈建议使用<a href="https://links.jianshu.com/go?to=https://swagger.io">Swagger</a>进行API构建与管理，以及提供API文档服务。全局安装swagger命令也可以实现初始化一个swagger项目。swagger命令可以让你在浏览器上实时直接编辑你的API定义和调试API。</p><h4 id="初始化swagger项目"><a href="#初始化swagger项目" class="headerlink" title="初始化swagger项目"></a>初始化swagger项目</h4><ul><li>安装命令：<code>npm install swagger -g</code></li><li>新建Swagger API项目：<code>swagger project create hello-swagger</code>，在这过程中会让你选择使用哪种Web服务器，当选择express时就可以自动引入express框架</li><li>项目结构：</li></ul><p>.<br>├── README.md<br>├── api<br>│   ├── controllers<br>│   │   ├── README.md<br>│   │   └── hello_world.js<br>│   ├── helpers<br>│   │   └── README.md<br>│   ├── mocks<br>│   │   └── README.md<br>│   └── swagger<br>│       └── swagger.yaml<br>├── app.js<br>├── config<br>│   ├── README.md<br>│   └── default.yaml<br>├── package-lock.json<br>├── package.json<br>└── test<br>    └── api<br>        ├── controllers<br>        │   ├── README.md<br>        │   └── hello_world.js<br>        └── helpers<br>            └── README.md</p><p> </p><h4 id="实时编辑和语法校验"><a href="#实时编辑和语法校验" class="headerlink" title="实时编辑和语法校验"></a>实时编辑和语法校验</h4><ul><li>启动在线编辑：<code>swagger project edit</code>, 此时会打开系统浏览器，在浏览器中可以直接编辑swagger文档，并进行实时语法检查，同时浏览器里面的编辑变更会回写到代码。</li></ul><p><img src="https://baiyuan.wang/wp-content/uploads/2019/05/20190516042224214.jpg"></p><p>Swagger实时编辑和语法校验</p><h4 id="在线调试API"><a href="#在线调试API" class="headerlink" title="在线调试API"></a>在线调试API</h4><p>上图右侧部分，就是类似于 <code>postman</code>的API调试工具。</p><h2 id="二、Swagger文档服务"><a href="#二、Swagger文档服务" class="headerlink" title="二、Swagger文档服务"></a>二、Swagger文档服务</h2><p>Swagger是一个最流行的的API构建与管理工具，在各种语言和框架都有相应的库可以支持，同时安装swagger-ui扩展进行API文档管理和在线调试。 其遵循<a href="https://links.jianshu.com/go?to=https://swagger.io/blog/api-strategy/difference-between-swagger-and-openapi/">OpenAPI标准</a>，OpenAPI定义了诸如路由转发、参数定义与校验等一整套API规范。</p><ul><li>OpenAPI规范文档：<a href="https://links.jianshu.com/go?to=https://swagger.io/specification/">https://swagger.io/specification/</a></li><li>在线API编辑器预览：<a href="https://links.jianshu.com/go?to=https://editor.swagger.io/">https://editor.swagger.io</a></li></ul><h3 id="发布swagger文档"><a href="#发布swagger文档" class="headerlink" title="发布swagger文档"></a>发布swagger文档</h3><p>上面的swagger命令适合在本地编辑、调试使用，当在产品（Production）环境发布文档服务时，适合引入 swagger UI 中间件</p><p>app.use(SwaggerUi(swaggerExpress.runner.swagger));</p><p>访问<a href="https://links.jianshu.com/go?to=http://localhost:10010/docs/%23/">http://localhost:10010/docs/#/</a>即可查看API文档：</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/05/20190516042224316.jpg"></p><p>Swagger UI</p><ul><li><p>在线预览：<a href="https://links.jianshu.com/go?to=https://petstore.swagger.io/">https://petstore.swagger.io/</a></p></li><li><p>完整代码如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stata">SwaggerExpress.create(config, function (<span class="hljs-keyword">err</span>, swaggerExpress) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) &#123;<br>    throw <span class="hljs-keyword">err</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// install middleware</span><br>  <span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(SwaggerUi(swaggerExpress.runner.swagger));<br>  swaggerExpress.register(<span class="hljs-keyword">app</span>);<br><br>  <span class="hljs-keyword">const</span> port = 10010;<br>  <span class="hljs-keyword">app</span>.listen(port);<br><br>  <span class="hljs-keyword">if</span> (swaggerExpress.runner.swagger.paths\[&#x27;/hello&#x27;\]) &#123;<br>    console.<span class="hljs-built_in">log</span>(&#x27;try this:\\ncurl http:<span class="hljs-comment">//127.0.0.1:&#x27; + port + &#x27;/hello?name=Scott&#x27;);</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p> </p><h2 id="三、启用ES6-JS语法"><a href="#三、启用ES6-JS语法" class="headerlink" title="三、启用ES6 JS语法"></a>三、启用ES6 JS语法</h2><p>ECMAScript 是 JS 的语言标准，ES6是新的JS语法标准。在没有其它配置的情况下使用ES6语法会出现一下错误。我们需要引入babel做语法转换。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> SwaggerExpress <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;swagger-express-mw&#x27;</span>;<br>       ^^^^^^^^^^^^^^<br><br>SyntaxError: Unexpected identifier<br>    at Module._compile (<span class="hljs-type">internal</span>/modules/cjs/loader.js:<span class="hljs-number">760</span>:<span class="hljs-number">23</span>)<br>    at <span class="hljs-keyword">Object</span>.Module._extensions..js (<span class="hljs-type">internal</span>/modules/cjs/loader.js:<span class="hljs-number">827</span>:<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="什么是babel"><a href="#什么是babel" class="headerlink" title="什么是babel"></a>什么是babel</h3><p>Babel 是一个 JavaScript 编译器，工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。更多文档可参考：<a href="https://links.jianshu.com/go?to=https://www.babeljs.cn/docs/">https://www.babeljs.cn/docs/</a></p><h3 id="如何配置？"><a href="#如何配置？" class="headerlink" title="如何配置？"></a>如何配置？</h3><ul><li><p>安装依赖：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -D @babel/core @babel/cli @babel/preset-env @babel/node<br></code></pre></td></tr></table></figure></li><li><p>在根目录创建.babelrc文件，内容如下</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> \<span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span>\<span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>使用babel-node命令代替node<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run prod&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node ./app.js&quot;</span>  <span class="hljs-comment">// -&gt; &quot;babel-node ./app.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="如何处理已有的非ES6项目？"><a href="#如何处理已有的非ES6项目？" class="headerlink" title="如何处理已有的非ES6项目？"></a>如何处理已有的非ES6项目？</h3><ul><li>安装一个npm module <code>cjs-to-es6</code> 可以做一些简单的ES6语法转化：<code>npm install -g cjs-to-es6</code></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://links.jianshu.com/go?to=https://www.babeljs.cn/docs/">https://www.babeljs.cn/docs/</a></li><li>How to enable ES6 (and beyond) syntax with Node and Express：<a href="https://links.jianshu.com/go?to=https://medium.freecodecamp.org/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab">https://medium.freecodecamp.org/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab</a></li></ul><h2 id="四、文件变动监听并自动重启服务"><a href="#四、文件变动监听并自动重启服务" class="headerlink" title="四、文件变动监听并自动重启服务"></a>四、文件变动监听并自动重启服务</h2><p>每次修改代码时我们需要重启Express来查看效果，<code>nodemon</code>可以在指定的文件发生修改后，帮助我们自动重启服务，提高开发效率。</p><ul><li>安装nodemon：<code>npm i -D nodemon</code></li><li>在根目录添加配置文件nodemon.json：</li></ul><p>{<br>  “exec”: “npm run dev”,<br>  “watch”: [“src&#x2F;<em>“, “public&#x2F;</em>“],<br>  “ext”: “js, html, css, json”<br>}</p><p> </p><ul><li>参考文档可以更多配置：<a href="https://links.jianshu.com/go?to=https://github.com/remy/nodemon%23nodemon">https://github.com/remy/nodemon#nodemon</a></li></ul><h2 id="五、使用ES-Lint做代码风格扫描"><a href="#五、使用ES-Lint做代码风格扫描" class="headerlink" title="五、使用ES Lint做代码风格扫描"></a>五、使用ES Lint做代码风格扫描</h2><p>ES Lint是一款代码风格扫描工具，尤其是在团队开发时可以帮助我们规范我们的代码风格，并提供与IDE的集成做到代码纠错。</p><ul><li>安装eslint <code>npm i -D eslint</code></li><li>参考文档：<a href="https://links.jianshu.com/go?to=https://eslint.org/docs/user-guide/getting-started">https://eslint.org/docs/user-guide/getting-started</a></li></ul><h2 id="六、在代码提交时触发指定操作"><a href="#六、在代码提交时触发指定操作" class="headerlink" title="六、在代码提交时触发指定操作"></a>六、在代码提交时触发指定操作</h2><p>常常有这样的场景，持续集成要求我们在提交代码之前测试在本地是可以通过的。这个时候我们可以在注册“钩子”的方式，在代码提交之前在本地运行测试，如果测试不通过则不允许提交。那么使用<code>husky</code>可以这一需求：</p><ul><li>husky文档：<a href="https://links.jianshu.com/go?to=https://github.com/typicode/husky%23readme">https://github.com/typicode/husky#readme</a></li></ul><h3 id="例子1：-在git-push-之前运行测试"><a href="#例子1：-在git-push-之前运行测试" class="headerlink" title="例子1： 在git push 之前运行测试"></a>例子1： 在git push 之前运行测试</h3><p>“husky”: {<br>    “hooks”: {<br>      “pre-push”: “npm run coverage &amp;&amp; npm run pact:test”<br>    }<br>  },</p><h3 id="例子2：-在git-commit-之前运行代码风格检查和自动纠正"><a href="#例子2：-在git-commit-之前运行代码风格检查和自动纠正" class="headerlink" title="例子2： 在git commit 之前运行代码风格检查和自动纠正"></a>例子2： 在git commit 之前运行代码风格检查和自动纠正</h3><p>“husky”: {<br>    “hooks”: {<br>      “pre-commit”: “npm lint”<br>    }<br>  },</p><p> </p><h2 id="七、开启Gzip压缩提高服务响应速度"><a href="#七、开启Gzip压缩提高服务响应速度" class="headerlink" title="七、开启Gzip压缩提高服务响应速度"></a>七、开启Gzip压缩提高服务响应速度</h2><p>开启gzip压缩可以显著提高HTTP的服务的访问速度，安装<code>compression</code>中间件可以非常方便地启用：</p><p>import compression from ‘compression’;<br>…<br>app.use(compression());</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在项目建立初期引入一些最佳实践可以避免后期大量复杂的重构工作，本文总结了在使用Node JS构建Web服务时的一些最佳实践，同时涉及的具体的操作步骤。&lt;/p&gt;
&lt;h2 id=&quot;一、使用初始化脚手架&quot;&gt;&lt;a href=&quot;#一、使用初始化脚手架&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="DevOps" scheme="https://baiyuan.wang/tags/DevOps/"/>
    
    <category term="Node.JS" scheme="https://baiyuan.wang/tags/Node-JS/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架下异步日志收集及验证是否生效</title>
    <link href="https://baiyuan.wang/verify-effectiveness-of-asynchronous-log-collection-under-spring-framework.html"/>
    <id>https://baiyuan.wang/verify-effectiveness-of-asynchronous-log-collection-under-spring-framework.html</id>
    <published>2019-05-15T09:04:20.000Z</published>
    <updated>2024-03-28T02:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Logback-AsyncAppender"><a href="#Logback-AsyncAppender" class="headerlink" title="Logback+AsyncAppender"></a>Logback+AsyncAppender</h2><p>logback的介绍. Logback是由log4j创始人设计的另一个开源日志组件。 为了避免日志记录会给服务带来性能问题，在项目中决定采用“异步记录日志”进行记录。这里就要使用到<strong>Logback的AsyncAppender组件</strong>。简而言之，就是AsyncAppender会在请求处理的主线程以外<strong>新建一个子线程 -“日志记录线程</strong>”进行日志输出。<strong>避免日志输出造成主线程阻塞</strong>。 在运行过程中，主线程不会直接输出日志，而是将<strong>日志以Event的方式发给日志线程</strong>，Event在日志线程中会形成一条队列。而AsyncAppender的配置项很多都是对队列的配置，比如：</p><ul><li>queueSize int BlockingQueue的最大容量，默认情况下，大小为256。</li><li>discardingThreshold int 默认情况下，当BlockingQueue还有20%容量，他将丢弃TRACE、DEBUG和INFO级别的event，只保留WARN和ERROR级别的event。为了保持所有的events，设置该值为0。</li><li>includeCallerData boolean 提取调用者数据的代价是相当昂贵的。为了提升性能，默认情况下，当event被加入到queue时，event关联的调用者数据不会被提取。默认情况下，只有”cheap”的数据，如线程名。</li></ul><p>需要注意到点：</p><ul><li>AsyncAppender只是实现将日志事件缓存到队列，具体怎么输出日志需要在 <appender-ref ref="xxxx"/>中实现，完整代码如下：</li></ul><?xml version="1.0" encoding="UTF-8"?><configuration>    <springProperty scope="context" name="appName" source="spring.application.name"/>    <shutdownHook class="ch.qos.logback.core.hook.DelayingShutdownHook"/>    <appender name="JSON" class="ch.qos.logback.core.ConsoleAppender">        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">            <level>info</level>        </filter>        <encoder class="net.logstash.logback.encoder.LogstashEncoder">            <customFields>{"service":"${appName}"}</customFields>        </encoder>    </appender>    <appender name="ASYNC\_CONSOLE\_JSON" class="ch.qos.logback.classic.AsyncAppender">        <neverBlock>true</neverBlock>        <discardingThreshold>0</discardingThreshold>        <queueSize>1000</queueSize>        <appender-ref ref="JSON"/>    </appender>    <root level="info">        <appender-ref ref="ASYNC\_CONSOLE\_JSON"/>    </root></configuration><h2 id="Shutdown-hook"><a href="#Shutdown-hook" class="headerlink" title="Shutdown hook"></a>Shutdown hook</h2><p>为了在JVM虚拟机退出之前，能将日志线程的队列中的日志处理完毕，需要注册一个<strong>shutdown hook</strong> 详见： <a href="https://logback.qos.ch/manual/appenders.html#AsyncAppender">https://logback.qos.ch/manual/appenders.html#AsyncAppender</a></p><h2 id="怎样验证异步日志收集是否生效"><a href="#怎样验证异步日志收集是否生效" class="headerlink" title="怎样验证异步日志收集是否生效"></a>怎样验证异步日志收集是否生效</h2><p>按照Logback的文档实现异步日志很简单，那么怎么验证异步日志有没有生效就是个问题。这里引入一个“<strong>VisualVM</strong>”工具，它可以列出一个Java进程所包含的线程。可以看到下面的AsyncAppender-Works-xxx就是日志收集线程。 <a href="https://baiyuan.wang/wp-content/uploads/2019/05/WechatIMG371.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/05/WechatIMG371.png"></a></p><h2 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h2><ul><li>Java日志框架：logback详解：<a href="https://www.cnblogs.com/xrq730/p/8628945.html">https://www.cnblogs.com/xrq730/p/8628945.html</a></li><li>Logback AsyncAppender 示例：<a href="https://examples.javacodegeeks.com/enterprise-java/logback/logback-ayncappender-example/">https://examples.javacodegeeks.com/enterprise-java/logback/logback-ayncappender-example/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Logback-AsyncAppender&quot;&gt;&lt;a href=&quot;#Logback-AsyncAppender&quot; class=&quot;headerlink&quot; title=&quot;Logback+AsyncAppender&quot;&gt;&lt;/a&gt;Logback+AsyncAppender&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JAVA" scheme="https://baiyuan.wang/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://baiyuan.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Nginx在网站改版中实现金丝雀发布</title>
    <link href="https://baiyuan.wang/nginxs-implementation-of-canary-release-in-website-revision.html"/>
    <id>https://baiyuan.wang/nginxs-implementation-of-canary-release-in-website-revision.html</id>
    <published>2019-04-23T13:07:32.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<p>在网站改版中我们希望选取部分用户进行金丝雀发布来给自己的新网站做“试点”，在确认新网站使用没有问题后，会慢慢加大新网站“试点”的比重，从而用到“金丝雀发布”。 “金丝雀发布”这一典故来源于采煤行业，据说以前矿工挖煤的时候，矿工下矿井前会先把金丝雀放进去，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。 矿工们用金丝雀对矿井进行空气测试的道理没沿用到软件行业。当我们要发布应用的新版本时，我们通常只会将部分流量切到新版本，当测试新版本应用没有问题时，再慢慢加大切向新版本流量的比例，这种发布方式被称为“金丝雀发布”。 那么，我们可以怎样实现金丝雀发布呢？ 在不涉及istio的情况下，我们一般会采用Nginx反向代理服务器来实现这种流量切分，通过编写nginx.conf规则来实现。 </p><p><a href="https://baiyuan.wang/wp-content/uploads/2019/10/baiyuan.wang_2019-10-23_13-25-07.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/10/baiyuan.wang_2019-10-23_13-25-07.png" alt="Nginx实现金丝雀发布"></a></p><h2 id="方法一：没有“记忆”的随机流量切分"><a href="#方法一：没有“记忆”的随机流量切分" class="headerlink" title="方法一：没有“记忆”的随机流量切分"></a>方法一：没有“记忆”的随机流量切分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx.config">http &#123;<br>upstream service &#123;<br>    server &#123;new-website-url&#125; weight=10;<br>    server &#123;old-website-url&#125; weight=90;<br>&#125;<br>server &#123;<br>    listen       80;<br>    server_name  baiyuan.wang;<br>    location / &#123;<br>        proxy_pass http://service;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式常常用于配置nginx作为负载均衡时，可以控制流量导向不同应用服务器的比重，当然也可以通过用于新旧版本的流量切分。但这种方式的一个问题是用户在多次请求时，被导向的页面是随机的。比如反复刷新浏览器，有时被导向新版网站，有时被导向旧的，这显然不是我们希望发生的。</p><h2 id="方法二：有“记忆”的流量切分"><a href="#方法二：有“记忆”的流量切分" class="headerlink" title="方法二：有“记忆”的流量切分"></a>方法二：有“记忆”的流量切分</h2><p>所以我们希望服务能“记住”每个用户第一次访问的版本，后续的请求依旧导向到改版本。而HTTP请求是无状态的，即每个HTTP请求实际上是独立的，而不是和用户建立一个长久的会话。我们只有设置里一个“特定的标记”，服务器才能知道你是不是同一个用户，所以我们需要使用cookie来标记用户。使用cookie而不是localstorage的原因是cookie是每次都会被浏览器发往服务器端。 这里，我们使用cookie来记录用户第一次访问的版本。后续访问时读取该cookie字段来控制nginx的转发行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nginx.config">http &#123;<br><br>    split\_clients &quot;$&#123;http\_user\_agent&#125;$&#123;date\_gmt&#125;&quot; $app_version &#123;<br>        10%     new;<br>        90%     old;<br>    &#125;<br><br>    map $cookie\_split\_version $upstream_group &#123;<br>        default $app_version;<br>        &quot;old&quot; &quot;old&quot;;<br>        &quot;new&quot; &quot;new&quot;;<br>    &#125;<br><br>    location = / &#123;<br>        add\_header Set-Cookie &quot;split\_version=$upstream_group;Path=/;Max-Age=21600;&quot;;<br><br>        if ($upstream_group = &quot;old&quot;) &#123;<br>            proxy\_pass https://$old\_url;<br>            break;<br>        &#125;<br>        if ($upstream_group = &quot;new&quot;) &#123;<br>            proxy\_pass https://$new\_url;<br>            break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在网站改版中我们希望选取部分用户进行金丝雀发布来给自己的新网站做“试点”，在确认新网站使用没有问题后，会慢慢加大新网站“试点”的比重，从而用到“金丝雀发布”。 “金丝雀发布”这一典故来源于采煤行业，据说以前矿工挖煤的时候，矿工下矿井前会先把金丝雀放进去，或者挖煤的时候一直带</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="运维" scheme="https://baiyuan.wang/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>保护日志中的用户隐私数据</title>
    <link href="https://baiyuan.wang/protecting-user-privacy-data-in-logs.html"/>
    <id>https://baiyuan.wang/protecting-user-privacy-data-in-logs.html</id>
    <published>2019-04-14T13:42:03.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019年度“315”晚会人工智能拨打骚扰电话的情节，让大众了解到在信息时代，保护个人隐私的重要性。本篇文章分享了在日志记录中保护用户隐私数据的七个最佳实践。</p></blockquote><p>与“中国人愿意用隐私交换便利性”的心态完全不同，欧美国家在个人隐私保护方面明显走得更早也更远一些。在2018年5月GDPR发布前后的一段时间里，保护个人隐私相关的需求被迅速提高了优先级，而像我这样一个开发国际化产品的普通程序员，日常工作也因此受到影响，我们放下手中的业务需求卡（Story），转而去做GDPR相关的安全需求。 一般在医疗保健或金融行业中，限制访问客户的敏感数据有着非常严格的规定，尤其欧洲GDPR颁布之后，公司泄露个人数据的后果也非常严重。在个人隐私保护方面，国内目前在法律和意识方面处于滞后的状态，但是许多人或多或少都感受到个人信息泄露给自己带来的麻烦，比如骚扰电话的增多就是最明显的例证。比较乐观的是网络安全法的发布，以及网民意识的觉醒，表明我们的个人信息保护正在路上。 对于一些面向欧美的项目，从公司最高层面，自上而下，我们采取了一系列相关动作，比如梳理我们基础设施架构图、数据流图、API数据字段分析等，其中包括保护日志中的个人信息。</p><h3 id="安全问题的特殊性"><a href="#安全问题的特殊性" class="headerlink" title="安全问题的特殊性"></a>安全问题的特殊性</h3><p>个人隐私安全和其它安全问题一样，是一个永远做不完的需求。你不能说你的网站是绝对安全的，只能说“我检查了所有目前已发现的安全漏洞列表（Checklist），并且采取了相应的防御措施，做到尽量安全”，或者说我们采取了一些很好的安全实践，比如采取了动态密码、在nginx上安装了防攻击防SQL注入插件等等。 现在的Web系统一般都配备了日志系统用于记录访问请求、分析线上事故等，比如开源的有ELK，SaaS的有DataDog、Sumo Logic 等。 在日志记录过程记录下一些用户隐私信息往往是不可避免的。诚然，开发者的个人隐私保护意识是很重要的，但有时并不一定是开发者的主动想偷窥用户信息。比如这里举一个很常见的情况，有些程序异常如果没有合理捕获，往往会输出调用堆栈，这些调用堆栈里面某些方法的参数可能就包含有个人隐私信息； 虽说没有一种一劳永逸的方式来避免个人信息出现在日志中，但我们可以通过下面的实践来尽量规避，并将这些<strong>内建</strong>在自己平时的开发工作中。下面的实践，一些涉及到了<strong>代码层面</strong>的技术实践、团队<strong>流程</strong>的优化，还有的是<strong>测试、运维</strong>上的一些措施。</p><h2 id="首先：确定什么是隐私数据"><a href="#首先：确定什么是隐私数据" class="headerlink" title="首先：确定什么是隐私数据"></a>首先：确定什么是隐私数据</h2><p>在我们深入讨论怎样避免个人隐私数据出现在日志之前，我们来界定什么是_隐私数据_：</p><ul><li>个人可标识数据（PII）：如社会安全号码，数据组合（如名字+出生日期或姓氏+邮政编码）或用户生成的数据（如电子邮件或用户名，如<a href="https://links.jianshu.com/go?to=mailto:BillGates@hotmail.com">blog@mail.baiyuan.wang</a>），手机号。</li><li>健康信息</li><li>财务数据（如信用卡号）</li><li>密码</li><li>IP地址：IP地址也有可能是个人隐私数据，尤其是与个人可标识数据与其有某种绑定关系。（而2019年的3.15晚会介绍一种将MAC也变成了PII的方式）</li></ul><p>个人隐私信息不一而足，其界定工作可能需要与熟悉GDPR的安全专家合作来完成，根据实际情况彻查应用内的数据，来确定什么是敏感的。</p><h2 id="一、解耦隐私字段"><a href="#一、解耦隐私字段" class="headerlink" title="一、解耦隐私字段"></a>一、解耦隐私字段</h2><p>处理隐私数据时，应尽量减少系统使用这些数据的频率。比如在数据库表设计时，使用电子邮件地址Email，或者极端一点的例子，使用身份证号码（下称PID）来作为“用户”表的主键。这意味系统在访问用户数据时，都需要使用Email或者PID来建立关联关系，这样做可能会非常省事，而且系统也是完全可以工作的，但是这极大地提高了敏感字段的曝光率，出现的地方越多，意味着被日志记录下来的几率越大。 所以更好的方法是解耦出隐私数据，只在在必要时才使用它。一种常见的解决方案是将随机生成的字符串作为用户表的ID，同时建立一个“1对1”的数据库表来存储用户ID与用户数据库表主键的关系。例如：  </p><p>PID | 外键<br>————————-<br>42-12xxxx-345 |5a2_cXKrt32DcWOJpJlyhr7FhTcLPfvlEAb1eA2Hza</p><p>在用户表以外的所有数据库表，都应该使用这个随机ID进行查询，这种随机ID即使被暴露也不会泄露任何个人数据。</p><h2 id="二、避免在URL中出现个人隐私信息"><a href="#二、避免在URL中出现个人隐私信息" class="headerlink" title="二、避免在URL中出现个人隐私信息"></a>二、避免在URL中出现个人隐私信息</h2><p>比如你有一个RESTful API，通过Email来查找用户信息，则可能很容易拥有这样一个Endpoint，如：**&#x2F;user&#x2F;<email>**。这种请求URL通常会被反向代理服务器和Web服务器记录下来，这样Email就会出现在日志当中。要将敏感数据不出现在网址之中，你可以 <strong>选项1.</strong> 不要将敏感字段用作唯一标识符，改用这些随机ID。 **选项2.**将敏感值作为POST的数据传递 与上面数据库解耦隐私字段一样，这些问题在API或数据库设计早期就需要考虑，否则可能后期需要花大量的工作来进行重构。而它的前提就是，应该要确定系统中哪些数据是敏感数据。</p><h2 id="三、对象打印重写toString方法"><a href="#三、对象打印重写toString方法" class="headerlink" title="三、对象打印重写toString方法"></a>三、对象打印重写toString方法</h2><p>为了定位问题或者debug的方便，开发经常会在日志中添加一个调试信息。因为追求方便的缘故，可能写出这样的代码（将User直接打印，而不是user.username）:</p><p>logger.info(“为用户$ {user}更新电子邮件);</p><p>一些程序语言，比如Java、Javascript，如果将一个对象直接进行打印，它其实是打印 toString方法返回的字符串，这样我们可以重写对象的toString方法来避免打印对象时出现的个人信息泄漏问题。</p><p>class UserAccount {<br>  id：string<br>  username：string<br>  passwordHash：string<br>  firstName：string<br>  lastName：string </p><p>  … </p><p>  public toString（）{<br>    return “UserAccount (${this.id})”;<br>}</p><p>如果开发人员实在“作死”的话，比如直接打印对象的字段就没有办法了，例如： <code>logger.info(&quot;The user&#39;s details are: $&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot;);</code></p><h2 id="四、结构化日志输出时屏蔽隐私字段"><a href="#四、结构化日志输出时屏蔽隐私字段" class="headerlink" title="四、结构化日志输出时屏蔽隐私字段"></a>四、结构化日志输出时屏蔽隐私字段</h2><p>为了日志方便查看，我们常常将日志以Json字符串的形式上传到日志服务器，这样我们查看日志可以清晰看到键值对结构。 我们可以在应用的日志输出中，遍历所有键值对信息，如果“键”存在firstName这样的字段，或者“值”中能匹配到Email，那么将对应的值替换成“<MASKED>”，例如：</p><p>Blacklist &#x3D; [“firstName”, “lastName”]<br>EmailRegex &#x3D; r”.+@.+”;<br>class Logger {<br>  log(details: Map&lt;string,string&gt;) {<br>    const cleanedDetails &#x3D; details.map( (key, value) &#x3D;&gt; {<br>      if (Blacklist.contains(key) || EmailRegex.match(value)) {<br>        return (key, “<MASKED>“);<br>      }<br>      return (key, value);<br>    }<br>    console.log(JSON.stringify(cleanedDetails));<br>  }<br>}</p><h2 id="五、将日志代码审查纳入Code-Review"><a href="#五、将日志代码审查纳入Code-Review" class="headerlink" title="五、将日志代码审查纳入Code Review"></a>五、将日志代码审查纳入Code Review</h2><p>Code Review是开发过程中可以保证代码质量的部分，比如在Code Review中常常会被别人指出程序漏洞、健壮性问题、改进建议等等。将日志代码的检查作为Code Review中各个成员关注的一部分。这个方面不是技术层面，而是团队Code Review流程上的改善。 如果使用的是<a href="https://links.jianshu.com/go?to=https://blog.github.com/2016-02-17-issue-and-pull-request-templates/">Pull Request Template</a> 来进行合并代码，则可能需要在模板中设置一个复选框，提示reviewer进行检查。</p><h2 id="六、个人信息泄露测试纳入QA和自动化测试"><a href="#六、个人信息泄露测试纳入QA和自动化测试" class="headerlink" title="六、个人信息泄露测试纳入QA和自动化测试"></a>六、个人信息泄露测试纳入QA和自动化测试</h2><p>虽说目前大部分公司的实践，并没有把<strong>个人隐私泄露测试纳入测试或者QA人员的工作范围</strong>，但是这部分的工作不仅需要测试来做，而且甚至<strong>可以自动化</strong>。 比如一个用户注册的场景，测试人员可以模仿用户在Web前端表单填写姓名、Email后，检查服务器日志中是否含有这些信息。而这部分工作可以使用Selenium、Cypress等端到端测试工具，然后调用日志服务器的API来搜索这些信息是否存在，来实现自动化。 自动化的个人隐私泄露测试也可以将其<strong>纳入到CI&#x2F;CD持续集成流水线</strong>中。    </p><h2 id="七、在日志收集器上传前“打码”隐私信息"><a href="#七、在日志收集器上传前“打码”隐私信息" class="headerlink" title="七、在日志收集器上传前“打码”隐私信息"></a>七、在日志收集器上传前“打码”隐私信息</h2><p>在我们的项目中，一般存在两种日志收集方式</p><ul><li>通过日志中心提供的日志收集进程（代理程序、Agent），将机器实例的标准输出或者日志文件内容，推送到日志服务器</li><li>通过AWS Lambda无服务器代码转发日志到日志中心</li></ul><p><a href="https://baiyuan.wang/wp-content/uploads/2019/04/Log-Collection.jpg"><img src="https://baiyuan.wang/wp-content/uploads/2019/04/Log-Collection.jpg"></a> 日志收集工具是日志到达日志中心的必经之地，在这个关口做好信息屏蔽，就可以对来自所有服务（多个微服务的情况下）的日志做集中式的处理。Datadog Agent直接提供了<a href="https://docs.datadoghq.com/logs/log_collection/#scrub-sensitive-data-in-your-logs">屏蔽隐私数据的配置</a>，而AWS Lambda的代码则是我们可控的，可以自己实现代码层面的正则替换。   </p><h2 id="八、日志系统中配置个人隐私信息的监控告警"><a href="#八、日志系统中配置个人隐私信息的监控告警" class="headerlink" title="八、日志系统中配置个人隐私信息的监控告警"></a>八、日志系统中配置个人隐私信息的监控告警</h2><p>即使有了上面的实践，我们依旧不能保证个人隐私绝对不会出现在日志中，一方面我们可以在平时Debug、查看应用日志时有意识地检查有没有含有隐私信息，另一方面我们还是可以通过一些技术手段<strong>将这一检测工作自动化</strong>，并通过<strong>告警系统通知</strong>到团队成员进行处理。 <a href="https://baiyuan.wang/wp-content/uploads/2019/04/Screen-Shot-2019-04-18-at-13.13.53.png"><img src="https://baiyuan.wang/wp-content/uploads/2019/04/Screen-Shot-2019-04-18-at-13.13.53.png"></a> 在监控系统配置Email告警 这已经在笔者所在的团队中得到实践。我们使用Datadog作为日志、监控系统，成功实现在日志中出现Email信息时，Datadog能自动发送邮件通知。但是需要指出的一点是，因为Email可以很好地通过正则表达式进行匹配，同时被很多日志系统所支持。但是对于姓名这些信息，可能只能交给人工智能了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://baiyuan.wang/wp-content/uploads/2019/04/PII-Protection.jpg"><img src="https://baiyuan.wang/wp-content/uploads/2019/04/PII-Protection.jpg" alt="PII Protection"></a> PII Protection 从上面的阐述中可以看到，个人隐私信息的保护，已经不是请一个安全专家就能简单解决的问题，也不是单独的某个角色的工作，而是需要整个团队各个角色的通力合作。这就是DevSecOps理念。  </p><ul><li>参考资料：<a href="https://links.jianshu.com/go?to=https://medium.com/@joecrobak/seven-best-practices-for-keeping-sensitive-data-out-of-logs-3d7bbd12904">https:&#x2F;&#x2F;medium.com&#x2F;@joecrobak&#x2F;seven-best-practices-for-keeping-sensitive-data-out-of-logs-3d7bbd12904</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2019年度“315”晚会人工智能拨打骚扰电话的情节，让大众了解到在信息时代，保护个人隐私的重要性。本篇文章分享了在日志记录中保护用户隐私数据的七个最佳实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与“中国人愿意用隐私交换便利性”的心态完全不同</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="DevOps" scheme="https://baiyuan.wang/tags/DevOps/"/>
    
    <category term="日志" scheme="https://baiyuan.wang/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>利用ModSecurity为你的wordpress博客保驾护航</title>
    <link href="https://baiyuan.wang/use-modsecurity-escort-your-wordpress-blog.html"/>
    <id>https://baiyuan.wang/use-modsecurity-escort-your-wordpress-blog.html</id>
    <published>2019-03-12T07:28:12.000Z</published>
    <updated>2024-03-28T02:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<p>ModSecurity是一个入侵探测与阻止的引擎，它主要是用于Web应用程序所以也可以叫做Web应用程序防火墙；它可以作为Apache Web服务器的一个模块或单独的应用程序来运行。ModSecurity的目的是为增强Web应用程序的安全性，来保护Web应用程序避免遭受攻击. <img src="https://baiyuan.wang/wp-content/uploads/2019/03/20190312152420118.gif" alt="24173056_1dMG.gif"></p><p>Availability of ModSecurity 2.9.1</p><h2 id="ModSecurity功能特点"><a href="#ModSecurity功能特点" class="headerlink" title="ModSecurity功能特点"></a>ModSecurity功能特点</h2><h3 id="HTTP流量记录"><a href="#HTTP流量记录" class="headerlink" title="HTTP流量记录"></a>HTTP流量记录</h3><p>web服务器已有的日志功能已经足够进行访问请求分析，但是就web的应用分析还有些不足，特别是大多情况下没办法记录下请求体。你的对手很清楚这 一点，所以很多时候的攻击是通过POST请求产生，并导致您的系统失明。ModSecurity充分的获取HTTP交互中的所以内容，并记录完整的请求和 响应。其日志功能可以允许您更细致的做出判断究竟什么是登录的时候，并确保相关的数据都被记录下来。一些请求和响应中的某些关键字段可能包含敏感数 据，ModSecurity可以被配置成在记录这些审计日志前隐藏它。</p><h3 id="实时监控和攻击检测"><a href="#实时监控和攻击检测" class="headerlink" title="实时监控和攻击检测"></a>实时监控和攻击检测</h3><p>除了提供记录日志功能外，ModSecurity还能实时的监控HTTP的流量以检测攻击。在某些时候，ModSecurity做为一个WEB入侵检测工具，可以让你对发生在WEB系统上的一些可疑事件做出响应。</p><h3 id="攻击防御和及时修补"><a href="#攻击防御和及时修补" class="headerlink" title="攻击防御和及时修补"></a>攻击防御和及时修补</h3><p>ModSecurity能够立即针对你的WEB应用系统进行攻击防御，有三种通用的方法： 1、消极(negative)安全模型：消极安全模型监控那些异常的、不常用的和通用的WEB攻击类请求。它统计每个请求的有关IP地址、应该连接、和用户帐户的异常分数，当出现较高的异常分数时，会记录日志并完全的阻止访问。 2、积极安全模开型：部署积极安全模型后，只有那些明确的请求被允许通过，其它的一律禁止。这个模式要求你对需要保护的WEB应用要非常的了解。因此积极安全模式最好是用于那种大量访问却很少更新的系统，这样才能使这种模型的维护工作量降到最低。 3、已知漏洞攻击：其规则语言使ModSecurity成为一个理想的外部修补工具，外部修补（有时是指虚拟修补）可以减少机会之窗。一些 组织修补这些应用的漏洞通常需要几周的时间，使用ModSecurity，应用系统可以从外部修补，根本不用改应用的源码（甚至时不用去管它），可以保证 你的系统安全直到有一个合适的补丁来应用到系统中。</p><h3 id="灵活的规则引擎"><a href="#灵活的规则引擎" class="headerlink" title="灵活的规则引擎"></a>灵活的规则引擎</h3><p>灵活的规则引擎是ModSecurity的核心，其实现了ModSecurity的规则语言，这是一个专用的程序语言设计的用于处理HTTP的传输 数据。ModSecurity规则语言被设计的简单易用，非常的灵活：通用的操作是简单的，而复杂的操作也是可以实现的。经过认证的 ModSecurity规则，放在ModSecurity中，包含了一整套规则，它实现了通用目的强化、协议正规化和对一些通用web应用安全问题的检 测。大量评论认为，这些规则可以用于学习研究使用。</p><h3 id="嵌入式模式部署"><a href="#嵌入式模式部署" class="headerlink" title="嵌入式模式部署"></a>嵌入式模式部署</h3><p>ModSecurity是一个可嵌入式的WEB应用防火墙，意思就是它可以做为以apache为基础的已经提供WEB服务的WEB服务器的一部分。这样的部署译意风一些特殊的优势： 1、不改变已有的网络结构。只需要花几分钟就可以为你的WEB服务器添加ModSecurity，而且由于它默认被设计为完全的被动方式，你可以自由的逐步部署并且只使用你需要的特性。同样也可以根据你的需要轻松的删除或停用它。 2、不存在单点故障。与网络设备部署方式不同，你不会给你的系统带来新的故障点。 3、绝对支持负载均衡。因为它以嵌入方式运行在WEB服务器上，ModSecurity会自动的利用附加的负载均衡特性。你不需要考虑负载均衡，除非你的系统本来就需要它。 4、极少开销。因为它在WEB服务器进程内工作，不会带来网络间接通信的负载，而且只进行最小的分析和数据交换开销。 5、加密或压缩内容没问题。许多IDS系统分析SSL流量的时候很困难，但对于ModSecurity没有麻烦，因为它工作于已解密和解压的数据环节。</p><h3 id="基于网络的部署"><a href="#基于网络的部署" class="headerlink" title="基于网络的部署"></a>基于网络的部署</h3><p>在基于apache的反向代理模式上ModSecurity同样能工作的很好，我们很多客户选择这样做。在这种情形下，装了ModSecurity的可以保护任一一种WEB服务器（即使它不是apache的）。  </p><h2 id="基于Wordpress-Docker镜像安装ModSecurity"><a href="#基于Wordpress-Docker镜像安装ModSecurity" class="headerlink" title="基于Wordpress Docker镜像安装ModSecurity"></a>基于Wordpress Docker镜像安装ModSecurity</h2><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>FROM wordpress:4.9.8-php5.6-apache<br>RUN apt-get update &amp;&amp; apt-get install -y libapache2-mod-security2<br>RUN a2enmod security2</p><h3 id="在站点配置文件中启用mod-security"><a href="#在站点配置文件中启用mod-security" class="headerlink" title="在站点配置文件中启用mod-security"></a>在站点配置文件中启用mod-security</h3><p>SecRuleEngine On</p><p>&lt;VirtualHost *:80&gt;<br>    ServerName baiyuan.wang<br>    ServerAdmin <a href="mailto:&#98;&#x6c;&#x6f;&#103;&#x40;&#109;&#97;&#105;&#108;&#x2e;&#98;&#97;&#105;&#x79;&#117;&#x61;&#x6e;&#x2e;&#119;&#97;&#x6e;&#x67;">&#98;&#x6c;&#x6f;&#103;&#x40;&#109;&#97;&#105;&#108;&#x2e;&#98;&#97;&#105;&#x79;&#117;&#x61;&#x6e;&#x2e;&#119;&#97;&#x6e;&#x67;</a><br>    DocumentRoot &#x2F;var&#x2F;www&#x2F;html<br>    ErrorLog ${APACHE_LOG_DIR}&#x2F;error.log<br>    CustomLog ${APACHE_LOG_DIR}&#x2F;access.log cdn_combined<br></VirtualHost></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>XSS 测试</li></ul><p>curl ‘<a href="https://baiyuan.wang/?q=%22%3E">https://baiyuan.wang/?q=&quot;&gt;</a><script>alert(1)</script>‘</p><ul><li>SQL 注入</li></ul><p>curl “<a href="https://baiyuan.wang/?q=%271">https://baiyuan.wang/?q=&#39;1</a> OR 1&#x3D;1”</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/geekeren/wordpress-env">https://github.com/geekeren/wordpress-env</a> : 基于wordpress官方镜像添加HTTPS、HTTP2、Mod-Security、mod-headers支持，同时支持使用docker-compose一键构建包含mysql、redis、datadog的wordpress博客环境</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ModSecurity是一个入侵探测与阻止的引擎，它主要是用于Web应用程序所以也可以叫做Web应用程序防火墙；它可以作为Apache Web服务器的一个模块或单独的应用程序来运行。ModSecurity的目的是为增强Web应用程序的安全性，来保护Web应用程序避免遭受攻击</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="网站安全" scheme="https://baiyuan.wang/tags/%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于持续集成-变更合并</title>
    <link href="https://baiyuan.wang/on-continuous-integration-change-merge.html"/>
    <id>https://baiyuan.wang/on-continuous-integration-change-merge.html</id>
    <published>2019-02-21T07:47:29.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<p>发布的时候，各特性分支才merge到master，如果几个特性分支修改了相同文件并造成冲突，如果发布周期比较长的话，merge的时候可能就会造成大量冲突。个人经验，一般是尽量做到持续发布、快速迭代（尽快merge到master），其次这要求写故事卡的童鞋遵循INVEST，卡尽量小且功能无依赖并独立。在以往项目的实践一般比较灵活，小feature直接在master搞），变更比较大的在特性分支上，很少有人喜欢用feature toggle。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发布的时候，各特性分支才merge到master，如果几个特性分支修改了相同文件并造成冲突，如果发布周期比较长的话，merge的时候可能就会造成大量冲突。个人经验，一般是尽量做到持续发布、快速迭代（尽快merge到master），其次这要求写故事卡的童鞋遵循INVEST，卡</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CI/CD" scheme="https://baiyuan.wang/tags/CI-CD/"/>
    
    <category term="敏捷" scheme="https://baiyuan.wang/tags/%E6%95%8F%E6%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>【开源】zipkin-js-instrumentation-axios: 集成axios和zipkin</title>
    <link href="https://baiyuan.wang/zipkin-js-instrumentation-axios.html"/>
    <id>https://baiyuan.wang/zipkin-js-instrumentation-axios.html</id>
    <published>2019-02-19T05:47:00.000Z</published>
    <updated>2024-03-28T02:24:50.740Z</updated>
    
    <content type="html"><![CDATA[<p>Zipkin 是由Twitter公司开发并开源的分布式追踪系统，而axios则是常用的Javascript HTTP客户端。由于zipkin-js官方没有提供axios的适配，同时同类型库zipkin-jinstrumentation-axios已经破坏了axios的原有功能，为此极客人制作了本库用于集成zipkin和axios，可以支持axios原有的所有方法属性，其用法和axios完全一致。</p><h1 id="zipkin-js-instrumentation-axios"><a href="#zipkin-js-instrumentation-axios" class="headerlink" title="zipkin-js-instrumentation-axios"></a>zipkin-js-instrumentation-axios</h1><p>Adds Zipkin tracing support for the <a href="https://www.npmjs.com/package/axios">axios</a> JS HTTP client library. It <strong>supports all features of <code>axios</code></strong>.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a><a href="https://github.com/geekeren/zipkin-js-instrumentation-axios#installation"></a>Installation</h2><p>npm install zipkin-js-instrumentation-axios –save</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a><a href="https://github.com/geekeren/zipkin-js-instrumentation-axios#usage"></a>Usage</h2><p>You need to use <code>wrapAxios</code> fucntion to wrap the native <code>axios</code> instance, and the <code>axios</code> instance’s type&#x2F;functions&#x2F;attributes are not affected. As a result, you can use <code>zipkinAxios</code> the same as <code>axios</code> For example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);<br><span class="hljs-keyword">const</span> wrapAxios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zipkin-js-instrumentation-axios&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Tracer</span>, <span class="hljs-title class_">ExplicitContext</span>, <span class="hljs-title class_">ConsoleRecorder</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;zipkin&#x27;</span>);<br><br><span class="hljs-keyword">const</span> ctxImpl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExplicitContext</span>();<br><span class="hljs-keyword">const</span> recorder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleRecorder</span>();<br><span class="hljs-keyword">const</span> localServiceName = <span class="hljs-string">&#x27;service-a&#x27;</span>; <span class="hljs-comment">// name of this application</span><br><span class="hljs-keyword">const</span> tracer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tracer</span>(&#123; ctxImpl, recorder, localServiceName &#125;);<br><br><span class="hljs-keyword">const</span> remoteServiceName = <span class="hljs-string">&#x27;weather-api&#x27;</span>;<br><span class="hljs-keyword">const</span> zipkinAxios = <span class="hljs-title function_">wrapAxios</span>(axios, &#123; tracer, localServiceName, remoteServiceName &#125;);<br><br>zipkinAxios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user?ID=12345&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p> </p><h3 id="Interceptors-of-Axios-also-supported"><a href="#Interceptors-of-Axios-also-supported" class="headerlink" title="Interceptors of Axios also supported"></a><a href="https://github.com/geekeren/zipkin-js-instrumentation-axios#interceptors-of-axios-also-supported"></a>Interceptors of Axios also supported</h3><p>You can intercept requests or responses before they are handled by then or catch.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Add a request interceptor</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// Do something before request is sent</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// Do something with request error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;);<br> <br><span class="hljs-comment">// Add a response interceptor</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// Do something with response data</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// Do something with response error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p> </p><h3 id="The-test-cases-all-passed"><a href="#The-test-cases-all-passed" class="headerlink" title="The test cases all passed"></a><a href="https://github.com/geekeren/zipkin-js-instrumentation-axios#the-test-cases-all-passed"></a>The test cases all passed</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">axios</span> instrumentation - integration test<br>   ✓ should add headers to requests<br>   ✓ should sup<span class="hljs-keyword">port</span> request shorthand (defaults to GET)<br>   ✓ should sup<span class="hljs-keyword">port</span> both url and uri options<br>   ✓ should sup<span class="hljs-keyword">port</span> promise callback<br>   ✓ should re<span class="hljs-keyword">port</span> 404 when path does not exist<br>   ✓ should re<span class="hljs-keyword">port</span> when service does not exist (41ms)<br>   ✓ should re<span class="hljs-keyword">port</span> when service returns 400<br>   ✓ should re<span class="hljs-keyword">port</span> when service returns 500<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zipkin 是由Twitter公司开发并开源的分布式追踪系统，而axios则是常用的Javascript HTTP客户端。由于zipkin-js官方没有提供axios的适配，同时同类型库zipkin-jinstrumentation-axios已经破坏了axios的原有功</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JS" scheme="https://baiyuan.wang/tags/JS/"/>
    
    <category term="微服务" scheme="https://baiyuan.wang/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>K8S使用就绪和存活探针配置健康检查</title>
    <link href="https://baiyuan.wang/k8s-health-examination-with-ready-survival-probes.html"/>
    <id>https://baiyuan.wang/k8s-health-examination-with-ready-survival-probes.html</id>
    <published>2019-01-17T10:30:19.000Z</published>
    <updated>2024-03-28T02:24:50.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>健康检查（Health Check）可用于服务运行的状态监控，比如腾讯旗下的DNSPOD的D监控，要求配置一个访问路径以判断网站是否可以正常访问实际上就是一个健康检查，当发现健康检查失败时会发送一个邮件通知或者短信来告知网站管理员进行维修。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/01/20190117183007118.jpg" alt="K8S流量转发" title="K8S流量转发"></p><p>而在现代一些分布式系统中，用户访问不再是单台主机，而是一个由成百上千台实例组成的<strong>集群</strong>，用户请求通过<strong>负载均衡器</strong>分发到不同的实例，<strong>负载均衡</strong>帮助解决单台服务器的访问压力，同时提高了系统的<strong>高可用性</strong>，而<strong>健康检查</strong>常常作为当前实例是否“可用”的判断标准。即：<strong>当系统发现某台实例健康检查不通过，负载均衡器将不会把流量导向该实例</strong>。 现在的云服务厂商比如AWS一般都为负载均衡配备了健康检查，而<strong>Kubernetes</strong>提供了两种探针来检查容器的状态，Liveliness和Readiness，根据<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-readiness-probes">官方文档</a>，Liveliness探针是为了查看容器是否正在运行，翻译为<strong>存活探针</strong>（livenessProbe），Readiness探针是为了查看容器是否准备好接受HTTP请求，翻译为<strong>就绪探针</strong>（readinessProbe）。 在Kubernetes中，Pod是Kubernetes创建及管理的最小的可部署的计算单元，一个Pod由一个或者多个容器（Docker，rocket等等）组成，这些容器共享内存，网络以及运行容器的方式。 在Kubernetes上下文中<strong>存活探针和就绪探针</strong>被称作<strong>健康检查</strong>。这些容器探针是一些周期性运行的小进程，这些探针返回的结果（成功，失败或者未知）反映了容器在Kubernetes的状态。基于这些结果，Kubernetes会判断如何处理每个容器，以保证弹性，高可用性和更长的正常运行时间。</p><h2 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h2><p>就绪探针旨在让Kubernetes知道你的应用<strong>是否准备好为请求提供服务</strong>。Kubernetes只有在就绪探针通过才会把流量转发到Pod。如果就绪探针检测失败，Kubernetes将停止向该容器发送流量，直到它通过。</p><h2 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h2><p>Liveness探测器是让Kubernetes知道你的<strong>应用是否活着</strong>。如果你的应用还活着，那么Kubernetes就让它继续存在。如果你的应用程序已经死了，Kubernetes将移除Pod并重新启动一个来替换它。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>让我们看看两个场景，来看看就绪探针和存活探针怎样帮助我们构建更高可用的的系统。</p><h3 id="就绪探针-1"><a href="#就绪探针-1" class="headerlink" title="就绪探针"></a>就绪探针</h3><p>一个应用往往需要一段时间来预热和启动，比如一个后端项目的启动需要连接数据库执行数据库迁移等等，一个Spring项目的启动也需要依赖Java虚拟机。即使该过程已启动，您的服务在启动并运行之前也无法运行。应用在完全就绪之前不应接收流量，但默认情况下，Kubernetes会在容器内的进程启动后立即开始发送流量。通过就绪探针探测，直到应用程序完全启动，然后才允许将流量发送到新副本。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/01/20190117183008212.jpg" alt="就绪探针的工作过程" title="就绪探针的工作过程"></p><p>就绪探针的工作过程</p><h3 id="存活探针-1"><a href="#存活探针-1" class="headerlink" title="存活探针"></a>存活探针</h3><p>让我们想象另一种情况，当我们的应用在成功启动以后因为一些原因“宕机”，或者遇到死锁情况，导致它无法响应用户请求。 在默认情况下，Kubernetes会继续向Pod发送请求，通过使用存活探针来检测，当发现服务不能在限定时间内处理请求（请求错误或者超时），就会重新启动有问题的pod。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/01/20190117183008319.jpg" alt="存活探针的工作过程" title="存活探针的工作过程"></p><p>存活探针的工作过程</p><h2 id="探针类型"><a href="#探针类型" class="headerlink" title="探针类型"></a>探针类型</h2><p>探针类型是指通过何种方式来进行健康检查，K8S有三种类型的探测：HTTP，Command和TCP。 <strong>HTTP</strong> HTTP探测可能是最常见的探针类型。即使应用不是HTTP服务，也可以创建一个轻量级HTTP服务器来响应探测。比如让Kubernetes通过HTTP访问一个URL，如果返回码在200到300范围内，就将应用程序标记为健康状态，否则它被标记为不健康。 更多关于HTTP探测可参考<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-a-liveness-http-request">这里</a>。 <strong>命令</strong> 对于命令探测，是指Kubernetes在容器内运行命令。如果命令以退出代码0返回，则容器将标记为正常。否则，它被标记为不健康。 更多关于命令探测可参考<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-a-liveness-command">这里</a>。 <strong>TCP</strong> 最后一种类型的探测是TCP探测，Kubernetes尝试在指定端口上建立TCP连接。如果它可以建立连接，容器被认为是健康的; 如果它不能被认为是不健康的。这常用于对<a href="https://grpc.io/">gRPC</a>或FTP服务的探测。 更多关于TCP探测可参考<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-a-tcp-liveness-probe">这里</a>。</p><h3 id="初始探测延迟"><a href="#初始探测延迟" class="headerlink" title="初始探测延迟"></a>初始探测延迟</h3><p>我们可以配置K8S健康检查运行的频率，检查成功或失败的条件，以及响应的超时时间。可参考<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes">有关配置探针的文档</a>。 存活探针探测失败会导致pod重新启动，所以配置初始探测延迟 <strong>initialDelaySeconds</strong>十分重要，要确保在应用准备之后探针才启动。否则，应用将无限重启！ 我建议使用<a href="https://www.quora.com/What-is-p99-latency">p99</a>启动时间作为initialDelaySeconds，或者取平均启动时间外加一个buffer。同时根据应用程序的启动时间更新这个值。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以下面的一个K8S的配置代码为例，</p><p>apiVersion: apps&#x2F;v1beta1<br>kind: Deployment<br>…<br>…<br>        readinessProbe:<br>          httpGet:<br>            path: &#x2F;actuator&#x2F;health<br>            port: 8080<br>          initialDelaySeconds: 120<br>          timeoutSeconds: 10<br>        livenessProbe:<br>          httpGet:<br>            path: &#x2F;actuator&#x2F;health<br>            port: 8080<br>          initialDelaySeconds: 60<br>          timeoutSeconds: 10<br>          periodSeconds: 5</p><p> </p><ul><li>K8S将在Pod开始<strong>启动后120s(initialDelaySeconds)后</strong>利用HTTP访问8080端口的 <strong>&#x2F;actuator&#x2F;health</strong>，如果<strong>超过10s</strong>或者返回码不在200~300内，就绪检查就失败</li><li>类似的，在Pod运行过程中，K8S仍然会每隔5s(periodSeconds检测8080端口的 <strong>&#x2F;actuator&#x2F;health</strong></li></ul><p><strong>参考资料</strong></p><ul><li><a href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes">【Kubernetes best practices: Setting up health checks with readiness and liveness probes】</a></li><li><a href="http://dockone.io/article/8367">【Kubernetes存活探针和就绪探针的最佳实践】</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;健康检查&quot;&gt;&lt;a href=&quot;#健康检查&quot; class=&quot;headerlink&quot; title=&quot;健康检查&quot;&gt;&lt;/a&gt;健康检查&lt;/h2&gt;&lt;p&gt;健康检查（Health Check）可用于服务运行的状态监控，比如腾讯旗下的DNSPOD的D监控，要求配置一个访问路径以判断</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式系统" scheme="https://baiyuan.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="微服务" scheme="https://baiyuan.wang/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构" scheme="https://baiyuan.wang/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>旧金山之行</title>
    <link href="https://baiyuan.wang/trip-san-francisco.html"/>
    <id>https://baiyuan.wang/trip-san-francisco.html</id>
    <published>2018-12-22T13:13:28.000Z</published>
    <updated>2024-03-28T02:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<p>美西海岸有山，名曰“旧金山”。</p><h2 id="忽闻海上有仙山"><a href="#忽闻海上有仙山" class="headerlink" title="忽闻海上有仙山"></a>忽闻海上有仙山</h2><p>飞机降落前的旧金山，青山如黛，江山如画，山在飘渺虚无间。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091305118.jpg" alt="山在缥缈虚无间"> 山在缥缈虚无间</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091306215.jpg" alt="鸟瞰下鳞次栉比的街道，就像美国地图一样，被切分得规规整整。"></p><p>鸟瞰下鳞次栉比的街道，就像美国地图一样，被切分得规规整整。</p><h2 id="陈旧而意蕴十足的街头"><a href="#陈旧而意蕴十足的街头" class="headerlink" title="陈旧而意蕴十足的街头"></a>陈旧而意蕴十足的街头</h2><p>在旧金山的街头闲逛，没有想象中的繁华，与国内的街道对比，最大的感受就是人太少，仿佛城市的背景噪音都小了几分贝，不自觉地从内心里感觉到静谧。</p><p>估摸着旧金山的城市基建不像中国一样都是近几年修建，或者翻新重建的，整体上没有中国感觉那么新，道路坑洼不平，低低的电线也是缠绕在城市美国角落，不过建筑充满历史和艺术感，不像国内建筑千篇一律。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091307316.jpg" alt="鸟瞰下鳞次栉比的街道，就像美国地图一样，被切分得规规整整。"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091308413.jpg" alt="陈旧而意蕴十足的街头"> 陈旧而意蕴十足的街头</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091309517.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091311619.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091312714.jpg" alt="image"></p><p>一进入旧金山的唐人街，熟悉感和亲切感是由内而外的。走进商店，和中国的小卖部别无二致，有各色蔬菜的菜市场，有红枣、枸杞、花生干活铺，空气中都是“中国”的味道。这是一个神奇的感觉，仿佛在异国中一处家的孤岛。路上的广告牌看起来和香港街道一样，显然不是大陆的style，店主听口音大多数上台湾人和香港人。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091313811.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/20190416091314914.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913151013.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913161114.jpg" alt="image"></p><p>国内品牌的方便面</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913171211.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913181313.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913191419.jpg" alt="在“南京小馆”吃了第一顿饱饭"> 在“南京小馆”吃了第一顿饱饭</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913201518.jpg" alt="金门大桥"> 金门大桥</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913211618.jpg" alt="image"></p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/04/201904160913221710.jpg" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;美西海岸有山，名曰“旧金山”。&lt;/p&gt;
&lt;h2 id=&quot;忽闻海上有仙山&quot;&gt;&lt;a href=&quot;#忽闻海上有仙山&quot; class=&quot;headerlink&quot; title=&quot;忽闻海上有仙山&quot;&gt;&lt;/a&gt;忽闻海上有仙山&lt;/h2&gt;&lt;p&gt;飞机降落前的旧金山，青山如黛，江山如画，山在飘渺虚无间</summary>
      
    
    
    
    <category term="岁月" scheme="https://baiyuan.wang/categories/%E5%B2%81%E6%9C%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Cloudformation与其背后的“基础设施即代码”</title>
    <link href="https://baiyuan.wang/cloudformation-infrastructure-code-behind-it.html"/>
    <id>https://baiyuan.wang/cloudformation-infrastructure-code-behind-it.html</id>
    <published>2018-11-16T13:43:19.000Z</published>
    <updated>2024-03-28T02:24:50.728Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉AWS的肯定不会对Cloudformation感到陌生，AWS官方对Cloudformation的定义如下：</p><blockquote><p>AWS CloudFormation 云资源服务可使开发人员和系统管理员轻松有序地创建、管理和更新相关 AWS 云资源模板。使用 AWS 模板或创建您自己的云资源。</p></blockquote><p>为了最快地对Cloudformation在心中稍微有一个概念，我为大家提炼出下面的关键词：</p><ul><li>利益相关者：运维或DevOps领域</li><li>一种管理云资源的服务</li><li>由AWS提供</li><li>通过模板文件（或者说配置文件、代码）管理云资源</li></ul><h2 id="代码-vs可视化操作"><a href="#代码-vs可视化操作" class="headerlink" title="代码 vs可视化操作"></a>代码 vs可视化操作</h2><p>联想起自己以前使用云服务的体验，初学者首先应该能想到，我是不是可以通过Cloudformation来申请主机、创建Loadbalance呢，而不是手动在AWS的控制台（Console）上“点点点”呢？</p><p>是的。如果说Cloudformation仅仅使可视化的界面操作代码化，这或许只能激起代码爱好者的兴趣，我们知道代码化的许多好处，比如效率更高、可被机器自动执行。</p><p>然而因为不是所有人都喜欢代码。对于患“代码恐惧症”的人，或者习惯在界面上配置的专业运维人员来说，界面操作显然比代码更直观、拥有更友好的操作引导。</p><p>对于追求高效的工程实践来说，代码化还是界面操作并非“萝卜青菜，各有所爱”的兴趣爱好问题，而是生产力问题。</p><h2 id="基础设施即代码"><a href="#基础设施即代码" class="headerlink" title="基础设施即代码"></a>基础设施即代码</h2><p>这年头流行一个词语，叫DevOps，维基百科的定义如下：</p><blockquote><p>DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><p>而我个人的理解就是，DevOps要求能把运维纳入软件开发体系，比如运用敏捷等软件开发方法、实现自动化持续集成、测试、交付、可被代码管理等等；其次，要求开发具备运维意识，将交付基础设施作为交付软件的一部分，借助云计算给开发人员赋能从而达到端到端交付的全栈能力，从而极大地提高研发效能。</p><p>在这个意义上，Cloudformation就是这样一个工具，可以将基础设施作为代码纳入到软件开发的一部分，并运用软件工程方法管理基础架构。</p><h2 id="“基础设施即代码”给我们带来什么"><a href="#“基础设施即代码”给我们带来什么" class="headerlink" title="“基础设施即代码”给我们带来什么"></a>“基础设施即代码”给我们带来什么</h2><p>在笔者所在的团队里，能写DevOps的代码已经作为开发的标配技能。在新起一个Codebase的时候，我们往往需要考虑一下内容：  </p><p><img src="https://baiyuan.wang/wp-content/uploads/2018/11/20181116134234113.jpg" alt="一个项目的文件结构截图"></p><p>一个项目的文件结构截图</p><ul><li>基础设施代码 （&#x2F;infra目录）</li><li>持续集成流水线代码（&#x2F;pipeline目录, 这年头还有个词叫“<a href="http://insights.thoughtworkers.org/pipeline-as-code/">流水线即代码</a>”）</li><li>业务代码（包括前后端代码、测试代码，&#x2F;api, &#x2F;test 目录）</li></ul><p>在一些大型的互联网公司来说，运维和开发的职权是完全分离的，开发可能仅仅只用关注业务代码部分。</p><p>实际上在一个项目启动后的前期，首先介入的可能是运维人员搭建出一套线上的开发环境（Dev）、测试环境（QA）、生产环境（Prod）用于开发的日常调试、测试人员测试以及发布项目；如果使用持续集成的方式的话，还要搭建持续集成（CI&#x2F;CD）流水线。</p><h3 id="一键自动构建云环境"><a href="#一键自动构建云环境" class="headerlink" title="一键自动构建云环境"></a>一键自动构建云环境</h3><p>借助AWS平台及其提供的Cloudformation（或者第三方工具如<a href="https://www.terraform.io/">terraform</a>），使用基础设施代码，我们就可以快速地构建一套完整的云环境。同时使用同样一套基础设施代码，再配置不同的环境变量，就可以快速地复制出不同的线上环境。</p><p>以Cloudformation为例：</p><p>编写Cloudformation代码，比如编写通过以下的代码，通过AWS提供的aws cloudformation命令，就可以实现在AWS创建一台可以弹性伸缩的实例。</p><p>ECSAutoScalingGroup:<br>    Type: ‘AWS::AutoScaling::AutoScalingGroup’<br>    Properties:<br>      VPCZoneIdentifier: !Ref InstanceSubnetIds<br>      LaunchConfigurationName: !Ref ContainerInstances<br>      MinSize: ‘1’<br>      MaxSize: !Ref MaxSize<br>      DesiredCapacity: !Ref DesiredCapacity<br>  ContainerInstances:<br>    Type: ‘AWS::AutoScaling::LaunchConfiguration’<br>    Properties:<br>      ImageId: !FindInMap<br>        - AWSRegionToAMI<br>        - !Ref ‘AWS::Region’<br>        - AMIID<br>      InstanceType: !Ref InstanceType<br>      IamInstanceProfile: !Ref EC2InstanceProfile<br>      KeyName: !Ref KeyName</p><p>同时我们可以使用AWS Cloudformation designer可视化地设计我们的基础架构及其之前的拓扑结构和关联关系，并导出代码。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2018/11/20181116134234212.jpg" alt="AWS Cloudformation designer"></p><p>AWS Cloudformation designer</p><h3 id="借助git等实现代码的版本管理"><a href="#借助git等实现代码的版本管理" class="headerlink" title="借助git等实现代码的版本管理"></a>借助git等实现代码的版本管理</h3><p>代码化后的基础设施，意味着可被git等版本控制工具进行管理，这意味着对基础设施的任何改动，比如更改服务器内存、更换可用区、修改域名、安全组等等，都可以通过review代码的方式进行跟踪。</p><p>而在过去，在控制台界面上进行的误操作导致线上环境出问题很难被记录下来，同时如果因为修改服务器环境配置导致的问题，可以很快通过git回滚代码的方式进行快速回滚服务器环境。</p><h3 id="基础设施版本间无缝切换"><a href="#基础设施版本间无缝切换" class="headerlink" title="基础设施版本间无缝切换"></a>基础设施版本间无缝切换</h3><ul><li>声明式操作</li></ul><p>在Cloudformation之前，AWS已经推出了命令行工具或者SDK来管理AWS的资源，与它们“命令式”操作不同的是，Cloudformation提供一种“声明式”的特性。</p><p>“命令式”操作希望你去一步步编写程序以达到最终所期望的状态，而声明式只关心你想要的资源与资源的状态，Cloudformation会自动分析达到想要的状态需要进行怎样的操作。（理解声明式和命令式的不同，可参考<a href="http://www.aqee.net/post/imperative-vs-declarative.html">《声明式编程和命令式编程的比较》</a>）</p><ul><li>幂等性</li></ul><p>Cloudformation的声明式操作为其提供了幂等性的特性，以为我们在任何时刻、任何版本的基础架构运行新的Cloudformation代码，AWS每次都会帮助你生成相同的基础架构。</p><ul><li>原子性</li></ul><p>大部分人在数据库事务中了解到“原子性”。Cloudformation同样支持一种原子操作，要么成功，要么失败。失败的话可以自动回滚，而在一次失败操作中产生的资源会在回滚时被自动删除掉。</p><h3 id="纳入持续集成-部署流水线（CI-CD）"><a href="#纳入持续集成-部署流水线（CI-CD）" class="headerlink" title="纳入持续集成&#x2F;部署流水线（CI&#x2F;CD）"></a>纳入持续集成&#x2F;部署流水线（CI&#x2F;CD）</h3><p>“基础设施即代码”的代码化、自动化，为CI&#x2F;CD流水线管理基础设施提供了可能。</p><p>一种理想的方式是，和修改业务代码一样，当我们要对基础设施进行变更时，通过修改基础设施的代码，提交到git仓库，触发CI&#x2F;CD流水线运行基础设施代码，然后达到更新基础设施的目的。  </p><p><img src="https://baiyuan.wang/wp-content/uploads/2018/11/20181116134234318.jpg" alt="持续集成"> 持续集成</p><p>同时根据云计算服务商提供的反馈，更新CI&#x2F;CD流水线的部署状态：红则失败绿则失败。</p><p>QA或者团队可以根据测试结果和发布计划通过流水线，将基础设施和业务代码一起推向下一阶段。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2018/11/20181116134236418.jpg" alt="GoCD持续集成流水线"></p><p>GoCD持续集成流水线</p><h2 id="扩展思考："><a href="#扩展思考：" class="headerlink" title="扩展思考："></a>扩展思考：</h2><p>2018年 <a href="https://assets.thoughtworks.com/assets/technology-radar-vol-19-cn.pdf">ThoughtWorks 技术雷达19期</a>为我们介绍了一款名为LocalStack的云服务的Mock框架，这意味着我们可以在本地调试基础设施代码，或者为基础架构代码做单元或集成测试。原文如下：</p><blockquote><p>使用云服务时面对的一个挑战是如何在本地进行开发和测试。 LOCALSTACK 为 AWS 解决了这个问题。它提供了各种 AWS 服务的本地 测试替身 实现，包括 S3 、 Kinesis 、Dynamodb 和 Lambda 等。它基于现有的最佳工具如Kinesalite 、 Dynalite 、Moto 等构建，并增加了进程隔离与错误注入的功能。 LocalStack 的使用很简单，并附带了一个简单的 JUnit 运行器以及 JUnit 5扩展。我们在一些项目中使用过 LocalStack ，并对它印象深刻。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;熟悉AWS的肯定不会对Cloudformation感到陌生，AWS官方对Cloudformation的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AWS CloudFormation 云资源服务可使开发人员和系统管理员轻松有序地创建、管理和更新相关 AWS 云资源模</summary>
      
    
    
    
    <category term="技术" scheme="https://baiyuan.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>沟通从远离喷子开始</title>
    <link href="https://baiyuan.wang/communication-no-spray.html"/>
    <id>https://baiyuan.wang/communication-no-spray.html</id>
    <published>2018-11-11T11:00:37.000Z</published>
    <updated>2024-03-28T02:24:50.728Z</updated>
    
    <content type="html"><![CDATA[<p>喷子或者杠精可能不知道自己是喷子或者杠精，只是想通过反驳别人的观点彰显自己的存在感，满足自己的虚荣心并以此为傲。比较可惜的是，他们失去了一次是对别人思想学习与吸纳的机会。还有高级一点的喷子，不知道对方有时候说的话有他特殊的上下文，而是断章取义对方的文字，不去思考作者特定语境下的上下文，而是来找寻表面的漏洞来喷，对着这种人建议他们学习一下“语用学”。</p><p><img src="https://baiyuan.wang/wp-content/uploads/2019/02/20190222075700118.jpg" alt="沟通" title="沟通"></p><p>而对于喷子，不能太在意了，有些想法如果是自己某一时刻的真知灼见，大可写下来，因为它在这一时刻的语境下是对的，如果假以时日这些想法的确是错的，也无需菲薄自己，因为这是一种成长与完善自己想法的过程。如果过分在意别人的评论，就什么也不敢说了，就永远缺乏自信了。 跟很多人深入交流以后发现，同龄人一般心智差不多，首先不要想自己把别人强很多，然后先认为别人比自己聪明，如果认为别人说错的，那看看别人有没有可取的点。带着学习的态度，而不是上来就喷的态度。那要不要纠正呢，要但不强势。纠正之前首先确定自己真的理解别人的意思，这样可能更耐心平和一点。 当然了，判定喷子的标准是对方是不是带着探讨问题的善意，这种善意遵循 “倾听-反馈-融合” 的过程，先倾听对方的观点，拉齐双方进入相同的上下文，这个时候结合自己的生活阅历或者知识储备发表自己的观点，不天马行空，扩大scope。不是抱着一股求胜心来企图“碾压”对方，而是带着“求知心”，或者是“Develop others”的心态。 所以，现在不喜欢在朋友圈发表一些观点性的文字，因为很难在朋友圈短小的文字下介绍一个完整的上下文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;喷子或者杠精可能不知道自己是喷子或者杠精，只是想通过反驳别人的观点彰显自己的存在感，满足自己的虚荣心并以此为傲。比较可惜的是，他们失去了一次是对别人思想学习与吸纳的机会。还有高级一点的喷子，不知道对方有时候说的话有他特殊的上下文，而是断章取义对方的文字，不去思考作者特定语境</summary>
      
    
    
    
    <category term="极客视点" scheme="https://baiyuan.wang/categories/%E6%9E%81%E5%AE%A2%E8%A7%86%E7%82%B9/"/>
    
    
    <category term="沟通" scheme="https://baiyuan.wang/tags/%E6%B2%9F%E9%80%9A/"/>
    
  </entry>
  
</feed>
