---
title: 密钥管理：从薪火相传的密钥到“密码即服务”
tags:
  - 安全
url: 3477.html
id: 3477
categories:
  - 技术
abbrlink: 57829
date: 2019-10-10 10:49:08
---

> 一个可运行的软件项目通常包括两个要素：代码和密钥。我们通常会使用**无版本控制的FTP**和**有版本控制的SVN、git**等成熟的工具进行代码管理；而在我参加的大大小小、许许多多的项目中，密钥管理似乎缺乏成熟或标准的实践。本文将历数一下笔者在各个使用过的密钥管理实践并分析他们的优缺点。最后给大家推荐一款密钥管理工具：vault。

在软件项目开发中，密钥常常应用于下面四个场景：

*   本地开发：通常包括开发环境的数据库密码、用于访问第三方API的token、一些私有程序包仓库的凭证等。
*   CICD流水线：比如Push Docker镜像的Docker仓库的访问凭证、用于部署的云服务凭证（AWS Secret等）、用于访问K8S集群的token等
*   运行线上服务：线上服务启动所需的数据库密码、API Token等等，同时可能需要管理用于多套环境的不同密钥。
*   线上运维：线上发生事故时，需要在本地登入堡垒机（跳板机）的SSH Key或集群的访问凭证。

本地开发：“薪火相传”的密钥文件
----------------

当我们加入一个团队时，通常会有一个Readme文档告诉你项目代码库的下载链接。除此之外它会告诉你需要向团队“前辈”索要密钥文件，不然你的代码是不能在本地启动的。同时有人告诉你，这个密钥文件千万不要加入到git仓库中。 这种“薪火相传”的密钥管理方式，是最原始也是最常见的方式。它常常会伴随这样几个问题：

*   **密钥更换或者引入新的密钥后，团队其它成员因为没有得到最新的密钥文件，导致服务在本地起不来。**

比如你会听到这样的对话：

> *   A: “我拉了一下最近的代码，怎么就跑不起来了？”
> *   坐在旁边的B突然想起了什么：“好吧，我想起来了！我改了一下数据库密码，忘记告诉你了，我把最新的密钥发给你。”或者“我新加了一个功能因为使用API-KEY要访问消息队列，我在自己本地的环境变量里面加上了这个KEY，忘记告诉你们了”
> *   随后B把最新的密钥文件传给了A。几天后，同在项目的C也遇到了同样的问题……

*   **误提交到代码仓库问题：**

相信已经不止一次地听人提醒：**千万不要将密钥文件明文提交到git**。但是密钥泄露在代码仓库的问题依旧时有发生。

本地开发：将密钥加密后存放在Git仓库
-------------------

密钥和代码一样，在团队项目中同样需要进行共享、同步。密钥放在git仓库中本来是可以解决团队协作问题的，只不是不能被明文存储。那么，如果是将密钥加密后再提交到git仓库呢？ git-crypt便是这样一款可将git仓库中的密钥文件进行透明加密和解密的工具。它可以将密钥文件在push时加密，在pull下来后解密。更多介绍和使用说明可以参考：[https://github.com/AGWA/git-crypt](https://github.com/AGWA/git-crypt) 借助git版本控制工具，它可以实现：

*   使用git进行密码共享
*   密钥的版本控制
*   用户权限管理

问题：

*   密码可能在多个服务中使用，怎么同步？

持续集成流水线中的密钥管理
-------------

[![](https://wangbaiyuan.cn/wp-content/uploads/2019/10/Screen-Shot-2019-10-15-at-11.01.32.png)](https://wangbaiyuan.cn/wp-content/uploads/2019/10/Screen-Shot-2019-10-15-at-11.01.32.png)

在现在的Web项目的CI/CD流程中，通常会将项目代码经过构建打包生成docker镜像（制品）；在部署阶段，不同环境会**采用相同的docker镜像**，但是会使用**不同的环境变量**（比如集群、域名、数据库地址密码等）传入到docker的运行时，从而完成在不同环境的部署。 环境（变量）在不同的CI/CD中有不同形式，比如的Jenkins的Credential、GoCD的Environment、CircleCI的Context。 如果将所有的部署与运行时所需要的密钥数据都保存到pipeline上，会导致下面的问题

*   过多的密码字段，将密码作为环境变量一个个传递到服务十分复杂
*   pipeline存环境变量一般加密后难以解密，如果你设置完自己都忘记了，那这个环境就彻底忘了

解决的办法一般是**在pipeline上保存尽量少的密钥字段**，我们通过一次认证就可以具备获取所有密钥数据的权限。

密码即服务：Hashicorp Vault
---------------------

在云和基础设施自动化时代，我们应该知道一家名为Hashcorp的公司，其代表作有知名的terraform、consul、packer、vagrant。vault也是这家公司的产品之一，它通过API将密码以服务的方式暴露出去。它可以提供：

*   中心化的密码服务
*   更安全的加密存储
*   密码的服务化
*   丰富的第三方集成：实现认证的扩展、多平台密钥管理

![Vault架构](https://wangbaiyuan.cn/wp-content/uploads/2019/10/20191015025844212.jpg)

服务化后的vault可以做到

*   与Github身份认证集成，比如你可以做到只允许在特定git organization下的用户才能获取密钥
*   签发临时的SSH证书：比如你只允许一个30分钟内有效的SSH KEY来登录堡垒机
*   生成临时的AWS KEY：比如你只能用一个30分钟内有效的AWS凭证
*   定期更换数据库密码，因为数据库长期不更换会加大泄露的风险
*   OTP：基于时间的临时密码
*   密码权限策略：只允许特定的微服务读取或者写入指定的密钥
*   密码的revoke（同事下项目了怎么办？）

### 最佳实践

*   不在本地持久化存储密钥，密钥的只存于当前terminal的环境变量里并随terminal session关闭而销毁
*   密钥是有时效性的，定期轮换
*   密钥获取者是有身份的，并且有权限控制
*   团队成员下项目时，revoke成员的token